From 7d81fd5ed42af46c6e5eef15b4dce7172a2e571d Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Tue, 31 Jan 2023 21:02:54 +0800
Subject: net/hns3: fix RSS key size compatibility

[ upstream commit 5172f9c464aa315a9d45b9177af71b4f99d55cdb ]

For better compatibility, the RSS key size of PF and VF are obtained
from firmware. However, the outdated HNS3_RSS_KEY_SIZE macro is still
utilized in many locations as the key size.

Fixes: 9c740336f024 ("net/hns3: get device specifications from firmware")
Cc: stable@dpdk.org

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Dongdong Liu <liudongdong3@huawei.com>
---
 drivers/net/hns3/hns3_common.c | 12 +++++++++++-
 drivers/net/hns3/hns3_flow.c   | 26 ++++++++++++--------------
 drivers/net/hns3/hns3_rss.c    | 23 +++++++++++------------
 drivers/net/hns3/hns3_rss.h    |  3 ++-
 4 files changed, 36 insertions(+), 28 deletions(-)

diff --git a/drivers/net/hns3/hns3_common.c b/drivers/net/hns3/hns3_common.c
index 212b35d842..9bfbe1161f 100644
--- a/drivers/net/hns3/hns3_common.c
+++ b/drivers/net/hns3/hns3_common.c
@@ -129,7 +129,7 @@ hns3_dev_infos_get(struct rte_eth_dev *eth_dev, struct rte_eth_dev_info *info)
 	};
 
 	info->reta_size = hw->rss_ind_tbl_size;
-	info->hash_key_size = HNS3_RSS_KEY_SIZE;
+	info->hash_key_size = hw->rss_key_size;
 	info->flow_type_rss_offloads = HNS3_ETH_RSS_SUPPORT;
 
 	info->default_rxportconf.burst_size = HNS3_DEFAULT_PORT_CONF_BURST_SIZE;
@@ -893,6 +893,16 @@ hns3_check_dev_specifications(struct hns3_hw *hw)
 		return -EINVAL;
 	}
 
+	if (hw->rss_key_size == 0 || hw->rss_key_size > HNS3_RSS_KEY_SIZE_MAX) {
+		hns3_err(hw, "the RSS key size obtained (%u) is invalid, and should not be zero or exceed the maximum(%u)",
+			 hw->rss_key_size, HNS3_RSS_KEY_SIZE_MAX);
+		return -EINVAL;
+	}
+
+	if (hw->rss_key_size > HNS3_RSS_KEY_SIZE)
+		hns3_warn(hw, "the RSS key size obtained (%u) is greater than the default key size (%u)",
+			  hw->rss_key_size, HNS3_RSS_KEY_SIZE);
+
 	return 0;
 }
 
diff --git a/drivers/net/hns3/hns3_flow.c b/drivers/net/hns3/hns3_flow.c
index 95609f8483..a18ec7650d 100644
--- a/drivers/net/hns3/hns3_flow.c
+++ b/drivers/net/hns3/hns3_flow.c
@@ -1406,10 +1406,10 @@ hns3_parse_rss_filter(struct rte_eth_dev *dev,
 		return rte_flow_error_set(error, ENOTSUP,
 					  RTE_FLOW_ERROR_TYPE_ACTION_CONF, act,
 					  "a nonzero RSS encapsulation level is not supported");
-	if (rss->key_len && rss->key_len != RTE_DIM(rss_conf->key))
+	if (rss->key_len && rss->key_len != hw->rss_key_size)
 		return rte_flow_error_set(error, ENOTSUP,
 					  RTE_FLOW_ERROR_TYPE_ACTION_CONF, act,
-					  "RSS hash key must be exactly 40 bytes");
+					  "invalid RSS key length");
 
 	if (!hns3_rss_input_tuple_supported(hw, rss))
 		return rte_flow_error_set(error, EINVAL,
@@ -1443,16 +1443,6 @@ hns3_disable_rss(struct hns3_hw *hw)
 	return 0;
 }
 
-static void
-hns3_adjust_rss_key(struct hns3_hw *hw, struct rte_flow_action_rss *rss_conf)
-{
-	if (rss_conf->key == NULL || rss_conf->key_len < HNS3_RSS_KEY_SIZE) {
-		hns3_warn(hw, "Default RSS hash key to be set");
-		rss_conf->key = hns3_hash_key;
-		rss_conf->key_len = HNS3_RSS_KEY_SIZE;
-	}
-}
-
 static int
 hns3_parse_rss_algorithm(struct hns3_hw *hw, enum rte_eth_hash_function *func,
 			 uint8_t *hash_algo)
@@ -1485,9 +1475,16 @@ hns3_parse_rss_algorithm(struct hns3_hw *hw, enum rte_eth_hash_function *func,
 static int
 hns3_hw_rss_hash_set(struct hns3_hw *hw, struct rte_flow_action_rss *rss_config)
 {
+	uint8_t rss_key[HNS3_RSS_KEY_SIZE_MAX] = {0};
+	bool use_default_key = false;
 	int ret;
 
-	hns3_adjust_rss_key(hw, rss_config);
+	if (rss_config->key == NULL || rss_config->key_len != hw->rss_key_size) {
+		hns3_warn(hw, "Default RSS hash key to be set");
+		memcpy(rss_key, hns3_hash_key,
+			RTE_MIN(sizeof(hns3_hash_key), hw->rss_key_size));
+		use_default_key = true;
+	}
 
 	ret = hns3_parse_rss_algorithm(hw, &rss_config->func,
 				       &hw->rss_info.hash_algo);
@@ -1495,7 +1492,8 @@ hns3_hw_rss_hash_set(struct hns3_hw *hw, struct rte_flow_action_rss *rss_config)
 		return ret;
 
 	ret = hns3_rss_set_algo_key(hw, hw->rss_info.hash_algo,
-				    rss_config->key, HNS3_RSS_KEY_SIZE);
+				    use_default_key ? rss_key : rss_config->key,
+				    hw->rss_key_size);
 	if (ret)
 		return ret;
 
diff --git a/drivers/net/hns3/hns3_rss.c b/drivers/net/hns3/hns3_rss.c
index 3db7bf0445..d6e0754273 100644
--- a/drivers/net/hns3/hns3_rss.c
+++ b/drivers/net/hns3/hns3_rss.c
@@ -316,7 +316,7 @@ hns3_rss_set_algo_key(struct hns3_hw *hw, uint8_t hash_algo,
 		}
 	}
 	/* Update the shadow RSS key with user specified */
-	memcpy(hw->rss_info.key, key, HNS3_RSS_KEY_SIZE);
+	memcpy(hw->rss_info.key, key, hw->rss_key_size);
 	return 0;
 }
 
@@ -498,9 +498,9 @@ hns3_dev_rss_hash_update(struct rte_eth_dev *dev,
 	uint8_t *key = rss_conf->rss_key;
 	int ret;
 
-	if (key && key_len != HNS3_RSS_KEY_SIZE) {
+	if (key && key_len != hw->rss_key_size) {
 		hns3_err(hw, "the hash key len(%u) is invalid, must be %u",
-			 key_len, HNS3_RSS_KEY_SIZE);
+			 key_len, hw->rss_key_size);
 		return -EINVAL;
 	}
 
@@ -511,7 +511,7 @@ hns3_dev_rss_hash_update(struct rte_eth_dev *dev,
 
 	if (key) {
 		ret = hns3_rss_set_algo_key(hw, hw->rss_info.hash_algo,
-					    key, HNS3_RSS_KEY_SIZE);
+					    key, hw->rss_key_size);
 		if (ret)
 			goto set_algo_key_fail;
 	}
@@ -547,9 +547,9 @@ hns3_dev_rss_hash_conf_get(struct rte_eth_dev *dev,
 	rss_conf->rss_hf = rss_cfg->conf.types;
 
 	/* Get the RSS Key required by the user */
-	if (rss_conf->rss_key && rss_conf->rss_key_len >= HNS3_RSS_KEY_SIZE) {
-		memcpy(rss_conf->rss_key, rss_cfg->key, HNS3_RSS_KEY_SIZE);
-		rss_conf->rss_key_len = HNS3_RSS_KEY_SIZE;
+	if (rss_conf->rss_key && rss_conf->rss_key_len >= hw->rss_key_size) {
+		memcpy(rss_conf->rss_key, rss_cfg->key, hw->rss_key_size);
+		rss_conf->rss_key_len = hw->rss_key_size;
 	}
 	rte_spinlock_unlock(&hw->lock);
 
@@ -754,8 +754,8 @@ hns3_rss_set_default_args(struct hns3_hw *hw)
 	/* Default hash algorithm */
 	rss_cfg->conf.func = RTE_ETH_HASH_FUNCTION_TOEPLITZ;
 
-	/* Default RSS key */
-	memcpy(rss_cfg->key, hns3_hash_key, HNS3_RSS_KEY_SIZE);
+	memcpy(rss_cfg->key, hns3_hash_key,
+		RTE_MIN(sizeof(hns3_hash_key), hw->rss_key_size));
 
 	/* Initialize RSS indirection table */
 	for (i = 0; i < hw->rss_ind_tbl_size; i++)
@@ -788,9 +788,8 @@ hns3_config_rss(struct hns3_adapter *hns)
 		break;
 	}
 
-	/* Configure RSS hash algorithm and hash key */
-	ret = hns3_rss_set_algo_key(hw, hw->rss_info.hash_algo, hash_key,
-				    HNS3_RSS_KEY_SIZE);
+	ret = hns3_rss_set_algo_key(hw, rss_cfg->hash_algo,
+				    hash_key, hw->rss_key_size);
 	if (ret)
 		return ret;
 
diff --git a/drivers/net/hns3/hns3_rss.h b/drivers/net/hns3/hns3_rss.h
index b7f62ca1ee..d6f81996f4 100644
--- a/drivers/net/hns3/hns3_rss.h
+++ b/drivers/net/hns3/hns3_rss.h
@@ -29,6 +29,7 @@
 #define HNS3_RSS_IND_TBL_SIZE	512 /* The size of hash lookup table */
 #define HNS3_RSS_IND_TBL_SIZE_MAX 2048
 #define HNS3_RSS_KEY_SIZE	40
+#define HNS3_RSS_KEY_SIZE_MAX	128
 #define HNS3_RSS_SET_BITMAP_MSK	0xffff
 
 #define HNS3_RSS_HASH_ALGO_TOEPLITZ	0
@@ -41,7 +42,7 @@ struct hns3_rss_conf {
 	/* RSS parameters :algorithm, flow_types,  key, queue */
 	struct rte_flow_action_rss conf;
 	uint8_t hash_algo; /* hash function type defined by hardware */
-	uint8_t key[HNS3_RSS_KEY_SIZE];  /* Hash key */
+	uint8_t key[HNS3_RSS_KEY_SIZE_MAX];  /* Hash key */
 	uint16_t rss_indirection_tbl[HNS3_RSS_IND_TBL_SIZE_MAX];
 	uint16_t queue[HNS3_RSS_QUEUES_BUFFER_NUM]; /* Queues indices to use */
 	bool valid; /* check if RSS rule is valid */
-- 
2.23.0

