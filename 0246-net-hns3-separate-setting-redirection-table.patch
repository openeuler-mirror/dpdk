From 5a9f2de85e9f9185165c7fe82247ef6125ef4115 Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Fri, 10 Mar 2023 17:35:10 +0800
Subject: net/hns3: separate setting redirection table

[ upstream commit a421cb93462932717f23c5d8342381726e547ba6 ]

The settings of redirection table comes from the ethdev ops (like,
dev_configure and rss_hash_update) and rte_flow API. For the ethdev
ops, driver has to save it to rss_info::rss_indirection_tbl in hns3_hw
structure so as to it can be restored when reset is triggered.
While rte_flow API no need to use this field to save, they has a global
RSS flow list to maintain all rules which can be used to restore the
table during the reset phase.

Cc: stable@dpdk.org

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Dongdong Liu <liudongdong3@huawei.com>
---
 drivers/net/hns3/hns3_flow.c |  2 --
 drivers/net/hns3/hns3_rss.c  | 21 +++++++++++++--------
 2 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/drivers/net/hns3/hns3_flow.c b/drivers/net/hns3/hns3_flow.c
index 0cb6914982..875c0eec11 100644
--- a/drivers/net/hns3/hns3_flow.c
+++ b/drivers/net/hns3/hns3_flow.c
@@ -1519,8 +1519,6 @@ hns3_update_indir_table(struct hns3_hw *hw,
 	uint32_t i;
 
 	/* Fill in redirection table */
-	memcpy(indir_tbl, hw->rss_info.rss_indirection_tbl,
-	       sizeof(hw->rss_info.rss_indirection_tbl));
 	for (i = 0, j = 0; i < hw->rss_ind_tbl_size; i++, j++) {
 		j %= num;
 		if (conf->queue[j] >= hw->alloc_rss_size) {
diff --git a/drivers/net/hns3/hns3_rss.c b/drivers/net/hns3/hns3_rss.c
index 401e3adfdf..751033d98f 100644
--- a/drivers/net/hns3/hns3_rss.c
+++ b/drivers/net/hns3/hns3_rss.c
@@ -473,10 +473,6 @@ hns3_set_rss_indir_table(struct hns3_hw *hw, uint16_t *indir, uint16_t size)
 		}
 	}
 
-	/* Update redirection table of hw */
-	memcpy(hw->rss_info.rss_indirection_tbl, indir,
-	       sizeof(uint16_t) * size);
-
 	return 0;
 }
 
@@ -542,8 +538,11 @@ hns3_rss_reset_indir_table(struct hns3_hw *hw)
 	}
 
 	ret = hns3_set_rss_indir_table(hw, lut, hw->rss_ind_tbl_size);
-	if (ret)
-		hns3_err(hw, "RSS uninit indir table failed: %d", ret);
+	if (ret != 0)
+		hns3_err(hw, "RSS uninit indir table failed, ret = %d.", ret);
+	else
+		memcpy(hw->rss_info.rss_indirection_tbl, lut,
+		       sizeof(uint16_t) * hw->rss_ind_tbl_size);
 	rte_free(lut);
 
 	return ret;
@@ -855,12 +854,12 @@ hns3_dev_rss_reta_update(struct rte_eth_dev *dev,
 		idx = i / RTE_ETH_RETA_GROUP_SIZE;
 		shift = i % RTE_ETH_RETA_GROUP_SIZE;
 		if (reta_conf[idx].reta[shift] >= hw->alloc_rss_size) {
-			rte_spinlock_unlock(&hw->lock);
 			hns3_err(hw, "queue id(%u) set to redirection table "
 				 "exceeds queue number(%u) allocated to a TC",
 				 reta_conf[idx].reta[shift],
 				 hw->alloc_rss_size);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto out;
 		}
 
 		if (reta_conf[idx].mask & (1ULL << shift))
@@ -869,7 +868,13 @@ hns3_dev_rss_reta_update(struct rte_eth_dev *dev,
 
 	ret = hns3_set_rss_indir_table(hw, indirection_tbl,
 				       hw->rss_ind_tbl_size);
+	if (ret != 0)
+		goto out;
 
+	memcpy(rss_cfg->rss_indirection_tbl, indirection_tbl,
+	       sizeof(uint16_t) * hw->rss_ind_tbl_size);
+
+out:
 	rte_spinlock_unlock(&hw->lock);
 	return ret;
 }
-- 
2.23.0

