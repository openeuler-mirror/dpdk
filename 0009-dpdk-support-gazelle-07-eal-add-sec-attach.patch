From 036103c944eac5c6c50e68fc1dad9d72a00b5c2c Mon Sep 17 00:00:00 2001
From: wuchangsheng <wuchangsheng2@huawei.com>
Date: Tue, 30 Mar 2021 17:02:45 +0800
Subject: [PATCH] dpdk-support-gazelle-07-eal-add-sec-attach

---
 lib/librte_eal/linux/eal/eal.c | 66 ++++++++++++++++++++++++++--------
 1 file changed, 52 insertions(+), 14 deletions(-)

diff --git a/lib/librte_eal/linux/eal/eal.c b/lib/librte_eal/linux/eal/eal.c
index 8bb1842..735afcd 100644
--- a/lib/librte_eal/linux/eal/eal.c
+++ b/lib/librte_eal/linux/eal/eal.c
@@ -103,6 +103,12 @@ static char runtime_dir[PATH_MAX];
 
 static const char *default_runtime_dir = "/var/run";
 
+/****** APIs for libnet ******/
+static unsigned int sec_count = 0;
+static struct rte_config sec_rte_config[RTE_MAX_SECONDARY];
+static struct internal_config sec_internal_config[RTE_MAX_SECONDARY];
+static char sec_runtime_dir[RTE_MAX_SECONDARY][PATH_MAX];
+
 static bool master_set_affinity = true;
 bool
 eal_is_master_set_affinity(void)
@@ -111,7 +117,8 @@ eal_is_master_set_affinity(void)
 }
 
 int
-eal_create_runtime_dir(void)
+eal_create_runtime_dir(char *runtime_dir, const int buflen,
+		const struct internal_config *conf)
 {
 	const char *directory = default_runtime_dir;
 	const char *xdg_runtime_dir = getenv("XDG_RUNTIME_DIR");
@@ -134,8 +141,8 @@ eal_create_runtime_dir(void)
 	}
 
 	/* create prefix-specific subdirectory under DPDK runtime dir */
-	ret = snprintf(runtime_dir, sizeof(runtime_dir), "%s/%s",
-			tmp, eal_get_hugefile_prefix());
+	ret = snprintf(runtime_dir, buflen, "%s/%s",
+			tmp, conf->hugefile_prefix);
 	if (ret < 0 || ret == sizeof(runtime_dir)) {
 		RTE_LOG(ERR, EAL, "Error creating prefix-specific runtime path name\n");
 		return -1;
@@ -246,12 +253,18 @@ eal_clean_runtime_dir(void)
 	return -1;
 }
 
-const char *
+char *
 rte_eal_get_runtime_dir(void)
 {
 	return runtime_dir;
 }
 
+char *
+rte_eal_sec_get_runtime_dir(const int sec_idx)
+{
+	return sec_runtime_dir[sec_idx];
+}
+
 /* Return user provided mbuf pool ops name */
 const char *
 rte_eal_mbuf_user_pool_ops(void)
@@ -266,6 +279,18 @@ rte_eal_get_configuration(void)
 	return &rte_config;
 }
 
+struct rte_config *
+rte_eal_sec_get_configuration(const int sec_idx)
+{
+	return &sec_rte_config[sec_idx];
+}
+
+struct internal_config *
+rte_eal_sec_get_internal_config(const int sec_idx)
+{
+	return &sec_internal_config[sec_idx];
+}
+
 enum rte_iova_mode
 rte_eal_iova_mode(void)
 {
@@ -395,18 +420,22 @@ rte_eal_config_create(void)
 
 /* attach to an existing shared memory config */
 static int
-rte_eal_config_attach(void)
+__rte_eal_config_attach(const int mmap_flags, int *mem_cfg_fd,
+		const char *runtime_dir,
+		const struct internal_config *internal_cfg,
+		struct rte_config *rte_cfg)
 {
 	struct rte_mem_config *mem_config;
+	int mcfg_fd = *mem_cfg_fd;
 
-	const char *pathname = eal_runtime_config_path();
+	const char *pathname = eal_sec_runtime_config_path(runtime_dir);
 
-	if (internal_config.no_shconf)
+	if (internal_cfg->no_shconf)
 		return 0;
 
-	if (mem_cfg_fd < 0){
-		mem_cfg_fd = open(pathname, O_RDWR);
-		if (mem_cfg_fd < 0) {
+	if (mcfg_fd < 0){
+		mcfg_fd = open(pathname, O_RDWR);
+		if (mcfg_fd < 0) {
 			RTE_LOG(ERR, EAL, "Cannot open '%s' for rte_mem_config\n",
 				pathname);
 			return -1;
@@ -415,20 +444,29 @@ rte_eal_config_attach(void)
 
 	/* map it as read-only first */
 	mem_config = (struct rte_mem_config *) mmap(NULL, sizeof(*mem_config),
-			PROT_READ, MAP_SHARED, mem_cfg_fd, 0);
+			mmap_flags, MAP_SHARED, mcfg_fd, 0);
 	if (mem_config == MAP_FAILED) {
-		close(mem_cfg_fd);
-		mem_cfg_fd = -1;
+		close(mcfg_fd);
+		mcfg_fd = -1;
 		RTE_LOG(ERR, EAL, "Cannot mmap memory for rte_config! error %i (%s)\n",
 			errno, strerror(errno));
 		return -1;
 	}
 
-	rte_config.mem_config = mem_config;
+	rte_cfg->mem_config = mem_config;
+	*mem_cfg_fd = mcfg_fd;
 
 	return 0;
 }
 
+static int
+rte_eal_config_attach(void)
+{
+	return __rte_eal_config_attach(PROT_READ, &mem_cfg_fd,
+				rte_eal_get_runtime_dir(), &internal_config,
+				rte_eal_get_configuration());
+}
+
 /* reattach the shared config at exact memory location primary process has it */
 static int
 rte_eal_config_reattach(void)
-- 
2.23.0

