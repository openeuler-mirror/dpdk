From 464bfbd345224ddb04399297988c0d99cbe8acc6 Mon Sep 17 00:00:00 2001
From: Chengchang Tang <tangchengchang@huawei.com>
Date: Wed, 22 Sep 2021 15:09:13 +0800
Subject: [PATCH 11/17] net/bonding: fix RSS key length

Currently the hash_key_size information has not been set. So, apps can
not get the key size from dev_info(), this make some problem.

e.g, in testpmd, the hash_key_size will be checked before configure
or get the hash key:
testpmd> show port 4 rss-hash
dev_info did not provide a valid hash key size
testpmd> show port 4 rss-hash key
dev_info did not provide a valid hash key size
testpmd> port config 4 rss-hash-key ipv4 (hash key)
dev_info did not provide a valid hash key size

In this patch, the meaning of rss_key_len has been modified. It only
indicated the length of the configured hash key before. Therefore,
its value depends on the user's configuration. This seems unreasonable.
And now, it indicates the minimum hash key length required by the
bonded device. Its value will be the shortest hash key among all slave
drivers.

Fixes: 734ce47f71e0 ("bonding: support RSS dynamic configuration")
Cc: stable@dpdk.org

Signed-off-by: Chengchang Tang <tangchengchang@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/bonding/rte_eth_bond_api.c |  6 ++++
 drivers/net/bonding/rte_eth_bond_pmd.c | 44 ++++++++++++++++----------
 2 files changed, 33 insertions(+), 17 deletions(-)

diff --git a/drivers/net/bonding/rte_eth_bond_api.c b/drivers/net/bonding/rte_eth_bond_api.c
index 44775f61e..c751a1242 100644
--- a/drivers/net/bonding/rte_eth_bond_api.c
+++ b/drivers/net/bonding/rte_eth_bond_api.c
@@ -290,6 +290,7 @@ eth_bond_slave_inherit_dev_info_rx_first(struct bond_dev_private *internals,
 	struct rte_eth_rxconf *rxconf_i = &internals->default_rxconf;
 
 	internals->reta_size = di->reta_size;
+	internals->rss_key_len = di->hash_key_size;
 
 	/* Inherit Rx offload capabilities from the first slave device */
 	internals->rx_offload_capa = di->rx_offload_capa;
@@ -385,6 +386,11 @@ eth_bond_slave_inherit_dev_info_rx_next(struct bond_dev_private *internals,
 	 */
 	if (internals->reta_size > di->reta_size)
 		internals->reta_size = di->reta_size;
+	if (internals->rss_key_len > di->hash_key_size) {
+		RTE_BOND_LOG(WARNING, "slave has different rss key size, "
+				"configuring rss may fail");
+		internals->rss_key_len = di->hash_key_size;
+	}
 
 	if (!internals->max_rx_pktlen &&
 	    di->max_rx_pktlen < internals->candidate_max_rx_pktlen)
diff --git a/drivers/net/bonding/rte_eth_bond_pmd.c b/drivers/net/bonding/rte_eth_bond_pmd.c
index 057b1ada5..c21df6d6f 100644
--- a/drivers/net/bonding/rte_eth_bond_pmd.c
+++ b/drivers/net/bonding/rte_eth_bond_pmd.c
@@ -1705,14 +1705,11 @@ slave_configure(struct rte_eth_dev *bonded_eth_dev,
 
 	/* If RSS is enabled for bonding, try to enable it for slaves  */
 	if (bonded_eth_dev->data->dev_conf.rxmode.mq_mode & ETH_MQ_RX_RSS_FLAG) {
-		if (internals->rss_key_len != 0) {
-			slave_eth_dev->data->dev_conf.rx_adv_conf.rss_conf.rss_key_len =
+		/* rss_key won't be empty if RSS is configured in bonded dev */
+		slave_eth_dev->data->dev_conf.rx_adv_conf.rss_conf.rss_key_len =
 					internals->rss_key_len;
-			slave_eth_dev->data->dev_conf.rx_adv_conf.rss_conf.rss_key =
+		slave_eth_dev->data->dev_conf.rx_adv_conf.rss_conf.rss_key =
 					internals->rss_key;
-		} else {
-			slave_eth_dev->data->dev_conf.rx_adv_conf.rss_conf.rss_key = NULL;
-		}
 
 		slave_eth_dev->data->dev_conf.rx_adv_conf.rss_conf.rss_hf =
 				bonded_eth_dev->data->dev_conf.rx_adv_conf.rss_conf.rss_hf;
@@ -2234,6 +2231,7 @@ bond_ethdev_info(struct rte_eth_dev *dev, struct rte_eth_dev_info *dev_info)
 	dev_info->flow_type_rss_offloads = internals->flow_type_rss_offloads;
 
 	dev_info->reta_size = internals->reta_size;
+	dev_info->hash_key_size = internals->rss_key_len;
 
 	return 0;
 }
@@ -3023,13 +3021,15 @@ bond_ethdev_rss_hash_update(struct rte_eth_dev *dev,
 	if (bond_rss_conf.rss_hf != 0)
 		dev->data->dev_conf.rx_adv_conf.rss_conf.rss_hf = bond_rss_conf.rss_hf;
 
-	if (bond_rss_conf.rss_key && bond_rss_conf.rss_key_len <
-			sizeof(internals->rss_key)) {
-		if (bond_rss_conf.rss_key_len == 0)
-			bond_rss_conf.rss_key_len = 40;
-		internals->rss_key_len = bond_rss_conf.rss_key_len;
+	if (bond_rss_conf.rss_key) {
+		if (bond_rss_conf.rss_key_len < internals->rss_key_len)
+			return -EINVAL;
+		else if (bond_rss_conf.rss_key_len > internals->rss_key_len)
+			RTE_BOND_LOG(WARNING, "rss_key will be truncated");
+
 		memcpy(internals->rss_key, bond_rss_conf.rss_key,
 				internals->rss_key_len);
+		bond_rss_conf.rss_key_len = internals->rss_key_len;
 	}
 
 	for (i = 0; i < internals->slave_count; i++) {
@@ -3491,14 +3491,24 @@ bond_ethdev_configure(struct rte_eth_dev *dev)
 	 * Fall back to default RSS key if the key is not specified
 	 */
 	if (dev->data->dev_conf.rxmode.mq_mode & ETH_MQ_RX_RSS) {
-		if (dev->data->dev_conf.rx_adv_conf.rss_conf.rss_key != NULL) {
-			internals->rss_key_len =
-				dev->data->dev_conf.rx_adv_conf.rss_conf.rss_key_len;
-			memcpy(internals->rss_key,
-			       dev->data->dev_conf.rx_adv_conf.rss_conf.rss_key,
+		struct rte_eth_rss_conf *rss_conf =
+			&dev->data->dev_conf.rx_adv_conf.rss_conf;
+		if (rss_conf->rss_key != NULL) {
+			if (internals->rss_key_len > rss_conf->rss_key_len) {
+				RTE_BOND_LOG(ERR, "Invalid rss key length(%u)",
+						rss_conf->rss_key_len);
+				return -EINVAL;
+			}
+
+			memcpy(internals->rss_key, rss_conf->rss_key,
 			       internals->rss_key_len);
 		} else {
-			internals->rss_key_len = sizeof(default_rss_key);
+			if (internals->rss_key_len > sizeof(default_rss_key)) {
+				RTE_BOND_LOG(ERR,
+				       "There is no suitable default hash key");
+				return -EINVAL;
+			}
+
 			memcpy(internals->rss_key, default_rss_key,
 			       internals->rss_key_len);
 		}
-- 
2.23.0

