From d81c5f9a3e78ae18f78caeb8791e8e3947151273 Mon Sep 17 00:00:00 2001
From: wuchangsheng <wuchangsheng2@huawei.com>
Date: Tue, 30 Mar 2021 17:16:50 +0800
Subject: [PATCH] dpdk-support-gazelle-09-eal-add-libnetapi

---
 lib/librte_eal/linux/eal/eal.c | 119 +++++++++++++++++++++++++++++++--
 1 file changed, 112 insertions(+), 7 deletions(-)

diff --git a/lib/librte_eal/linux/eal/eal.c b/lib/librte_eal/linux/eal/eal.c
index 2de9914..a1f2b42 100644
--- a/lib/librte_eal/linux/eal/eal.c
+++ b/lib/librte_eal/linux/eal/eal.c
@@ -901,7 +901,11 @@ __eal_parse_args(int argc, char **argv, char *runtime_dir, const int buflen,
 			break;
 		}
 		case OPT_MATCH_ALLOCATIONS_NUM:
-			internal_config.match_allocations = 1;
+			internal_cfg->match_allocations = 1;
+			break;
+
+		case OPT_MAP_PERFECT_NUM:
+			internal_cfg->map_perfect = 1;
 			break;
 
 		default:
@@ -924,20 +928,25 @@ __eal_parse_args(int argc, char **argv, char *runtime_dir, const int buflen,
 	}
 
 	/* create runtime data directory */
-	if (internal_config.no_shconf == 0 &&
-			eal_create_runtime_dir() < 0) {
+	if (internal_cfg->no_shconf == 0 &&
+			eal_create_runtime_dir(runtime_dir, buflen, internal_cfg) < 0) {
 		RTE_LOG(ERR, EAL, "Cannot create runtime directory\n");
 		ret = -1;
 		goto out;
 	}
 
-	if (eal_adjust_config(&internal_config) != 0) {
-		ret = -1;
-		goto out;
+	if (!internal_cfg->pri_and_sec) {
+		ret = eal_adjust_config(internal_cfg);
+		if (ret != 0)
+			goto out;
+	} else {
+		ret = eal_sec_adjust_config(internal_cfg);
+		if (ret != 0)
+			goto out;
 	}
 
 	/* sanity checks */
-	if (eal_check_common_options(&internal_config) != 0) {
+	if (eal_check_common_options(internal_cfg, rte_cfg) != 0) {
 		eal_usage(prgname);
 		ret = -1;
 		goto out;
@@ -1504,3 +1513,99 @@ rte_eal_check_module(const char *module_name)
 	/* Module has been found */
 	return 1;
 }
+
+
+/****** APIs for libnet ******/
+int
+rte_eal_sec_attach(int argc, char **argv)
+{
+	int ret;
+	int sec_idx = -1;
+	struct internal_config *lc_internal_cfg = NULL;
+
+	if (sec_count >= RTE_MAX_SECONDARY) {
+		RTE_LOG(ERR, EAL, "Too many secondary processes: %d.\n", sec_count);
+		rte_errno = EINVAL;
+		return -1;
+	}
+	
+	for (int i = 0; i < RTE_MAX_SECONDARY; ++i) {
+		if (sec_internal_config[i].pri_and_sec == 0) {
+			sec_internal_config[i].pri_and_sec = 1;
+			sec_idx = i;
+			break;
+		}
+	}
+	lc_internal_cfg = rte_eal_sec_get_internal_config(sec_idx);
+	
+	eal_reset_internal_config(lc_internal_cfg);
+	
+	ret = eal_sec_parse_args(argc, argv, sec_idx);
+	if (ret < 0) {
+		if (ret == -EALREADY) {
+			RTE_LOG(ERR, EAL, "file_refix %s already called initialization.\n",
+					lc_internal_cfg->hugefile_prefix);
+			rte_errno = EALREADY;
+		} else {
+			RTE_LOG(ERR, EAL, "Invalid 'command line' arguments.\n");
+			rte_errno = EINVAL;
+		}
+		return -1;
+	}
+
+	rte_sec_config_init(sec_idx);
+
+	ret = rte_eal_sec_memory_init(sec_idx);
+	if (ret < 0) {
+		RTE_LOG(ERR, EAL, "Cannot init memory\n");
+		rte_errno = ENOMEM;
+		return -1;
+	}
+	
+	sec_count++;
+	return 0;
+}
+
+int
+rte_eal_sec_detach(const char *file_prefix, int length)
+{
+	int ret;
+	int sec_idx = -1;
+
+	if (!file_prefix || length <= 0) {
+		RTE_LOG(ERR, EAL, "Invalid 'file_prefix or length' arguments.\n");
+		rte_errno = EINVAL;
+		return -1;
+	}
+	
+	for (int i = 0; i < RTE_MAX_SECONDARY; ++i) {
+		if (sec_internal_config[i].pri_and_sec == 0)
+			continue;
+		if (!strncmp(sec_internal_config[i].hugefile_prefix, file_prefix, length)) {
+			sec_idx = i;
+			break;
+		}
+	}
+	if (sec_idx == -1) {
+		RTE_LOG(ERR, EAL, "Cannot find file_prefix %s.\n", file_prefix);
+		rte_errno = EINVAL;
+		return -1;
+	}
+
+	ret = rte_eal_sec_memory_cleanup(sec_idx);
+	if (ret < 0) {
+		RTE_LOG(ERR, EAL, "Cannot cleanup memory\n");
+		rte_errno = ENOMEM;
+		return -1;
+	}
+
+	ret = eal_sec_config_cleanup(sec_idx);
+	if (ret < 0) {
+		RTE_LOG(ERR, EAL, "Cannot cleanup hugepage sharefile.\n");
+		rte_errno = EACCES;
+		return -1;
+	}
+
+	sec_count--;
+	return 0;
+}
-- 
2.23.0

