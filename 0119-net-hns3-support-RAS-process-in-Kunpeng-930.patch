From 9a12486ffd05e3940cd533ac5ba03ba641c864f2 Mon Sep 17 00:00:00 2001
From: Hongbo Zheng <zhenghongbo3@huawei.com>
Date: Mon, 19 Apr 2021 15:36:44 +0800
Subject: [PATCH 119/189] net/hns3: support RAS process in Kunpeng 930

Kunpeng 930 uses a new RAS exception reporting solution.
The reset type and exception status are reported through
firmware. The driver modifies the corresponding code to
adapt to the new solution.

Signed-off-by: Hongbo Zheng <zhenghongbo3@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_cmd.c       |   9 +-
 drivers/net/hns3/hns3_cmd.h       |   2 +
 drivers/net/hns3/hns3_ethdev.c    |  11 +-
 drivers/net/hns3/hns3_ethdev.h    |  23 ++-
 drivers/net/hns3/hns3_ethdev_vf.c |   3 +-
 drivers/net/hns3/hns3_intr.c      | 296 +++++++++++++++++++++++++++++++++++++-
 drivers/net/hns3/hns3_intr.h      |  70 +++++++++
 7 files changed, 399 insertions(+), 15 deletions(-)

diff --git a/drivers/net/hns3/hns3_cmd.c b/drivers/net/hns3/hns3_cmd.c
index 15bf781..f3588ab 100644
--- a/drivers/net/hns3/hns3_cmd.c
+++ b/drivers/net/hns3/hns3_cmd.c
@@ -237,7 +237,12 @@ hns3_is_special_opcode(uint16_t opcode)
 				  HNS3_OPC_STATS_MAC,
 				  HNS3_OPC_STATS_MAC_ALL,
 				  HNS3_OPC_QUERY_32_BIT_REG,
-				  HNS3_OPC_QUERY_64_BIT_REG};
+				  HNS3_OPC_QUERY_64_BIT_REG,
+				  HNS3_OPC_QUERY_CLEAR_MPF_RAS_INT,
+				  HNS3_OPC_QUERY_CLEAR_PF_RAS_INT,
+				  HNS3_OPC_QUERY_CLEAR_ALL_MPF_MSIX_INT,
+				  HNS3_OPC_QUERY_CLEAR_ALL_PF_MSIX_INT,
+				  HNS3_OPC_QUERY_ALL_ERR_INFO,};
 	uint32_t i;
 
 	for (i = 0; i < ARRAY_SIZE(spec_opcode); i++)
@@ -449,6 +454,8 @@ hns3_parse_capability(struct hns3_hw *hw,
 	if (hns3_get_bit(caps, HNS3_CAPS_UDP_TUNNEL_CSUM_B))
 		hns3_set_bit(hw->capability,
 				HNS3_DEV_SUPPORT_OUTER_UDP_CKSUM_B, 1);
+	if (hns3_get_bit(caps, HNS3_CAPS_RAS_IMP_B))
+		hns3_set_bit(hw->capability, HNS3_DEV_SUPPORT_RAS_IMP_B, 1);
 }
 
 static uint32_t
diff --git a/drivers/net/hns3/hns3_cmd.h b/drivers/net/hns3/hns3_cmd.h
index a24063b..70aed7b 100644
--- a/drivers/net/hns3/hns3_cmd.h
+++ b/drivers/net/hns3/hns3_cmd.h
@@ -252,6 +252,8 @@ enum hns3_opcode_type {
 	HNS3_OPC_QUERY_MSIX_INT_STS_BD_NUM      = 0x1513,
 	HNS3_OPC_QUERY_CLEAR_ALL_MPF_MSIX_INT   = 0x1514,
 	HNS3_OPC_QUERY_CLEAR_ALL_PF_MSIX_INT    = 0x1515,
+	HNS3_OPC_QUERY_ALL_ERR_BD_NUM           = 0x1516,
+	HNS3_OPC_QUERY_ALL_ERR_INFO             = 0x1517,
 	HNS3_OPC_IGU_EGU_TNL_INT_EN             = 0x1803,
 	HNS3_OPC_IGU_COMMON_INT_EN              = 0x1806,
 	HNS3_OPC_TM_QCN_MEM_INT_CFG             = 0x1A14,
diff --git a/drivers/net/hns3/hns3_ethdev.c b/drivers/net/hns3/hns3_ethdev.c
index 1d09b5b..893b357 100644
--- a/drivers/net/hns3/hns3_ethdev.c
+++ b/drivers/net/hns3/hns3_ethdev.c
@@ -324,10 +324,8 @@ hns3_interrupt_handler(void *param)
 		hns3_warn(hw, "received interrupt: vector0_int_stat:0x%x "
 			  "ras_int_stat:0x%x cmdq_int_stat:0x%x",
 			  vector0_int, ras_int, cmdq_int);
-		hns3_handle_msix_error(hns, &hw->reset.request);
-		hns3_handle_ras_error(hns, &hw->reset.request);
 		hns3_handle_mac_tnl(hw);
-		hns3_schedule_reset(hns);
+		hns3_handle_error(hns);
 	} else if (event_cause == HNS3_VECTOR0_EVENT_RST) {
 		hns3_warn(hw, "received reset interrupt");
 		hns3_schedule_reset(hns);
@@ -6284,12 +6282,15 @@ hns3_is_reset_pending(struct hns3_adapter *hns)
 
 	hns3_check_event_cause(hns, NULL);
 	reset = hns3_get_reset_level(hns, &hw->reset.pending);
-	if (hw->reset.level != HNS3_NONE_RESET && hw->reset.level < reset) {
+
+	if (reset != HNS3_NONE_RESET && hw->reset.level != HNS3_NONE_RESET &&
+	    hw->reset.level < reset) {
 		hns3_warn(hw, "High level reset %d is pending", reset);
 		return true;
 	}
 	reset = hns3_get_reset_level(hns, &hw->reset.request);
-	if (hw->reset.level != HNS3_NONE_RESET && hw->reset.level < reset) {
+	if (reset != HNS3_NONE_RESET && hw->reset.level != HNS3_NONE_RESET &&
+	    hw->reset.level < reset) {
 		hns3_warn(hw, "High level reset %d is request", reset);
 		return true;
 	}
diff --git a/drivers/net/hns3/hns3_ethdev.h b/drivers/net/hns3/hns3_ethdev.h
index 8b6c0d2..4a855de 100644
--- a/drivers/net/hns3/hns3_ethdev.h
+++ b/drivers/net/hns3/hns3_ethdev.h
@@ -306,8 +306,9 @@ enum hns3_reset_stage {
 };
 
 enum hns3_reset_level {
-	HNS3_NONE_RESET,
+	HNS3_FLR_RESET,     /* A VF perform FLR reset */
 	HNS3_VF_FUNC_RESET, /* A VF function reset */
+
 	/*
 	 * All VFs under a PF perform function reset.
 	 * Kernel PF driver use mailbox to inform DPDK VF to do reset, the value
@@ -315,6 +316,7 @@ enum hns3_reset_level {
 	 * same.
 	 */
 	HNS3_VF_PF_FUNC_RESET = 2,
+
 	/*
 	 * All VFs under a PF perform FLR reset.
 	 * Kernel PF driver use mailbox to inform DPDK VF to do reset, the value
@@ -328,14 +330,23 @@ enum hns3_reset_level {
 	 * In PF FLR, the register state of VF is not reliable, VF's driver
 	 * should not access the registers of the VF device.
 	 */
-	HNS3_VF_FULL_RESET = 3,
-	HNS3_FLR_RESET,     /* A VF perform FLR reset */
+	HNS3_VF_FULL_RESET,
+
 	/* All VFs under the rootport perform a global or IMP reset */
 	HNS3_VF_RESET,
-	HNS3_FUNC_RESET,    /* A PF function reset */
+
+	/*
+	 * The enumeration value of HNS3_FUNC_RESET/HNS3_GLOBAL_RESET/
+	 * HNS3_IMP_RESET/HNS3_NONE_RESET are also used by firmware, and
+	 * can not be changed.
+	 */
+
+	HNS3_FUNC_RESET = 5,    /* A PF function reset */
+
 	/* All PFs under the rootport perform a global reset */
 	HNS3_GLOBAL_RESET,
 	HNS3_IMP_RESET,     /* All PFs under the rootport perform a IMP reset */
+	HNS3_NONE_RESET,
 	HNS3_MAX_RESET
 };
 
@@ -846,6 +857,7 @@ enum {
 #define HNS3_DEV_SUPPORT_STASH_B		0x7
 #define HNS3_DEV_SUPPORT_RXD_ADV_LAYOUT_B	0x9
 #define HNS3_DEV_SUPPORT_OUTER_UDP_CKSUM_B	0xA
+#define HNS3_DEV_SUPPORT_RAS_IMP_B		0xB
 
 #define hns3_dev_dcb_supported(hw) \
 	hns3_get_bit((hw)->capability, HNS3_DEV_SUPPORT_DCB_B)
@@ -882,6 +894,9 @@ enum {
 #define hns3_dev_outer_udp_cksum_supported(hw) \
 	hns3_get_bit((hw)->capability, HNS3_DEV_SUPPORT_OUTER_UDP_CKSUM_B)
 
+#define hns3_dev_ras_imp_supported(hw) \
+	hns3_get_bit((hw)->capability, HNS3_DEV_SUPPORT_RAS_IMP_B)
+
 #define HNS3_DEV_PRIVATE_TO_HW(adapter) \
 	(&((struct hns3_adapter *)adapter)->hw)
 #define HNS3_DEV_PRIVATE_TO_PF(adapter) \
diff --git a/drivers/net/hns3/hns3_ethdev_vf.c b/drivers/net/hns3/hns3_ethdev_vf.c
index dd8f248..efc614b 100644
--- a/drivers/net/hns3/hns3_ethdev_vf.c
+++ b/drivers/net/hns3/hns3_ethdev_vf.c
@@ -2465,7 +2465,8 @@ hns3vf_is_reset_pending(struct hns3_adapter *hns)
 	/* Check the registers to confirm whether there is reset pending */
 	hns3vf_check_event_cause(hns, NULL);
 	reset = hns3vf_get_reset_level(hw, &hw->reset.pending);
-	if (hw->reset.level != HNS3_NONE_RESET && hw->reset.level < reset) {
+	if (hw->reset.level != HNS3_NONE_RESET && reset != HNS3_NONE_RESET &&
+	    hw->reset.level < reset) {
 		hns3_warn(hw, "High level reset %d is pending", reset);
 		return true;
 	}
diff --git a/drivers/net/hns3/hns3_intr.c b/drivers/net/hns3/hns3_intr.c
index ccc90c5..7385c7b 100644
--- a/drivers/net/hns3/hns3_intr.c
+++ b/drivers/net/hns3/hns3_intr.c
@@ -23,8 +23,8 @@
 	} while (0)
 
 static const char *reset_string[HNS3_MAX_RESET] = {
-	"none", "vf_func", "vf_pf_func", "vf_full", "flr",
-	"vf_global", "pf_func", "global", "IMP",
+	"flr", "vf_func", "vf_pf_func", "vf_full", "vf_global",
+	"pf_func", "global", "IMP", "none",
 };
 
 static const struct hns3_hw_error mac_afifo_tnl_int[] = {
@@ -1384,13 +1384,108 @@ static const struct hns3_hw_error_desc pf_msix_err_tbl[] = {
 	}
 };
 
-enum hns3_hw_err_type {
+enum hns3_hw_err_report_type {
 	MPF_MSIX_ERR,
 	PF_MSIX_ERR,
 	MPF_RAS_ERR,
 	PF_RAS_ERR,
 };
 
+static const struct hns3_hw_mod_name hns3_hw_module_name[] = {
+	{
+		.module_name = MODULE_NONE,
+		.msg = "MODULE_NONE"
+	}, {
+		.module_name = MODULE_BIOS_COMMON,
+		.msg = "MODULE_BIOS_COMMON"
+	}, {
+		.module_name = MODULE_GE,
+		.msg = "MODULE_GE"
+	}, {
+		.module_name = MODULE_IGU_EGU,
+		.msg = "MODULE_IGU_EGU"
+	}, {
+		.module_name = MODULE_LGE,
+		.msg = "MODULE_LGE"
+	}, {
+		.module_name = MODULE_NCSI,
+		.msg = "MODULE_NCSI"
+	}, {
+		.module_name = MODULE_PPP,
+		.msg = "MODULE_PPP"
+	}, {
+		.module_name = MODULE_QCN,
+		.msg = "MODULE_QCN"
+	}, {
+		.module_name = MODULE_RCB_RX,
+		.msg = "MODULE_RCB_RX"
+	}, {
+		.module_name = MODULE_RTC,
+		.msg = "MODULE_RTC"
+	}, {
+		.module_name = MODULE_SSU,
+		.msg = "MODULE_SSU"
+	}, {
+		.module_name = MODULE_TM,
+		.msg = "MODULE_TM"
+	}, {
+		.module_name = MODULE_RCB_TX,
+		.msg = "MODULE_RCB_TX"
+	}, {
+		.module_name = MODULE_TXDMA,
+		.msg = "MODULE_TXDMA"
+	}, {
+		.module_name = MODULE_MASTER,
+		.msg = "MODULE_MASTER"
+	}, {
+		.module_name = MODULE_ROH_MAC,
+		.msg = "MODULE_ROH_MAC"
+	}
+};
+
+static const struct hns3_hw_err_type hns3_hw_error_type[] = {
+	{
+		.error_type = NONE_ERROR,
+		.msg = "none_error"
+	}, {
+		.error_type = FIFO_ERROR,
+		.msg = "fifo_error"
+	}, {
+		.error_type = MEMORY_ERROR,
+		.msg = "memory_error"
+	}, {
+		.error_type = POISION_ERROR,
+		.msg = "poision_error"
+	}, {
+		.error_type = MSIX_ECC_ERROR,
+		.msg = "msix_ecc_error"
+	}, {
+		.error_type = TQP_INT_ECC_ERROR,
+		.msg = "tqp_int_ecc_error"
+	}, {
+		.error_type = PF_ABNORMAL_INT_ERROR,
+		.msg = "pf_abnormal_int_error"
+	}, {
+		.error_type = MPF_ABNORMAL_INT_ERROR,
+		.msg = "mpf_abnormal_int_error"
+	}, {
+		.error_type = COMMON_ERROR,
+		.msg = "common_error"
+	}, {
+		.error_type = PORT_ERROR,
+		.msg = "port_error"
+	}, {
+		.error_type = ETS_ERROR,
+		.msg = "ets_error"
+	}, {
+		.error_type = NCSI_ERROR,
+		.msg = "ncsi_error"
+	}, {
+		.error_type = GLB_ERROR,
+		.msg = "glb_error"
+	}
+};
+
 static int
 hns3_config_ncsi_hw_err_int(struct hns3_adapter *hns, bool en)
 {
@@ -1927,7 +2022,8 @@ hns3_get_hw_error_status(struct hns3_cmd_desc *desc, uint8_t desc_offset,
 
 static int
 hns3_handle_hw_error(struct hns3_adapter *hns, struct hns3_cmd_desc *desc,
-		     int num, uint64_t *levels, enum hns3_hw_err_type err_type)
+		     int num, uint64_t *levels,
+		     enum hns3_hw_err_report_type err_type)
 {
 	const struct hns3_hw_error_desc *err = pf_ras_err_tbl;
 	enum hns3_opcode_type opcode;
@@ -2094,6 +2190,198 @@ hns3_handle_ras_error(struct hns3_adapter *hns, uint64_t *levels)
 	rte_free(desc);
 }
 
+static void
+hns3_handle_type_reg_error_data(struct hns3_hw *hw,
+				struct hns3_mod_err_info *mod_err_info,
+				struct hns3_type_reg_err_info *err_info)
+{
+#define HNS3_ERR_TYPE_MASK 0x7F
+#define HNS3_ERR_TYPE_IS_RAS_OFFSET 7
+
+	uint8_t mod_id, total_module, type_id, total_type;
+	uint8_t is_ras;
+	uint8_t i;
+
+	mod_id = mod_err_info->mod_id;
+	type_id = err_info->type_id & HNS3_ERR_TYPE_MASK;
+	is_ras = err_info->type_id >> HNS3_ERR_TYPE_IS_RAS_OFFSET;
+
+	total_module = ARRAY_SIZE(hns3_hw_module_name);
+	total_type = ARRAY_SIZE(hns3_hw_error_type);
+
+	hns3_err(hw, "total_module:%u, total_type:%u",
+		 total_module, total_type);
+
+	if (mod_id < total_module && type_id < total_type)
+		hns3_err(hw, "found %s %s, is %s error.",
+			 hns3_hw_module_name[mod_id].msg,
+			 hns3_hw_error_type[type_id].msg,
+			 is_ras ? "ras" : "msix");
+	else
+		hns3_err(hw, "unknown module[%u] or type[%u].",
+			 mod_id, type_id);
+
+	hns3_err(hw, "reg_value:");
+	for (i = 0; i < err_info->reg_num; i++)
+		hns3_err(hw, "0x%08x", err_info->reg[i]);
+}
+
+static void
+hns3_handle_module_error_data(struct hns3_hw *hw, uint32_t *buf,
+			      uint32_t buf_size)
+{
+	struct hns3_type_reg_err_info *type_reg_err_info;
+	struct hns3_mod_err_info *mod_err_info;
+	struct hns3_sum_err_info *sum_err_info;
+	uint8_t mod_num, reset_type;
+	uint32_t offset = 0;
+	uint8_t err_num;
+	uint8_t i;
+
+	sum_err_info = (struct hns3_sum_err_info *)&buf[offset++];
+	mod_num = sum_err_info->mod_num;
+	reset_type = sum_err_info->reset_type;
+	if (reset_type && reset_type != HNS3_NONE_RESET)
+		hns3_atomic_set_bit(reset_type, &hw->reset.request);
+
+	hns3_err(hw, "reset_type = %s, mod_num = %u.",
+		 reset_string[reset_type], mod_num);
+
+	while (mod_num--) {
+		if (offset >= buf_size) {
+			hns3_err(hw, "offset(%u) exceeds buf's size(%u).",
+				 offset, buf_size);
+			return;
+		}
+		mod_err_info = (struct hns3_mod_err_info *)&buf[offset++];
+		err_num = mod_err_info->err_num;
+		for (i = 0; i < err_num; i++) {
+			if (offset >= buf_size) {
+				hns3_err(hw,
+					 "offset(%u) exceeds buf size(%u).",
+					 offset, buf_size);
+				return;
+			}
+
+			type_reg_err_info = (struct hns3_type_reg_err_info *)
+					     &buf[offset++];
+			hns3_handle_type_reg_error_data(hw, mod_err_info,
+							type_reg_err_info);
+
+			offset += type_reg_err_info->reg_num;
+		}
+	}
+}
+
+static int
+hns3_query_all_err_bd_num(struct hns3_hw *hw, uint32_t *bd_num)
+{
+	struct hns3_cmd_desc desc;
+	uint32_t bd_num_data;
+	int ret;
+
+	hns3_cmd_setup_basic_desc(&desc, HNS3_OPC_QUERY_ALL_ERR_BD_NUM, true);
+	ret = hns3_cmd_send(hw, &desc, 1);
+	if (ret) {
+		hns3_err(hw, "failed to query error bd_num, ret = %d.", ret);
+		return ret;
+	}
+
+	bd_num_data = rte_le_to_cpu_32(desc.data[0]);
+	*bd_num = bd_num_data;
+	if (bd_num_data == 0) {
+		hns3_err(hw, "the value of bd_num is 0!");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+hns3_query_all_err_info(struct hns3_hw *hw, struct hns3_cmd_desc *desc,
+			uint32_t bd_num)
+{
+	int ret;
+
+	hns3_cmd_setup_basic_desc(desc, HNS3_OPC_QUERY_ALL_ERR_INFO, true);
+	ret = hns3_cmd_send(hw, desc, bd_num);
+	if (ret) {
+		hns3_err(hw, "failed to query error info, ret = %d.", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void
+hns3_handle_hw_error_v2(struct hns3_hw *hw)
+{
+	uint32_t bd_num, buf_len, i, buf_size;
+	struct hns3_cmd_desc *desc;
+	uint32_t *desc_data;
+	uint32_t *buf;
+	int ret;
+
+	ret = hns3_query_all_err_bd_num(hw, &bd_num);
+	if (ret)
+		goto out;
+
+	desc = rte_zmalloc("hns3_ras", bd_num * sizeof(struct hns3_cmd_desc),
+					   0);
+	if (desc == NULL) {
+		hns3_err(hw, "failed to malloc hns3 ras cmd desc.");
+		goto out;
+	}
+
+	ret = hns3_query_all_err_info(hw, desc, bd_num);
+	if (ret)
+		goto err_desc;
+
+	buf_len = bd_num * sizeof(struct hns3_cmd_desc) - HNS3_DESC_NO_DATA_LEN;
+	buf_size = buf_len / HNS3_DESC_DATA_UNIT_SIZE;
+
+	desc_data = rte_zmalloc("hns3_ras", buf_len, 0);
+	if (desc_data == NULL) {
+		hns3_err(hw, "failed to malloc hns3 ras desc data.");
+		goto err_desc;
+	}
+
+	buf = rte_zmalloc("hns3_ras", buf_len, 0);
+	if (buf == NULL) {
+		hns3_err(hw, "failed to malloc hns3 ras buf data.");
+		goto err_buf_alloc;
+	}
+
+	memcpy(desc_data, &desc[0].data[0], buf_len);
+	for (i = 0; i < buf_size; i++)
+		buf[i] = rte_le_to_cpu_32(desc_data[i]);
+
+	hns3_handle_module_error_data(hw, buf, buf_size);
+	rte_free(buf);
+
+err_buf_alloc:
+	rte_free(desc_data);
+err_desc:
+	rte_free(desc);
+out:
+	return;
+}
+
+void
+hns3_handle_error(struct hns3_adapter *hns)
+{
+	struct hns3_hw *hw = &hns->hw;
+
+	if (hns3_dev_ras_imp_supported(hw)) {
+		hns3_handle_hw_error_v2(hw);
+		hns3_schedule_reset(hns);
+	} else {
+		hns3_handle_msix_error(hns, &hw->reset.request);
+		hns3_handle_ras_error(hns, &hw->reset.request);
+		hns3_schedule_reset(hns);
+	}
+}
+
 int
 hns3_reset_init(struct hns3_hw *hw)
 {
diff --git a/drivers/net/hns3/hns3_intr.h b/drivers/net/hns3/hns3_intr.h
index 4a0a731..a140ca1 100644
--- a/drivers/net/hns3/hns3_intr.h
+++ b/drivers/net/hns3/hns3_intr.h
@@ -81,6 +81,75 @@
 
 #define HNS3_RESET_PROCESS_MS			200
 
+#define HNS3_DESC_DATA_MAX			8
+#define HNS3_REG_NUM_MAX			256
+#define HNS3_DESC_NO_DATA_LEN			8
+#define HNS3_DESC_DATA_UNIT_SIZE		4
+
+enum hns3_mod_name_list {
+	MODULE_NONE,
+	MODULE_BIOS_COMMON,
+	MODULE_GE,
+	MODULE_IGU_EGU,
+	MODULE_LGE,
+	MODULE_NCSI,
+	MODULE_PPP,
+	MODULE_QCN,
+	MODULE_RCB_RX,
+	MODULE_RTC,
+	MODULE_SSU,
+	MODULE_TM,
+	MODULE_RCB_TX,
+	MODULE_TXDMA,
+	MODULE_MASTER,
+	MODULE_ROH_MAC,
+};
+
+enum hns3_err_type_list {
+	NONE_ERROR,
+	FIFO_ERROR,
+	MEMORY_ERROR,
+	POISION_ERROR,
+	MSIX_ECC_ERROR,
+	TQP_INT_ECC_ERROR,
+	PF_ABNORMAL_INT_ERROR,
+	MPF_ABNORMAL_INT_ERROR,
+	COMMON_ERROR,
+	PORT_ERROR,
+	ETS_ERROR,
+	NCSI_ERROR,
+	GLB_ERROR,
+};
+
+struct hns3_hw_mod_name {
+	enum hns3_mod_name_list module_name;
+	const char *msg;
+};
+
+struct hns3_hw_err_type {
+	enum hns3_err_type_list error_type;
+	const char *msg;
+};
+
+struct hns3_sum_err_info {
+	uint8_t reset_type; /* the total reset type */
+	uint8_t mod_num; /* the modules num encounter error */
+	uint8_t rsv[2];
+};
+
+struct hns3_mod_err_info {
+	uint8_t mod_id; /* the error module id */
+	uint8_t err_num; /* the errors num in module */
+	uint8_t rsv[2];
+};
+
+struct hns3_type_reg_err_info {
+	uint8_t type_id; /* the type id of error */
+	uint8_t reg_num; /* the related registers num of this error */
+	uint8_t rsv[2];
+	uint32_t reg[HNS3_REG_NUM_MAX]; /* the registers value */
+};
+
 struct hns3_hw_blk {
 	const char *name;
 	int (*enable_err_intr)(struct hns3_adapter *hns, bool en);
@@ -103,6 +172,7 @@ int hns3_enable_hw_error_intr(struct hns3_adapter *hns, bool state);
 void hns3_handle_msix_error(struct hns3_adapter *hns, uint64_t *levels);
 void hns3_handle_ras_error(struct hns3_adapter *hns, uint64_t *levels);
 void hns3_config_mac_tnl_int(struct hns3_hw *hw, bool en);
+void hns3_handle_error(struct hns3_adapter *hns);
 
 void hns3_intr_unregister(const struct rte_intr_handle *hdl,
 			  rte_intr_callback_fn cb_fn, void *cb_arg);
-- 
2.7.4

