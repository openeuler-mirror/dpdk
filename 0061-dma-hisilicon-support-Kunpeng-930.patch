From 0ac9cae2d0e1763cf884f0b5d735e4b57b6acb27 Mon Sep 17 00:00:00 2001
From: Chengwen Feng <fengchengwen@huawei.com>
Date: Thu, 17 Feb 2022 10:59:07 +0800
Subject: [PATCH 01/25] dma/hisilicon: support Kunpeng 930

The Kunpeng930 DMA devices have the same PCI device id with Kunpeng920,
but with different PCI revision and register layout. This patch
introduces the basic initialization for Kunpeng930 DMA devices.

Signed-off-by: Chengwen Feng <fengchengwen@huawei.com>
---
 doc/guides/dmadevs/hisilicon.rst    |  1 +
 drivers/dma/hisilicon/hisi_dmadev.c | 34 ++++++++++++++++++++++++++---
 drivers/dma/hisilicon/hisi_dmadev.h | 28 +++++++++++++++++++-----
 3 files changed, 54 insertions(+), 9 deletions(-)

diff --git a/doc/guides/dmadevs/hisilicon.rst b/doc/guides/dmadevs/hisilicon.rst
index 191e56f2f7..81bf090311 100644
--- a/doc/guides/dmadevs/hisilicon.rst
+++ b/doc/guides/dmadevs/hisilicon.rst
@@ -13,6 +13,7 @@ Supported Kunpeng SoCs
 ----------------------
 
 * Kunpeng 920
+* Kunpeng 930
 
 
 Device Setup
diff --git a/drivers/dma/hisilicon/hisi_dmadev.c b/drivers/dma/hisilicon/hisi_dmadev.c
index 05066b4d0e..d4e08994a8 100644
--- a/drivers/dma/hisilicon/hisi_dmadev.c
+++ b/drivers/dma/hisilicon/hisi_dmadev.c
@@ -39,6 +39,8 @@ hisi_dma_queue_base(struct hisi_dma_dev *hw)
 {
 	if (hw->reg_layout == HISI_DMA_REG_LAYOUT_HIP08)
 		return HISI_DMA_HIP08_QUEUE_BASE;
+	else if (hw->reg_layout == HISI_DMA_REG_LAYOUT_HIP09)
+		return HISI_DMA_HIP09_QUEUE_BASE;
 	else
 		return 0;
 }
@@ -174,7 +176,7 @@ hisi_dma_reset_hw(struct hisi_dma_dev *hw)
 }
 
 static void
-hisi_dma_init_hw(struct hisi_dma_dev *hw)
+hisi_dma_init_common(struct hisi_dma_dev *hw)
 {
 	hisi_dma_write_queue(hw, HISI_DMA_QUEUE_SQ_BASE_L_REG,
 			     lower_32_bits(hw->sqe_iova));
@@ -192,6 +194,12 @@ hisi_dma_init_hw(struct hisi_dma_dev *hw)
 	hisi_dma_write_queue(hw, HISI_DMA_QUEUE_ERR_INT_NUM0_REG, 0);
 	hisi_dma_write_queue(hw, HISI_DMA_QUEUE_ERR_INT_NUM1_REG, 0);
 	hisi_dma_write_queue(hw, HISI_DMA_QUEUE_ERR_INT_NUM2_REG, 0);
+}
+
+static void
+hisi_dma_init_hw(struct hisi_dma_dev *hw)
+{
+	hisi_dma_init_common(hw);
 
 	if (hw->reg_layout == HISI_DMA_REG_LAYOUT_HIP08) {
 		hisi_dma_write_queue(hw, HISI_DMA_HIP08_QUEUE_ERR_INT_NUM3_REG,
@@ -206,9 +214,27 @@ hisi_dma_init_hw(struct hisi_dma_dev *hw)
 				HISI_DMA_HIP08_QUEUE_CTRL0_ERR_ABORT_B, false);
 		hisi_dma_update_queue_mbit(hw, HISI_DMA_QUEUE_INT_STATUS_REG,
 				HISI_DMA_HIP08_QUEUE_INT_MASK_M, true);
-		hisi_dma_update_queue_mbit(hw,
-				HISI_DMA_HIP08_QUEUE_INT_MASK_REG,
+		hisi_dma_update_queue_mbit(hw, HISI_DMA_QUEUE_INT_MASK_REG,
 				HISI_DMA_HIP08_QUEUE_INT_MASK_M, true);
+	} else if (hw->reg_layout == HISI_DMA_REG_LAYOUT_HIP09) {
+		hisi_dma_update_queue_mbit(hw, HISI_DMA_QUEUE_CTRL0_REG,
+				HISI_DMA_HIP09_QUEUE_CTRL0_ERR_ABORT_M, false);
+		hisi_dma_update_queue_mbit(hw, HISI_DMA_QUEUE_INT_STATUS_REG,
+				HISI_DMA_HIP09_QUEUE_INT_MASK_M, true);
+		hisi_dma_update_queue_mbit(hw, HISI_DMA_QUEUE_INT_MASK_REG,
+				HISI_DMA_HIP09_QUEUE_INT_MASK_M, true);
+		hisi_dma_update_queue_mbit(hw,
+				HISI_DMA_HIP09_QUEUE_ERR_INT_STATUS_REG,
+				HISI_DMA_HIP09_QUEUE_ERR_INT_MASK_M, true);
+		hisi_dma_update_queue_mbit(hw,
+				HISI_DMA_HIP09_QUEUE_ERR_INT_MASK_REG,
+				HISI_DMA_HIP09_QUEUE_ERR_INT_MASK_M, true);
+		hisi_dma_update_queue_bit(hw, HISI_DMA_QUEUE_CTRL1_REG,
+				HISI_DMA_HIP09_QUEUE_CTRL1_VA_ENABLE_B, true);
+		hisi_dma_update_bit(hw,
+				HISI_DMA_HIP09_QUEUE_CFG_REG(hw->queue_id),
+				HISI_DMA_HIP09_QUEUE_CFG_LINK_DOWN_MASK_B,
+				true);
 	}
 }
 
@@ -230,6 +256,8 @@ hisi_dma_reg_layout(uint8_t revision)
 {
 	if (revision == HISI_DMA_REVISION_HIP08B)
 		return HISI_DMA_REG_LAYOUT_HIP08;
+	else if (revision >= HISI_DMA_REVISION_HIP09A)
+		return HISI_DMA_REG_LAYOUT_HIP09;
 	else
 		return HISI_DMA_REG_LAYOUT_INVALID;
 }
diff --git a/drivers/dma/hisilicon/hisi_dmadev.h b/drivers/dma/hisilicon/hisi_dmadev.h
index 12e209c86e..591aec0b32 100644
--- a/drivers/dma/hisilicon/hisi_dmadev.h
+++ b/drivers/dma/hisilicon/hisi_dmadev.h
@@ -23,20 +23,22 @@
 #define HISI_DMA_DEVICE_ID			0xA122
 #define HISI_DMA_PCI_REVISION_ID_REG		0x08
 #define HISI_DMA_REVISION_HIP08B		0x21
+#define HISI_DMA_REVISION_HIP09A		0x30
 
 #define HISI_DMA_MAX_HW_QUEUES			4
 #define HISI_DMA_MAX_DESC_NUM			8192
 #define HISI_DMA_MIN_DESC_NUM			32
 
 /**
- * The HIP08B(HiSilicon IP08) and later Chip(e.g. HiSilicon IP09) are DMA iEPs,
- * they have the same pci device id but with different pci revision.
- * Unfortunately, they have different register layouts, so the layout
+ * The HIP08B(HiSilicon IP08) and HIP09B(HiSilicon IP09) are DMA iEPs, they
+ * have the same pci device id but different pci revision.
+ * Unfortunately, they have different register layouts, so two layout
  * enumerations are defined.
  */
 enum {
 	HISI_DMA_REG_LAYOUT_INVALID = 0,
-	HISI_DMA_REG_LAYOUT_HIP08
+	HISI_DMA_REG_LAYOUT_HIP08,
+	HISI_DMA_REG_LAYOUT_HIP09
 };
 
 /**
@@ -66,7 +68,7 @@ enum {
  * calculated by:
  *     offset = queue-base + (queue-id * queue-region) + reg-offset-in-region.
  *
- * The first part of queue region is basically the same for HIP08 and later chip
+ * The first part of queue region is basically the same for HIP08 and HIP09
  * register layouts, therefore, HISI_QUEUE_* registers are defined for it.
  */
 #define HISI_DMA_QUEUE_SQ_BASE_L_REG		0x0
@@ -85,6 +87,7 @@ enum {
 #define HISI_DMA_QUEUE_FSM_REG			0x30
 #define HISI_DMA_QUEUE_FSM_STS_M		GENMASK(3, 0)
 #define HISI_DMA_QUEUE_INT_STATUS_REG		0x40
+#define HISI_DMA_QUEUE_INT_MASK_REG		0x44
 #define HISI_DMA_QUEUE_ERR_INT_NUM0_REG		0x84
 #define HISI_DMA_QUEUE_ERR_INT_NUM1_REG		0x88
 #define HISI_DMA_QUEUE_ERR_INT_NUM2_REG		0x8C
@@ -95,7 +98,6 @@ enum {
  */
 #define HISI_DMA_HIP08_QUEUE_BASE			0x0
 #define HISI_DMA_HIP08_QUEUE_CTRL0_ERR_ABORT_B		2
-#define HISI_DMA_HIP08_QUEUE_INT_MASK_REG		0x44
 #define HISI_DMA_HIP08_QUEUE_INT_MASK_M			GENMASK(14, 0)
 #define HISI_DMA_HIP08_QUEUE_ERR_INT_NUM3_REG		0x90
 #define HISI_DMA_HIP08_QUEUE_ERR_INT_NUM4_REG		0x94
@@ -106,6 +108,20 @@ enum {
 #define HISI_DMA_HIP08_DUMP_START_REG			0x2000
 #define HISI_DMA_HIP08_DUMP_END_REG			0x2280
 
+/**
+ * HiSilicon IP09 DMA register and field define:
+ */
+#define HISI_DMA_HIP09_QUEUE_BASE			0x2000
+#define HISI_DMA_HIP09_QUEUE_CTRL0_ERR_ABORT_M		GENMASK(31, 28)
+#define HISI_DMA_HIP09_QUEUE_CTRL1_VA_ENABLE_B		2
+#define HISI_DMA_HIP09_QUEUE_INT_MASK_M			0x1
+#define HISI_DMA_HIP09_QUEUE_ERR_INT_STATUS_REG		0x48
+#define HISI_DMA_HIP09_QUEUE_ERR_INT_MASK_REG		0x4C
+#define HISI_DMA_HIP09_QUEUE_ERR_INT_MASK_M		GENMASK(18, 1)
+#define HISI_DMA_HIP09_QUEUE_CFG_REG(queue_id)		(0x800 + \
+							 (queue_id) * 0x20)
+#define HISI_DMA_HIP09_QUEUE_CFG_LINK_DOWN_MASK_B	16
+
 /**
  * In fact, there are multiple states, but it need to pay attention to
  * the following two states for the driver:
-- 
2.30.0

