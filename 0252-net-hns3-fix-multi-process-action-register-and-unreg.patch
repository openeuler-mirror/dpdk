From c4ae016e0b548882c5f777cd1782b8661a34f252 Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Tue, 2 Nov 2021 09:38:27 +0800
Subject: [PATCH 19/33] net/hns3: fix multi-process action register and
 unregister

The multi-process has the following problems:
1) After a port in primary process is closed, the mp action of the
   process is unregistered. Which will cause that other device in the
   primary process cannot respond to requests from secondary processes.
2) Because variable "hns3_inited" is set to true without returning an
   initial value, the mp action cannot be registered again after it is
   unregistered.
3) The mp action of primary and secondary process need to be registered
   only once regardless of port numbers in the process. That's what
   variable "hns3_inited" does. But the variable is difficult to
   understand.

This patch adds a hns3_process_local_data structure to resolve above
problems.

Fixes: 9570b1fdbdad ("net/hns3: check multi-process action register result")
Fixes: 23d4b61fee5d ("net/hns3: support multiple process")

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_ethdev.c    |  2 ++
 drivers/net/hns3/hns3_ethdev_vf.c |  2 ++
 drivers/net/hns3/hns3_mp.c        | 37 ++++++++++++++++++-------------
 drivers/net/hns3/hns3_mp.h        |  7 ++++++
 4 files changed, 33 insertions(+), 15 deletions(-)

diff --git a/drivers/net/hns3/hns3_ethdev.c b/drivers/net/hns3/hns3_ethdev.c
index 31d027836..2f2d2a605 100644
--- a/drivers/net/hns3/hns3_ethdev.c
+++ b/drivers/net/hns3/hns3_ethdev.c
@@ -7424,6 +7424,7 @@ hns3_dev_init(struct rte_eth_dev *eth_dev)
 			goto err_mp_init_secondary;
 		}
 		__atomic_fetch_add(&hw->secondary_cnt, 1, __ATOMIC_RELAXED);
+		process_data.eth_dev_cnt++;
 		hns3_tx_push_init(eth_dev);
 		return 0;
 	}
@@ -7435,6 +7436,7 @@ hns3_dev_init(struct rte_eth_dev *eth_dev)
 			     ret);
 		goto err_mp_init_primary;
 	}
+	process_data.eth_dev_cnt++;
 
 	hw->adapter_state = HNS3_NIC_UNINITIALIZED;
 	hns->is_vf = false;
diff --git a/drivers/net/hns3/hns3_ethdev_vf.c b/drivers/net/hns3/hns3_ethdev_vf.c
index 76721b0d7..108bd61d5 100644
--- a/drivers/net/hns3/hns3_ethdev_vf.c
+++ b/drivers/net/hns3/hns3_ethdev_vf.c
@@ -2713,6 +2713,7 @@ hns3vf_dev_init(struct rte_eth_dev *eth_dev)
 			goto err_mp_init_secondary;
 		}
 		__atomic_fetch_add(&hw->secondary_cnt, 1, __ATOMIC_RELAXED);
+		process_data.eth_dev_cnt++;
 		hns3_tx_push_init(eth_dev);
 		return 0;
 	}
@@ -2724,6 +2725,7 @@ hns3vf_dev_init(struct rte_eth_dev *eth_dev)
 			     ret);
 		goto err_mp_init_primary;
 	}
+	process_data.eth_dev_cnt++;
 
 	hw->adapter_state = HNS3_NIC_UNINITIALIZED;
 	hns->is_vf = true;
diff --git a/drivers/net/hns3/hns3_mp.c b/drivers/net/hns3/hns3_mp.c
index 184acfe02..753b93f09 100644
--- a/drivers/net/hns3/hns3_mp.c
+++ b/drivers/net/hns3/hns3_mp.c
@@ -12,7 +12,8 @@
 #include "hns3_rxtx.h"
 #include "hns3_mp.h"
 
-static bool hns3_inited;
+/* local data for primary or secondary process. */
+struct hns3_process_local_data process_data;
 
 /*
  * Initialize IPC message.
@@ -230,14 +231,15 @@ int hns3_mp_init_primary(void)
 {
 	int ret;
 
-	if (!hns3_inited) {
-		/* primary is allowed to not support IPC */
-		ret = rte_mp_action_register(HNS3_MP_NAME, mp_primary_handle);
-		if (ret && rte_errno != ENOTSUP)
-			return ret;
+	if (process_data.init_done)
+		return 0;
 
-		hns3_inited = true;
-	}
+	/* primary is allowed to not support IPC */
+	ret = rte_mp_action_register(HNS3_MP_NAME, mp_primary_handle);
+	if (ret && rte_errno != ENOTSUP)
+		return ret;
+
+	process_data.init_done = true;
 
 	return 0;
 }
@@ -247,8 +249,12 @@ int hns3_mp_init_primary(void)
  */
 void hns3_mp_uninit_primary(void)
 {
-	if (hns3_inited)
+	process_data.eth_dev_cnt--;
+
+	if (process_data.eth_dev_cnt == 0) {
 		rte_mp_action_unregister(HNS3_MP_NAME);
+		process_data.init_done = false;
+	}
 }
 
 /*
@@ -258,13 +264,14 @@ int hns3_mp_init_secondary(void)
 {
 	int ret;
 
-	if (!hns3_inited) {
-		ret = rte_mp_action_register(HNS3_MP_NAME, mp_secondary_handle);
-		if (ret)
-			return ret;
+	if (process_data.init_done)
+		return 0;
 
-		hns3_inited = true;
-	}
+	ret = rte_mp_action_register(HNS3_MP_NAME, mp_secondary_handle);
+	if (ret)
+		return ret;
+
+	process_data.init_done = true;
 
 	return 0;
 }
diff --git a/drivers/net/hns3/hns3_mp.h b/drivers/net/hns3/hns3_mp.h
index e0e4aeaf6..b49532f98 100644
--- a/drivers/net/hns3/hns3_mp.h
+++ b/drivers/net/hns3/hns3_mp.h
@@ -5,6 +5,13 @@
 #ifndef _HNS3_MP_H_
 #define _HNS3_MP_H_
 
+/* Local data for primary or secondary process. */
+struct hns3_process_local_data {
+	bool init_done; /* Process action register completed flag. */
+	int eth_dev_cnt; /* Ethdev count under the current process. */
+};
+extern struct hns3_process_local_data process_data;
+
 void hns3_mp_req_start_rxtx(struct rte_eth_dev *dev);
 void hns3_mp_req_stop_rxtx(struct rte_eth_dev *dev);
 void hns3_mp_req_start_tx(struct rte_eth_dev *dev);
-- 
2.33.0

