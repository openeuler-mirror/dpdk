From ddd874645976918320694f9095f9a3892eaf4a4c Mon Sep 17 00:00:00 2001
From: Hongbo Zheng <zhenghongbo3@huawei.com>
Date: Sat, 17 Jul 2021 10:02:52 +0800
Subject: [PATCH 20/26] net/hns3: fix timing of clearing interrupt source

Currently, the PF/VF does not clear the interrupt source immediately
after receiving the interrupt. As a result, if the second interrupt
task is triggered when processing the first interrupt task, clearing
the interrupt source before exiting will clear the interrupt sources
of the two tasks at the same time. As a result, no interrupt is
triggered for the second task.

Clearing interrupt source immediately after checking event cause
ensures that:
1. Even if two interrupt tasks are triggered at the same time, they can
be processed.
2. If the second task is triggered during the processing of the first
task and the interrupt source is not cleared, the interrupt is reported
after vector0 is enabled.

Fixes: a5475d61fa34 ("net/hns3: support VF")
Fixes: 3988ab0eee52 ("net/hns3: add abnormal interrupt process")
Cc: stable@dpdk.org

Signed-off-by: Hongbo Zheng <zhenghongbo3@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_ethdev.c    | 2 +-
 drivers/net/hns3/hns3_ethdev_vf.c | 5 ++---
 2 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/drivers/net/hns3/hns3_ethdev.c b/drivers/net/hns3/hns3_ethdev.c
index ce7aa95..f658e74 100644
--- a/drivers/net/hns3/hns3_ethdev.c
+++ b/drivers/net/hns3/hns3_ethdev.c
@@ -317,6 +317,7 @@ hns3_interrupt_handler(void *param)
 	vector0_int = hns3_read_dev(hw, HNS3_VECTOR0_OTHER_INT_STS_REG);
 	ras_int = hns3_read_dev(hw, HNS3_RAS_PF_OTHER_INT_STS_REG);
 	cmdq_int = hns3_read_dev(hw, HNS3_VECTOR0_CMDQ_SRC_REG);
+	hns3_clear_event_cause(hw, event_cause, clearval);
 	/* vector 0 interrupt is shared with reset and mailbox source events. */
 	if (event_cause == HNS3_VECTOR0_EVENT_ERR) {
 		hns3_warn(hw, "received interrupt: vector0_int_stat:0x%x "
@@ -335,7 +336,6 @@ hns3_interrupt_handler(void *param)
 			  vector0_int, ras_int, cmdq_int);
 	}
 
-	hns3_clear_event_cause(hw, event_cause, clearval);
 	/* Enable interrupt if it is not cause by reset */
 	hns3_pf_enable_irq0(hw);
 }
diff --git a/drivers/net/hns3/hns3_ethdev_vf.c b/drivers/net/hns3/hns3_ethdev_vf.c
index b62b059..9e3b31e 100644
--- a/drivers/net/hns3/hns3_ethdev_vf.c
+++ b/drivers/net/hns3/hns3_ethdev_vf.c
@@ -1116,6 +1116,8 @@ hns3vf_interrupt_handler(void *param)
 
 	/* Read out interrupt causes */
 	event_cause = hns3vf_check_event_cause(hns, &clearval);
+	/* Clear interrupt causes */
+	hns3vf_clear_event_cause(hw, clearval);
 
 	switch (event_cause) {
 	case HNS3VF_VECTOR0_EVENT_RST:
@@ -1128,9 +1130,6 @@ hns3vf_interrupt_handler(void *param)
 		break;
 	}
 
-	/* Clear interrupt causes */
-	hns3vf_clear_event_cause(hw, clearval);
-
 	/* Enable interrupt */
 	hns3vf_enable_irq0(hw);
 }
-- 
2.7.4

