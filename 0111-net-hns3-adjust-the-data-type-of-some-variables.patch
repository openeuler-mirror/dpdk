From ca3ada1984f4c159ae2c7e94c82f38d0f239ba84 Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Wed, 1 Jun 2022 11:52:43 +0800
Subject: [PATCH 111/122] net/hns3: adjust the data type of some variables

Using the 'int' type and 'uint16_t' type to compare is insecure.
Make them consistent.

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_common.c   |  4 ++--
 drivers/net/hns3/hns3_dcb.c      |  2 +-
 drivers/net/hns3/hns3_ethdev.c   |  2 +-
 drivers/net/hns3/hns3_regs.c     |  2 +-
 drivers/net/hns3/hns3_rss.c      |  2 +-
 drivers/net/hns3/hns3_rxtx.c     | 23 ++++++++++++-----------
 drivers/net/hns3/hns3_rxtx_vec.h |  4 ++--
 7 files changed, 20 insertions(+), 19 deletions(-)

diff --git a/drivers/net/hns3/hns3_common.c b/drivers/net/hns3/hns3_common.c
index 9c86c00a04..edd16d8076 100644
--- a/drivers/net/hns3/hns3_common.c
+++ b/drivers/net/hns3/hns3_common.c
@@ -475,7 +475,7 @@ hns3_configure_all_mac_addr(struct hns3_adapter *hns, bool del)
 	struct rte_ether_addr *addr;
 	uint16_t mac_addrs_capa;
 	int ret = 0;
-	int i;
+	uint16_t i;
 
 	mac_addrs_capa =
 		hns->is_vf ? HNS3_VF_UC_MACADDR_NUM : HNS3_UC_MACADDR_NUM;
@@ -645,8 +645,8 @@ int
 hns3_init_ring_with_vector(struct hns3_hw *hw)
 {
 	uint16_t vec;
+	uint16_t i;
 	int ret;
-	int i;
 
 	/*
 	 * In hns3 network engine, vector 0 is always the misc interrupt of this
diff --git a/drivers/net/hns3/hns3_dcb.c b/drivers/net/hns3/hns3_dcb.c
index 136ada626b..d88757611c 100644
--- a/drivers/net/hns3/hns3_dcb.c
+++ b/drivers/net/hns3/hns3_dcb.c
@@ -628,7 +628,7 @@ hns3_set_rss_size(struct hns3_hw *hw, uint16_t nb_rx_q)
 	struct hns3_rss_conf *rss_cfg = &hw->rss_info;
 	uint16_t rx_qnum_per_tc;
 	uint16_t used_rx_queues;
-	int i;
+	uint16_t i;
 
 	rx_qnum_per_tc = nb_rx_q / hw->num_tc;
 	if (rx_qnum_per_tc > hw->rss_size_max) {
diff --git a/drivers/net/hns3/hns3_ethdev.c b/drivers/net/hns3/hns3_ethdev.c
index 29c9f96c05..97cf27d2a1 100644
--- a/drivers/net/hns3/hns3_ethdev.c
+++ b/drivers/net/hns3/hns3_ethdev.c
@@ -2929,8 +2929,8 @@ hns3_map_tqps_to_func(struct hns3_hw *hw, uint16_t func_id, uint16_t tqp_pid,
 static int
 hns3_map_tqp(struct hns3_hw *hw)
 {
+	uint16_t i;
 	int ret;
-	int i;
 
 	/*
 	 * In current version, VF is not supported when PF is driven by DPDK
diff --git a/drivers/net/hns3/hns3_regs.c b/drivers/net/hns3/hns3_regs.c
index 86a4cf74d5..6778e4cfc2 100644
--- a/drivers/net/hns3/hns3_regs.c
+++ b/drivers/net/hns3/hns3_regs.c
@@ -294,8 +294,8 @@ hns3_direct_access_regs(struct hns3_hw *hw, uint32_t *data)
 	struct hns3_adapter *hns = HNS3_DEV_HW_TO_ADAPTER(hw);
 	uint32_t *origin_data_ptr = data;
 	uint32_t reg_offset;
+	uint16_t i, j;
 	int reg_num;
-	int i, j;
 
 	/* fetching per-PF registers values from PF PCIe register space */
 	reg_num = sizeof(cmdq_reg_addrs) / sizeof(uint32_t);
diff --git a/drivers/net/hns3/hns3_rss.c b/drivers/net/hns3/hns3_rss.c
index d376486a1d..4c546c9363 100644
--- a/drivers/net/hns3/hns3_rss.c
+++ b/drivers/net/hns3/hns3_rss.c
@@ -631,7 +631,7 @@ hns3_rss_set_default_args(struct hns3_hw *hw)
 {
 	struct hns3_rss_conf *rss_cfg = &hw->rss_info;
 	uint16_t queue_num = hw->alloc_rss_size;
-	int i;
+	uint16_t i;
 
 	/* Default hash algorithm */
 	rss_cfg->conf.func = RTE_ETH_HASH_FUNCTION_TOEPLITZ;
diff --git a/drivers/net/hns3/hns3_rxtx.c b/drivers/net/hns3/hns3_rxtx.c
index ee0aaaf7fc..510802be05 100644
--- a/drivers/net/hns3/hns3_rxtx.c
+++ b/drivers/net/hns3/hns3_rxtx.c
@@ -390,7 +390,7 @@ hns3_enable_all_queues(struct hns3_hw *hw, bool en)
 	struct hns3_tx_queue *txq;
 	uint32_t rcb_reg;
 	void *tqp_base;
-	int i;
+	uint16_t i;
 
 	for (i = 0; i < hw->cfg_max_queues; i++) {
 		if (hns3_dev_get_support(hw, INDEP_TXRX)) {
@@ -736,8 +736,8 @@ hns3pf_reset_all_tqps(struct hns3_hw *hw)
 #define HNS3_RESET_RCB_NOT_SUPPORT	0U
 #define HNS3_RESET_ALL_TQP_SUCCESS	1U
 	uint8_t reset_status;
+	uint16_t i;
 	int ret;
-	int i;
 
 	ret = hns3_reset_rcb_cmd(hw, &reset_status);
 	if (ret)
@@ -774,7 +774,7 @@ hns3vf_reset_all_tqps(struct hns3_hw *hw)
 	uint8_t reset_status;
 	uint8_t msg_data[2];
 	int ret;
-	int i;
+	uint16_t i;
 
 	memset(msg_data, 0, sizeof(uint16_t));
 	ret = hns3_send_mbx_msg(hw, HNS3_MBX_QUEUE_RESET, 0, msg_data,
@@ -806,7 +806,8 @@ int
 hns3_reset_all_tqps(struct hns3_adapter *hns)
 {
 	struct hns3_hw *hw = &hns->hw;
-	int ret, i;
+	uint16_t i;
+	int ret;
 
 	/* Disable all queues before reset all queues */
 	for (i = 0; i < hw->cfg_max_queues; i++) {
@@ -1037,7 +1038,7 @@ hns3_dev_all_rx_queue_intr_enable(struct hns3_hw *hw, bool en)
 {
 	struct rte_eth_dev *dev = &rte_eth_devices[hw->data->port_id];
 	uint16_t nb_rx_q = hw->data->nb_rx_queues;
-	int i;
+	uint16_t i;
 
 	if (dev->data->dev_conf.intr_conf.rxq == 0)
 		return;
@@ -1121,7 +1122,7 @@ static void
 hns3_init_txq(struct hns3_tx_queue *txq)
 {
 	struct hns3_desc *desc;
-	int i;
+	uint16_t i;
 
 	/* Clear tx bd */
 	desc = txq->tx_ring;
@@ -1145,7 +1146,7 @@ hns3_init_tx_ring_tc(struct hns3_adapter *hns)
 
 	for (i = 0; i < HNS3_MAX_TC_NUM; i++) {
 		struct hns3_tc_queue_info *tc_queue = &hw->tc_queue[i];
-		int j;
+		uint16_t j;
 
 		if (!tc_queue->enable)
 			continue;
@@ -1442,7 +1443,7 @@ hns3_alloc_txq_and_dma_zone(struct rte_eth_dev *dev,
 	struct hns3_tx_queue *txq;
 	struct hns3_desc *desc;
 	unsigned int tx_desc;
-	int i;
+	uint16_t i;
 
 	txq = rte_zmalloc_socket(q_info->type, sizeof(struct hns3_tx_queue),
 				 RTE_CACHE_LINE_SIZE, q_info->socket_id);
@@ -1679,7 +1680,7 @@ hns3_dev_release_mbufs(struct hns3_adapter *hns)
 	struct rte_eth_dev_data *dev_data = hns->hw.data;
 	struct hns3_rx_queue *rxq;
 	struct hns3_tx_queue *txq;
-	int i;
+	uint16_t i;
 
 	if (dev_data->rx_queues)
 		for (i = 0; i < dev_data->nb_rx_queues; i++) {
@@ -3086,7 +3087,7 @@ hns3_tx_free_useless_buffer(struct hns3_tx_queue *txq)
 	uint16_t tx_next_use = txq->next_to_use;
 	struct hns3_entry *tx_entry = &txq->sw_ring[tx_next_clean];
 	struct hns3_desc *desc = &txq->tx_ring[tx_next_clean];
-	int i;
+	uint16_t i;
 
 	if (tx_next_use >= tx_next_clean &&
 	    tx_next_use < tx_next_clean + txq->tx_rs_thresh)
@@ -3984,7 +3985,7 @@ hns3_tx_free_buffer_simple(struct hns3_tx_queue *txq)
 	struct hns3_entry *tx_entry;
 	struct hns3_desc *desc;
 	uint16_t tx_next_clean;
-	int i;
+	uint16_t i;
 
 	while (1) {
 		if (HNS3_GET_TX_QUEUE_PEND_BD_NUM(txq) < txq->tx_rs_thresh)
diff --git a/drivers/net/hns3/hns3_rxtx_vec.h b/drivers/net/hns3/hns3_rxtx_vec.h
index 4985a7cae8..d13f18627d 100644
--- a/drivers/net/hns3/hns3_rxtx_vec.h
+++ b/drivers/net/hns3/hns3_rxtx_vec.h
@@ -15,7 +15,7 @@ hns3_tx_bulk_free_buffers(struct hns3_tx_queue *txq)
 	struct hns3_entry *tx_entry;
 	struct rte_mbuf *m;
 	int nb_free = 0;
-	int i;
+	uint16_t i;
 
 	tx_entry = &txq->sw_ring[txq->next_to_clean];
 	if (txq->mbuf_fast_free_en) {
@@ -56,7 +56,7 @@ static inline void
 hns3_tx_free_buffers(struct hns3_tx_queue *txq)
 {
 	struct hns3_desc *tx_desc;
-	int i;
+	uint16_t i;
 
 	/*
 	 * All mbufs can be released only when the VLD bits of all
-- 
2.22.0

