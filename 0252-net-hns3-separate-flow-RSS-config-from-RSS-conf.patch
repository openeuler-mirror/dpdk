From bfbcc4acf9a007f4774e54febda3eac275b9c747 Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Fri, 10 Mar 2023 17:35:16 +0800
Subject: net/hns3: separate flow RSS config from RSS conf

[ upstream commit b93ad0cc7677881911e5fc3baa89e0a0bbd73c48 ]

Some RSS fields in struct hns3_rss_conf (e.g. conf, queue,
valid) are only used when create RSS flow rule, which is
unnecessary for RSS configuration information from ethdev
ops. This patch removes these fields from hns3_rss_conf
and add a new struct hns3_flow_rss_conf as rte flow
RSS filter list node element.

Cc: stable@dpdk.org

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Dongdong Liu <liudongdong3@huawei.com>
---
 drivers/net/hns3/hns3_flow.c | 23 ++++++++++++-----------
 drivers/net/hns3/hns3_flow.h | 10 +++++++++-
 drivers/net/hns3/hns3_rss.h  |  5 -----
 3 files changed, 21 insertions(+), 17 deletions(-)

diff --git a/drivers/net/hns3/hns3_flow.c b/drivers/net/hns3/hns3_flow.c
index f073adebb6..b1189455ec 100644
--- a/drivers/net/hns3/hns3_flow.c
+++ b/drivers/net/hns3/hns3_flow.c
@@ -1359,7 +1359,6 @@ hns3_parse_rss_filter(struct rte_eth_dev *dev,
 {
 	struct hns3_adapter *hns = dev->data->dev_private;
 	struct hns3_hw *hw = &hns->hw;
-	struct hns3_rss_conf *rss_conf = &hw->rss_info;
 	const struct rte_flow_action_rss *rss;
 	const struct rte_flow_action *act;
 	uint32_t act_index = 0;
@@ -1374,7 +1373,7 @@ hns3_parse_rss_filter(struct rte_eth_dev *dev,
 					  act, "no valid queues");
 	}
 
-	if (rss->queue_num > RTE_DIM(rss_conf->queue))
+	if (rss->queue_num > HNS3_RSS_QUEUES_BUFFER_NUM)
 		return rte_flow_error_set(error, ENOTSUP,
 					  RTE_FLOW_ERROR_TYPE_ACTION_CONF, act,
 					  "queue number configured exceeds "
@@ -1439,7 +1438,7 @@ hns3_disable_rss(struct hns3_hw *hw)
 }
 
 static int
-hns3_parse_rss_algorithm(struct hns3_hw *hw, struct hns3_rss_conf *rss_conf,
+hns3_parse_rss_algorithm(struct hns3_hw *hw, struct hns3_flow_rss_conf *rss_conf,
 			 uint8_t *hash_algo)
 {
 	const uint8_t hash_func_map[] = {
@@ -1466,8 +1465,8 @@ hns3_parse_rss_algorithm(struct hns3_hw *hw, struct hns3_rss_conf *rss_conf,
 		 * rte_flow_hash_algo) when this rule is delivered.
 		 */
 		if (__atomic_load_n(&hw->reset.resetting, __ATOMIC_RELAXED) &&
-		    *hash_algo != rss_conf->rte_flow_hash_algo)
-			*hash_algo = rss_conf->rte_flow_hash_algo;
+		    *hash_algo != rss_conf->hash_algo)
+			*hash_algo = rss_conf->hash_algo;
 
 		return 0;
 	}
@@ -1478,7 +1477,7 @@ hns3_parse_rss_algorithm(struct hns3_hw *hw, struct hns3_rss_conf *rss_conf,
 }
 
 static int
-hns3_hw_rss_hash_set(struct hns3_hw *hw, struct hns3_rss_conf *conf)
+hns3_hw_rss_hash_set(struct hns3_hw *hw, struct hns3_flow_rss_conf *conf)
 {
 	struct rte_flow_action_rss *rss_config = &conf->conf;
 	uint8_t rss_key[HNS3_RSS_KEY_SIZE_MAX] = {0};
@@ -1503,7 +1502,7 @@ hns3_hw_rss_hash_set(struct hns3_hw *hw, struct hns3_rss_conf *conf)
 				    hw->rss_key_size);
 	if (ret)
 		return ret;
-	conf->rte_flow_hash_algo = hash_algo;
+	conf->hash_algo = hash_algo;
 
 	/* Filter the unsupported flow types */
 	flow_types = rss_config->types ?
@@ -1545,7 +1544,8 @@ hns3_update_indir_table(struct hns3_hw *hw,
 }
 
 static int
-hns3_reset_rss_filter(struct hns3_hw *hw, const struct hns3_rss_conf *conf)
+hns3_reset_rss_filter(struct hns3_hw *hw,
+		      const struct hns3_flow_rss_conf *conf)
 {
 	int ret;
 
@@ -1560,7 +1560,7 @@ hns3_reset_rss_filter(struct hns3_hw *hw, const struct hns3_rss_conf *conf)
 }
 
 static int
-hns3_config_rss_filter(struct hns3_hw *hw, struct hns3_rss_conf *conf)
+hns3_config_rss_filter(struct hns3_hw *hw, struct hns3_flow_rss_conf *conf)
 {
 	struct rte_flow_action_rss *rss_act;
 	uint16_t num;
@@ -1669,7 +1669,8 @@ hns3_rss_action_is_dup(struct hns3_hw *hw,
 }
 
 static int
-hns3_flow_parse_rss(struct rte_eth_dev *dev, struct hns3_rss_conf *conf)
+hns3_flow_parse_rss(struct rte_eth_dev *dev,
+		    struct hns3_flow_rss_conf *conf)
 {
 	struct hns3_adapter *hns = dev->data->dev_private;
 	struct hns3_hw *hw = &hns->hw;
@@ -1739,8 +1740,8 @@ hns3_flow_create_rss_rule(struct rte_eth_dev *dev,
 	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
 	const struct rte_flow_action_rss *rss_act;
 	struct hns3_rss_conf_ele *rss_filter_ptr;
+	struct hns3_flow_rss_conf *new_conf;
 	struct hns3_rss_conf_ele *filter_ptr;
-	struct hns3_rss_conf *new_conf;
 	int ret;
 
 	rss_filter_ptr = rte_zmalloc("hns3 rss filter",
diff --git a/drivers/net/hns3/hns3_flow.h b/drivers/net/hns3/hns3_flow.h
index e4b2fdf2e6..90126f2b6e 100644
--- a/drivers/net/hns3/hns3_flow.h
+++ b/drivers/net/hns3/hns3_flow.h
@@ -24,10 +24,18 @@ struct rte_flow {
 	uint32_t counter_id;
 };
 
+struct hns3_flow_rss_conf {
+	struct rte_flow_action_rss conf;
+	uint8_t hash_algo;
+	uint8_t key[HNS3_RSS_KEY_SIZE_MAX];  /* Hash key */
+	uint16_t queue[HNS3_RSS_QUEUES_BUFFER_NUM]; /* Queues indices to use */
+	bool valid; /* check if RSS rule is valid */
+};
+
 /* rss filter list structure */
 struct hns3_rss_conf_ele {
 	TAILQ_ENTRY(hns3_rss_conf_ele) entries;
-	struct hns3_rss_conf filter_info;
+	struct hns3_flow_rss_conf filter_info;
 };
 
 /* hns3_flow memory list structure */
diff --git a/drivers/net/hns3/hns3_rss.h b/drivers/net/hns3/hns3_rss.h
index cc0bb8431d..d19730c69c 100644
--- a/drivers/net/hns3/hns3_rss.h
+++ b/drivers/net/hns3/hns3_rss.h
@@ -40,15 +40,10 @@
 /* Same as the Max queue num under TC */
 #define HNS3_RSS_QUEUES_BUFFER_NUM	512
 struct hns3_rss_conf {
-	/* RSS parameters :algorithm, flow_types,  key, queue */
-	struct rte_flow_action_rss conf;
 	uint64_t rss_hf;
 	uint8_t hash_algo; /* hash function type defined by hardware */
-	uint8_t rte_flow_hash_algo;
 	uint8_t key[HNS3_RSS_KEY_SIZE_MAX];  /* Hash key */
 	uint16_t rss_indirection_tbl[HNS3_RSS_IND_TBL_SIZE_MAX];
-	uint16_t queue[HNS3_RSS_QUEUES_BUFFER_NUM]; /* Queues indices to use */
-	bool valid; /* check if RSS rule is valid */
 	/*
 	 * For IPv6 SCTP packets type, check whether the NIC hardware support
 	 * RSS hash using the src/dst port as the input tuple. For Kunpeng920
-- 
2.23.0

