diff --git a/dpdk-20.11/adapter/meson.build b/dpdk-20.11/adapter/meson.build
new file mode 100644
index 0000000..7be6b00
--- /dev/null
+++ b/dpdk-20.11/adapter/meson.build
@@ -0,0 +1,164 @@
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright(c) 2018 Intel Corporation
+
+sources = files(
+        'rte_atomic_adapter.c',
+        'rte_bus_pci_adapter.c',
+        'rte_bus_vdev_adapter.c',
+        'rte_cycles_adapter.c',
+        'rte_dev_adapter.c',
+        'rte_devargs_adapter.c',
+        'rte_ethdev_adapter.c',
+        'rte_ethdev_driver_adapter.c',
+        'rte_ethdev_pci_adapter.c',
+        'rte_flow_adapter.c',
+        'rte_mbuf_adapter.c',
+        'rte_mempool_adapter.c',
+        'rte_ring_adapter.c',
+        'rte_spinlock_adapter.c')
+
+headers = files('rte_adapter.h')
+
+libname = 'rte_adapter'
+
+default_cflags = machine_args
+default_cflags += ['-DALLOW_EXPERIMENTAL_API']
+default_cflags += ['-DALLOW_INTERNAL_API']
+
+if cc.has_argument('-Wno-format-truncation')
+    default_cflags += '-Wno-format-truncation'
+endif
+
+reason = '<unknown reason>' # set if build == false to explain why
+name = 'adapter'
+use_function_versioning = false
+
+indirect_headers = [] # public headers not directly included by apps
+driver_sdk_headers = [] # public headers included by drivers
+includes = []
+cflags = default_cflags
+objs = [] # other object files to link against, used e.g. for
+          # instruction-set optimized versions of code
+
+# use "deps" for internal DPDK dependencies, and "ext_deps" for
+# external package/library requirements
+ext_deps = []
+deps += ['cfgfile', 'eal', 'kvargs', 'mempool', 'pci', 'bus_pci', 'bus_vdev', 'ring', 'mbuf', 'timer', 'ethdev']
+
+# eal is standard dependency once built
+if dpdk_conf.has('RTE_LIB_EAL')
+    deps += ['eal']
+endif
+
+shared_deps = ext_deps
+static_deps = ext_deps
+foreach d:deps
+    if not is_variable('shared_rte_' + d)
+        error('Missing internal dependency "@0@" for @name@ [@2@]'
+                .format(d, name, 'lib/' + name))
+    endif
+    shared_deps += [get_variable('shared_rte_' + d)]
+    static_deps += [get_variable('static_rte_' + d)]
+endforeach
+
+dpdk_conf.set('RTE_LIB_' + name.to_upper(), name)
+install_headers(headers)
+install_headers(indirect_headers)
+#if get_option('enable_driver_sdk')
+#    install_headers(driver_sdk_headers)
+#endif
+#dpdk_chkinc_headers += headers
+
+libname = 'rte_' + name
+#includes += include_directories(name)
+
+#if developer_mode and is_windows and use_function_versioning
+#    message('@0@: Function versioning is not supported by Windows.'.format(name))
+#endif
+
+if use_function_versioning
+    cflags += '-DRTE_USE_FUNCTION_VERSIONING'
+endif
+cflags += '-DRTE_LOG_DEFAULT_LOGTYPE=lib.' + name
+
+# first build static lib
+static_lib = static_library(libname,
+        sources,
+        objects: objs,
+        c_args: cflags,
+        dependencies: static_deps,
+        include_directories: includes,
+        install: true)
+static_dep = declare_dependency(
+        include_directories: includes,
+        dependencies: static_deps)
+
+if not use_function_versioning or is_windows
+    # use pre-build objects to build shared lib
+    sources = []
+    objs += static_lib.extract_all_objects(recursive: false)
+else
+    # for compat we need to rebuild with
+    # RTE_BUILD_SHARED_LIB defined
+    cflags += '-DRTE_BUILD_SHARED_LIB'
+endif
+version_map = '@0@/version.map'.format(
+        meson.current_source_dir())
+implib = 'librte_' + name + '.dll.a'
+
+def_file = custom_target(libname + '_def',
+        command: [map_to_win_cmd, '@INPUT@', '@OUTPUT@'],
+        input: version_map,
+        output: '@0@_exports.def'.format(libname))
+
+mingw_map = custom_target(libname + '_mingw',
+        command: [map_to_win_cmd, '@INPUT@', '@OUTPUT@'],
+        input: version_map,
+        output: '@0@_mingw.map'.format(libname))
+
+if is_ms_linker
+    lk_args = ['-Wl,/def:' + def_file.full_path()]
+    if meson.version().version_compare('<0.54.0')
+        lk_args += ['-Wl,/implib:lib\\' + implib]
+    endif
+else
+    if is_windows
+        lk_args = ['-Wl,--version-script=' + mingw_map.full_path()]
+    else
+        lk_args = ['-Wl,--version-script=' + version_map]
+    endif
+endif
+
+lk_deps = [version_map, def_file, mingw_map]
+#if developer_mode and not is_windows
+    # on unix systems check the output of the
+    # check-symbols.sh script, using it as a
+    # dependency of the .so build
+#    lk_deps += custom_target(name + '.sym_chk',
+#            command: [check_symbols,
+#                version_map, '@INPUT@'],
+#            capture: true,
+#            input: static_lib,
+#            output: name + '.sym_chk')
+#endif
+
+shared_lib = shared_library(libname,
+        sources,
+        objects: objs,
+        c_args: cflags,
+        dependencies: shared_deps,
+        include_directories: includes,
+        link_args: lk_args,
+        link_depends: lk_deps,
+        version: abi_version,
+        soversion: so_version,
+        install: true)
+shared_dep = declare_dependency(link_with: shared_lib,
+        include_directories: includes,
+        dependencies: shared_deps)
+
+dpdk_libraries = [shared_lib] + dpdk_libraries
+dpdk_static_libraries = [static_lib] + dpdk_static_libraries
+
+set_variable('shared_rte_' + name, shared_dep)
+set_variable('static_rte_' + name, static_dep)
diff --git a/dpdk-20.11/adapter/rte_adapter.h b/dpdk-20.11/adapter/rte_adapter.h
new file mode 100644
index 0000000..118ed33
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_adapter.h
@@ -0,0 +1,189 @@
+#ifndef _RTE_ADAPTER_H
+#define _RTE_ADAPTER_H
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdarg.h>
+
+#include "rte_atomic.h"
+#include "rte_bus.h"
+#include "rte_bus_pci.h"
+#include "rte_bus_vdev.h"
+#include "rte_cfgfile.h"
+#include "rte_cycles.h"
+#include "rte_dev.h"
+#include "rte_devargs.h"
+#include "rte_ethdev.h"
+#include "rte_ethdev_driver.h"
+#include "rte_bus_pci.h"
+#include "rte_ethdev_pci.h"
+#include "rte_flow.h"
+#include "rte_flow_driver.h"
+#include "rte_mbuf.h"
+#include "rte_mempool.h"
+#include "rte_ring.h"
+#include "rte_spinlock.h"
+
+extern void rte_adapter_init(void);
+extern void rte_adapter_uninit(void);
+
+void rte_atomic16_init_stub(rte_atomic16_t *v);
+int16_t rte_atomic16_read_stub(const rte_atomic16_t *v);
+void rte_atomic16_set_stub(rte_atomic16_t *v, int16_t new_value);
+void rte_atomic16_add_stub(rte_atomic16_t *v, int16_t inc);
+void rte_atomic16_sub_stub(rte_atomic16_t *v, int16_t dec);
+void rte_atomic16_inc_stub(rte_atomic16_t *v);
+void rte_atomic16_dec_stub(rte_atomic16_t *v);
+void rte_atomic32_init_stub(rte_atomic32_t *v);
+int32_t rte_atomic32_read_stub(rte_atomic32_t *v);
+void rte_atomic32_set_stub(rte_atomic32_t *v, int32_t new_value);
+void rte_atomic32_add_stub(rte_atomic32_t *v, int32_t inc);
+void rte_atomic32_sub_stub(rte_atomic32_t *v, int32_t dec);
+void rte_atomic32_inc_stub(rte_atomic32_t *v);
+void rte_atomic32_dec_stub(rte_atomic32_t *v);
+
+struct rte_pci_device_list* rte_pci_bus_get_device_list_ptr(struct rte_pci_bus *pci_bus);
+struct rte_pci_device* rte_pci_device_list_get_first(struct rte_pci_device_list *device_list);
+struct rte_pci_driver* rte_pci_driver_allocate(void);
+void rte_pci_driver_free(struct rte_pci_driver *driver);
+void rte_pci_driver_set_name(struct rte_pci_driver *driver, const char *name);
+void rte_pci_driver_set_id_table(struct rte_pci_driver *driver, const struct rte_pci_id *pci_id);
+void rte_pci_driver_set_drv_flags(struct rte_pci_driver *driver, uint32_t drv_flags);
+void rte_pci_driver_set_probe(struct rte_pci_driver *driver, void *arg);
+void rte_pci_driver_set_remove(struct rte_pci_driver *driver, void *arg);
+struct rte_pci_device* rte_pci_device_get_next(struct rte_pci_device *pci_dev);
+struct rte_pci_addr* rte_pci_device_get_addr_ptr(struct rte_pci_device *device);
+struct rte_pci_id* rte_pci_device_get_id_ptr(struct rte_pci_device *device);
+struct rte_mem_resource* rte_pci_device_get_mem_resource(struct rte_pci_device *device);
+struct rte_device* rte_pci_device_get_device_ptr(struct rte_pci_device *device);
+char* rte_pci_device_get_name(struct rte_pci_device *device);
+
+struct rte_device* rte_vdev_device_get_device_ptr(struct rte_vdev_device *dev);
+const char* rte_vdev_device_name_stub(const struct rte_vdev_device *dev);
+struct rte_vdev_driver* rte_vdev_driver_allocate(void);
+void rte_vdev_driver_free(struct rte_vdev_driver *driver);
+void rte_vdev_driver_set_probe(struct rte_vdev_driver *driver, void *arg);
+void rte_vdev_driver_set_remove(struct rte_vdev_driver *driver, void *arg);
+void rte_vdev_driver_set_name(struct rte_vdev_driver *driver, const char *name);
+void rte_vdev_driver_set_alias(struct rte_vdev_driver *driver, const char *alias);
+
+uint64_t rte_get_tsc_cycles_stub(void);
+void rte_delay_ms_stub(unsigned ms);
+uint64_t rte_rdtsc_stub(void);
+uint64_t rte_get_tsc_hz_stub(void);
+
+const struct rte_driver* rte_device_get_driver(struct rte_device *device);
+const char* rte_device_get_name(struct rte_device *device);
+struct rte_devargs* rte_device_get_devargs(struct rte_device *device);
+
+struct rte_eth_dev_info* rte_eth_dev_info_allocate(void);
+void rte_eth_dev_info_free(struct rte_eth_dev_info *info);
+void rte_eth_dev_info_set_driver_name(struct rte_eth_dev_info *info, char *driver_name);
+void rte_eth_dev_info_set_max_rx_queues(struct rte_eth_dev_info *info, uint16_t max_rx_queues);
+void rte_eth_dev_info_set_max_tx_queues(struct rte_eth_dev_info *info, uint16_t max_tx_queues);
+void rte_eth_dev_info_set_max_rx_pktlen(struct rte_eth_dev_info *info, uint32_t max_rx_pktlen);
+void rte_eth_dev_info_set_min_mtu(struct rte_eth_dev_info *info, uint16_t min_mtu);
+void rte_eth_dev_info_set_max_mtu(struct rte_eth_dev_info *info, uint16_t max_mtu);
+void rte_eth_dev_info_set_if_index(struct rte_eth_dev_info *info, unsigned int if_index);
+const char* rte_eth_dev_info_get_driver_name(struct rte_eth_dev_info *info);
+uint32_t rte_eth_dev_info_get_if_index(struct rte_eth_dev_info *info);
+
+void rte_eth_dev_set_device(struct rte_eth_dev *dev, struct rte_device *device);
+void rte_eth_dev_set_dev_ops(struct rte_eth_dev *dev, struct eth_dev_ops *dev_ops);
+void rte_eth_dev_set_rx_pkt_burst(struct rte_eth_dev *dev, void *burst_cb);
+void rte_eth_dev_set_tx_pkt_burst(struct rte_eth_dev *dev, void *burst_cb);
+struct rte_device* rte_eth_dev_get_device(struct rte_eth_dev *dev);
+struct rte_eth_dev_data* rte_eth_dev_get_data(struct rte_eth_dev *dev);
+void* rte_eth_dev_get_data_dev_private(struct rte_eth_dev *dev);
+struct rte_eth_link* rte_eth_dev_get_data_dev_link_ptr(struct rte_eth_dev *dev);
+struct rte_pci_device* rte_eth_dev_get_pci_device_ptr(struct rte_eth_dev *dev);
+void rte_eth_dev_data_set_rx_queues(struct rte_eth_dev_data *data, void **queues);
+void rte_eth_dev_data_set_rx_queue_single(struct rte_eth_dev_data *data, int idx, void *queue);
+void rte_eth_dev_data_set_tx_queues(struct rte_eth_dev_data *data, void **queues);
+void rte_eth_dev_data_set_tx_queue_single(struct rte_eth_dev_data *data, int idx, void *queue);
+void rte_eth_dev_data_set_dev_private(struct rte_eth_dev_data *data, void *private_data);
+void rte_eth_dev_data_set_nb_rx_queues(struct rte_eth_dev_data *data,uint16_t nb_queues);
+void rte_eth_dev_data_set_nb_tx_queues(struct rte_eth_dev_data *data, uint16_t nb_queues);
+void rte_eth_dev_data_set_dev_link(struct rte_eth_dev_data *data, struct rte_eth_link dev_link);
+void rte_eth_dev_data_set_mac_addrs(struct rte_eth_dev_data *data, struct rte_ether_addr *mac_addrs);
+void rte_eth_dev_data_set_numa_node(struct rte_eth_dev_data *data, int numa_node);
+void rte_eth_dev_data_set_mtu(struct rte_eth_dev_data *data, uint16_t mtu);
+void rte_eth_dev_data_set_dev_started(struct rte_eth_dev_data *data, uint8_t dev_started);
+void* rte_eth_dev_data_get_rx_queue_single(struct rte_eth_dev_data *data, int idx);
+void* rte_eth_dev_data_get_tx_queue_single(struct rte_eth_dev_data *data, int idx);
+uint16_t rte_eth_dev_data_get_nb_rx_queues(struct rte_eth_dev_data *data);
+uint16_t rte_eth_dev_data_get_nb_tx_queues(struct rte_eth_dev_data *data);
+struct rte_ether_addr* rte_eth_dev_data_get_mac_addrs(struct rte_eth_dev_data *data);
+int rte_eth_dev_data_get_numa_node(struct rte_eth_dev_data *data);
+char* rte_eth_dev_data_get_name(struct rte_eth_dev_data *data);
+void* rte_eth_dev_data_get_dev_private(struct rte_eth_dev_data *data);
+struct rte_eth_link* rte_eth_dev_data_get_dev_link_ptr(struct rte_eth_dev_data *data);
+uint16_t rte_eth_dev_data_get_mtu(struct rte_eth_dev_data *data);
+uint8_t rte_eth_dev_data_get_dev_started(struct rte_eth_dev_data *data);
+
+struct eth_dev_ops* rte_eth_dev_ops_allocate(void);
+void rte_eth_dev_ops_free(struct eth_dev_ops *edev_ops);
+void rte_eth_dev_ops_set_dev_configure(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_dev_start(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_dev_stop(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_dev_close(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_dev_set_link_down(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_dev_set_link_up(struct eth_dev_ops *edev_ops,void *arg);
+void rte_eth_dev_ops_set_dev_infos_get(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_stats_get(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_stats_reset(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_xstats_get_names(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_link_update(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_mtu_set(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_rx_queue_setup(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_tx_queue_setup(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_rx_queue_release(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_tx_queue_release(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_flow_ops_get(struct eth_dev_ops *edev_ops, void *arg);
+void rte_eth_dev_ops_set_extra_config_set(struct eth_dev_ops *edev_ops, void *arg);
+
+int rte_eth_dev_pci_generic_probe_stub(struct rte_pci_device *pci_dev,
+    size_t private_data_size, eth_dev_pci_callback_t dev_init);
+int rte_eth_dev_pci_generic_remove_stub(struct rte_pci_device *pci_dev,
+    eth_dev_pci_callback_t dev_uninit);
+
+struct rte_flow_ops* rte_flow_ops_allocate(void);
+void rte_flow_ops_free(struct rte_flow_ops *flow_ops);
+void rte_flow_ops_set_validate(struct rte_flow_ops *flow_ops, void *arg);
+void rte_flow_ops_set_create(struct rte_flow_ops *flow_ops, void *arg);
+void rte_flow_ops_set_destroy(struct rte_flow_ops *flow_ops, void *arg);
+void rte_flow_ops_set_flush(struct rte_flow_ops *flow_ops, void *arg);
+void rte_flow_ops_set_query(struct rte_flow_ops *flow_ops, void *arg);
+
+size_t rte_mbuf_struct_size(void);
+void* rte_mbuf_get_udata64_ptr(struct rte_mbuf *mbuf);
+void* rte_pktmbuf_get_data(struct rte_mbuf *mbuf);
+uint32_t rte_pktmbuf_get_data_len(struct rte_mbuf *mbuf);
+uint32_t rte_pktmbuf_get_pkt_len(struct rte_mbuf *mbuf);
+uint64_t rte_mbuf_get_ol_flags(struct rte_mbuf *mbuf);
+uint16_t rte_mbuf_get_vlan_tci(struct rte_mbuf *mbuf);
+uint32_t rte_mbuf_get_hash_rss(struct rte_mbuf *mbuf);
+void rte_mbuf_set_ol_flags(struct rte_mbuf *mbuf, uint64_t flag);
+struct rte_mbuf* rte_pktmbuf_alloc_stub(struct rte_mempool *mp);
+int rte_pktmbuf_alloc_bulk_stub(struct rte_mempool *pool,
+    struct rte_mbuf **mbufs, unsigned count);
+void rte_pktmbuf_free_stub(struct rte_mbuf *m);
+
+int rte_mempool_get_stub(struct rte_mempool *mp, void **obj_p);
+void rte_mempool_put_bulk_stub(struct rte_mempool *mp, void *const *obj_table, 
+    unsigned int n);
+void rte_mempool_put_stub(struct rte_mempool *mp, void *obj);
+
+unsigned int rte_ring_enqueue_burst_stub(struct rte_ring *r, void *const *obj_table,
+    unsigned int n, unsigned int *free_space);
+unsigned int rte_ring_dequeue_burst_stub(struct rte_ring *r, void **obj_table,
+    unsigned int n, unsigned int *available);
+unsigned int rte_ring_count_stub(const struct rte_ring *r);
+
+void rte_spinlock_init_stub(rte_spinlock_t *sl);
+void rte_spinlock_lock_stub(rte_spinlock_t *sl);
+void rte_spinlock_unlock_stub(rte_spinlock_t *sl);
+void rte_spinlock_trylock_stub(rte_spinlock_t *sl);
+
+#endif
\ No newline at end of file
diff --git a/dpdk-20.11/adapter/rte_atomic_adapter.c b/dpdk-20.11/adapter/rte_atomic_adapter.c
new file mode 100644
index 0000000..4706ef5
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_atomic_adapter.c
@@ -0,0 +1,72 @@
+#include "rte_atomic.h"
+#include "rte_adapter.h"
+
+void rte_atomic16_init_stub(rte_atomic16_t *v)
+{
+    rte_atomic16_init(v);
+}
+
+int16_t rte_atomic16_read_stub(const rte_atomic16_t *v)
+{
+    return rte_atomic16_read(v);
+}
+
+void rte_atomic16_set_stub(rte_atomic16_t *v, int16_t new_value)
+{
+    rte_atomic16_set(v, new_value);
+}
+
+void rte_atomic16_add_stub(rte_atomic16_t *v, int16_t inc)
+{
+    rte_atomic16_add(v, inc);
+}
+
+void rte_atomic16_sub_stub(rte_atomic16_t *v, int16_t dec)
+{
+    rte_atomic16_sub(v, dec);
+}
+
+void rte_atomic16_inc_stub(rte_atomic16_t *v)
+{
+    rte_atomic16_inc(v);
+}
+
+void rte_atomic16_dec_stub(rte_atomic16_t *v)
+{
+    rte_atomic16_dec(v);
+}
+
+void rte_atomic32_init_stub(rte_atomic32_t *v)
+{
+    rte_atomic32_init(v);
+}
+
+int32_t rte_atomic32_read_stub(rte_atomic32_t *v)
+{
+    return rte_atomic32_read(v);
+}
+
+void rte_atomic32_set_stub(rte_atomic32_t *v, int32_t new_value)
+{
+    rte_atomic32_set(v, new_value);
+}
+
+void rte_atomic32_add_stub(rte_atomic32_t *v, int32_t inc)
+{
+    rte_atomic32_add(v, inc);
+}
+
+void rte_atomic32_sub_stub(rte_atomic32_t *v, int32_t dec)
+{
+    rte_atomic32_sub(v, dec);
+}
+
+void rte_atomic32_inc_stub(rte_atomic32_t *v)
+{
+    rte_atomic32_inc(v);
+}
+
+void rte_atomic32_dec_stub(rte_atomic32_t *v)
+{
+    rte_atomic32_dec(v);
+}
diff --git a/dpdk-20.11/adapter/rte_bus_pci_adapter.c b/dpdk-20.11/adapter/rte_bus_pci_adapter.c
new file mode 100644
index 0000000..402c071
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_bus_pci_adapter.c
@@ -0,0 +1,78 @@
+#include <sys/queue.h>
+#include "rte_bus_pci.h"
+#include "rte_adapter.h"
+
+struct rte_pci_device_list* rte_pci_bus_get_device_list_ptr(struct rte_pci_bus *pci_bus)
+{
+    return &pci_bus->device_list;
+}
+
+struct rte_pci_device* rte_pci_device_list_get_first(struct rte_pci_device_list *device_list)
+{
+    return TAILQ_FIRST(device_list);
+}
+
+struct rte_pci_driver* rte_pci_driver_allocate(void)
+{
+    return calloc(1, sizeof(struct rte_pci_driver)); // 考虑malloc是否合适 + glic malloc是否在construtor阶段即准备好
+}
+
+void rte_pci_driver_free(struct rte_pci_driver *driver)
+{
+    free(driver);
+}
+
+void rte_pci_driver_set_name(struct rte_pci_driver *driver, const char *name)
+{
+    driver->driver.name = name;
+}
+
+void rte_pci_driver_set_id_table(struct rte_pci_driver *driver, const struct rte_pci_id *pci_id)
+{
+    driver->id_table = pci_id;
+}
+
+void rte_pci_driver_set_drv_flags(struct rte_pci_driver *driver, uint32_t drv_flags)
+{
+    driver->drv_flags = drv_flags;
+}
+
+void rte_pci_driver_set_probe(struct rte_pci_driver *driver, void *arg)
+{
+    driver->probe = (pci_probe_t*)arg;
+}
+
+void rte_pci_driver_set_remove(struct rte_pci_driver *driver, void *arg)
+{
+    driver->remove = (pci_remove_t*)arg;
+}
+
+struct rte_pci_device* rte_pci_device_get_next(struct rte_pci_device *pci_dev)
+{
+    return TAILQ_NEXT(pci_dev, next);
+}
+
+struct rte_pci_addr* rte_pci_device_get_addr_ptr(struct rte_pci_device *device)
+{
+    return &device->addr;
+}
+
+struct rte_pci_id* rte_pci_device_get_id_ptr(struct rte_pci_device *device)
+{
+    return &device->id;
+}
+
+struct rte_mem_resource* rte_pci_device_get_mem_resource(struct rte_pci_device *device)
+{
+    return device->mem_resource;
+}
+
+struct rte_device* rte_pci_device_get_device_ptr(struct rte_pci_device *device)
+{
+    return &device->device;
+}
+
+char* rte_pci_device_get_name(struct rte_pci_device *device)
+{
+    return device->name;
+}
diff --git a/dpdk-20.11/adapter/rte_bus_vdev_adapter.c b/dpdk-20.11/adapter/rte_bus_vdev_adapter.c
new file mode 100644
index 0000000..bab3af2
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_bus_vdev_adapter.c
@@ -0,0 +1,42 @@
+#include "rte_bus_vdev.h"
+#include "rte_adapter.h"
+
+struct rte_device* rte_vdev_device_get_device_ptr(struct rte_vdev_device *dev)
+{
+    return &dev->device;
+}
+
+const char* rte_vdev_device_name_stub(const struct rte_vdev_device *dev)
+{
+    return rte_vdev_device_name(dev);
+}
+
+struct rte_vdev_driver* rte_vdev_driver_allocate(void)
+{
+    return calloc(1, sizeof(struct rte_vdev_driver));
+}
+
+void rte_vdev_driver_free(struct rte_vdev_driver *driver)
+{
+    free(driver);
+}
+
+void rte_vdev_driver_set_probe(struct rte_vdev_driver *driver, void *arg)
+{
+    driver->probe = (rte_vdev_probe_t*)arg;
+}
+
+void rte_vdev_driver_set_remove(struct rte_vdev_driver *driver, void *arg)
+{
+    driver->remove = (rte_vdev_remove_t*)arg;
+}
+
+void rte_vdev_driver_set_name(struct rte_vdev_driver *driver, const char *name)
+{
+    driver->driver.name = name;
+}
+
+void rte_vdev_driver_set_alias(struct rte_vdev_driver *driver, const char *alias)
+{
+    driver->driver.alias = alias;
+}
diff --git a/dpdk-20.11/adapter/rte_cycles_adapter.c b/dpdk-20.11/adapter/rte_cycles_adapter.c
new file mode 100644
index 0000000..18af096
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_cycles_adapter.c
@@ -0,0 +1,22 @@
+#include "rte_cycles.h"
+#include "rte_adapter.h"
+
+uint64_t rte_get_tsc_cycles_stub(void)
+{
+    return rte_get_tsc_cycles();
+}
+
+void rte_delay_ms_stub(unsigned ms)
+{
+    rte_delay_ms(ms);
+}
+
+uint64_t rte_rdtsc_stub(void)
+{
+    return rte_rdtsc();
+}
+
+uint64_t rte_get_tsc_hz_stub(void)
+{
+    return rte_get_tsc_hz();
+}
\ No newline at end of file
diff --git a/dpdk-20.11/adapter/rte_dev_adapter.c b/dpdk-20.11/adapter/rte_dev_adapter.c
new file mode 100644
index 0000000..5c1d5fc
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_dev_adapter.c
@@ -0,0 +1,22 @@
+#include "rte_dev.h"
+#include "rte_adapter.h"
+
+const struct rte_driver* rte_device_get_driver(struct rte_device *device)
+{
+    return device->driver;
+}
+
+const char* rte_device_get_name(struct rte_device *device)
+{
+    return device->name;
+}
+
+struct rte_devargs* rte_device_get_devargs(struct rte_device *device)
+{
+    return device->devargs;
+}
+
+const char* rte_driver_get_name(struct rte_driver *driver)
+{
+    return driver->name;
+}
diff --git a/dpdk-20.11/adapter/rte_devargs_adapter.c b/dpdk-20.11/adapter/rte_devargs_adapter.c
new file mode 100644
index 0000000..177ab2c
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_devargs_adapter.c
@@ -0,0 +1,7 @@
+#include "rte_devargs.h"
+#include "rte_adapter.h"
+
+const char* rte_devargs_get_args(struct rte_devargs *devargs)
+{
+    return devargs->args;
+}
diff --git a/dpdk-20.11/adapter/rte_ethdev_adapter.c b/dpdk-20.11/adapter/rte_ethdev_adapter.c
new file mode 100644
index 0000000..5de8eeb
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_ethdev_adapter.c
@@ -0,0 +1,57 @@
+#include "rte_ethdev.h"
+#include "rte_adapter.h"
+
+struct rte_eth_dev_info* rte_eth_dev_info_allocate(void)
+{
+    return calloc(1, sizeof(struct rte_eth_dev_info));
+}
+
+void rte_eth_dev_info_free(struct rte_eth_dev_info *info)
+{
+    free(info);
+}
+
+void rte_eth_dev_info_set_driver_name(struct rte_eth_dev_info *info, char *driver_name)
+{
+    info->driver_name = driver_name;
+}
+
+void rte_eth_dev_info_set_max_rx_queues(struct rte_eth_dev_info *info, uint16_t max_rx_queues)
+{
+    info->max_rx_queues = max_rx_queues;
+}
+
+void rte_eth_dev_info_set_max_tx_queues(struct rte_eth_dev_info *info, uint16_t max_tx_queues)
+{
+    info->max_tx_queues = max_tx_queues;
+}
+
+void rte_eth_dev_info_set_max_rx_pktlen(struct rte_eth_dev_info *info, uint32_t max_rx_pktlen)
+{
+    info->max_rx_pktlen = max_rx_pktlen;
+}
+
+void rte_eth_dev_info_set_min_mtu(struct rte_eth_dev_info *info, uint16_t min_mtu)
+{
+    info->min_mtu = min_mtu;
+}
+
+void rte_eth_dev_info_set_max_mtu(struct rte_eth_dev_info *info, uint16_t max_mtu)
+{
+    info->max_mtu = max_mtu;
+}
+
+void rte_eth_dev_info_set_if_index(struct rte_eth_dev_info *info, unsigned int if_index)
+{
+    info->if_index = if_index;
+}
+
+const char* rte_eth_dev_info_get_driver_name(struct rte_eth_dev_info *info)
+{
+    return info->driver_name;
+}
+
+uint32_t rte_eth_dev_info_get_if_index(struct rte_eth_dev_info *info)
+{
+    return info->if_index;
+}
diff --git a/dpdk-20.11/adapter/rte_ethdev_driver_adapter.c b/dpdk-20.11/adapter/rte_ethdev_driver_adapter.c
new file mode 100644
index 0000000..9e0ede8
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_ethdev_driver_adapter.c
@@ -0,0 +1,288 @@
+#include "rte_ethdev_driver.h"
+#include "rte_bus_pci.h"
+#include "rte_adapter.h"
+
+void rte_eth_dev_set_device(struct rte_eth_dev *dev, struct rte_device *device)
+{
+    dev->device = device;
+}
+
+void rte_eth_dev_set_dev_ops(struct rte_eth_dev *dev, struct eth_dev_ops *dev_ops)
+{
+    dev->dev_ops = dev_ops;
+}
+
+void rte_eth_dev_set_rx_pkt_burst(struct rte_eth_dev *dev, void *burst_cb)
+{
+    dev->rx_pkt_burst = burst_cb;
+}
+
+void rte_eth_dev_set_tx_pkt_burst(struct rte_eth_dev *dev, void *burst_cb)
+{
+    dev->tx_pkt_burst = burst_cb;
+}
+
+struct rte_device* rte_eth_dev_get_device(struct rte_eth_dev *dev)
+{
+    return dev->device;
+}
+
+struct rte_eth_dev_data* rte_eth_dev_get_data(struct rte_eth_dev *dev)
+{
+    return dev->data;
+}
+
+void* rte_eth_dev_get_data_dev_private(struct rte_eth_dev *dev)
+{
+    return dev->data->dev_private;
+}
+
+struct rte_eth_link* rte_eth_dev_get_data_dev_link_ptr(struct rte_eth_dev *dev)
+{
+    return &dev->data->dev_link;
+}
+
+struct rte_pci_device* rte_eth_dev_get_pci_device_ptr(struct rte_eth_dev *dev)
+{
+    return RTE_ETH_DEV_TO_PCI(dev);
+}
+
+void rte_eth_dev_data_set_rx_queues(struct rte_eth_dev_data *data, void **queues)
+{
+    data->rx_queues = queues;
+}
+
+void rte_eth_dev_data_set_rx_queue_single(struct rte_eth_dev_data *data, int idx, void *queue)
+{
+    data->rx_queues[idx]=queue;
+}
+
+void rte_eth_dev_data_set_tx_queues(struct rte_eth_dev_data *data, void **queues)
+{
+    data->tx_queues=queues;
+}
+
+void rte_eth_dev_data_set_tx_queue_single(struct rte_eth_dev_data *data, int idx, void *queue)
+{
+    data->tx_queues[idx] = queue;
+}
+
+void rte_eth_dev_data_set_dev_private(struct rte_eth_dev_data *data, void *private_data)
+{
+    data->dev_private = private_data;
+}
+
+void rte_eth_dev_data_set_nb_rx_queues(struct rte_eth_dev_data *data,uint16_t nb_queues)
+{
+    data->nb_rx_queues = nb_queues;
+}
+
+void rte_eth_dev_data_set_nb_tx_queues(struct rte_eth_dev_data *data, uint16_t nb_queues)
+{
+    data->nb_tx_queues = nb_queues;
+}
+
+void rte_eth_dev_data_set_dev_link(struct rte_eth_dev_data *data, struct rte_eth_link dev_link)
+{
+    data->dev_link = dev_link;
+}
+
+void rte_eth_dev_data_set_mac_addrs(struct rte_eth_dev_data *data, struct rte_ether_addr *mac_addrs)
+{
+    data->mac_addrs = mac_addrs;
+}
+
+void rte_eth_dev_data_set_numa_node(struct rte_eth_dev_data *data, int numa_node)
+{
+    data->numa_node = numa_node;
+}
+
+void rte_eth_dev_data_set_mtu(struct rte_eth_dev_data *data, uint16_t mtu)
+{
+    data->mtu = mtu;
+}
+
+void rte_eth_dev_data_set_dev_started(struct rte_eth_dev_data *data, uint8_t dev_started)
+{
+    data->dev_started = dev_started;
+}
+
+void* rte_eth_dev_data_get_rx_queue_single(struct rte_eth_dev_data *data, int idx)
+{
+    return data->rx_queues[idx];
+}
+
+void* rte_eth_dev_data_get_tx_queue_single(struct rte_eth_dev_data *data, int idx)
+{
+    return data->tx_queues[idx];
+}
+
+uint16_t rte_eth_dev_data_get_nb_rx_queues(struct rte_eth_dev_data *data)
+{
+    return data->nb_rx_queues;
+}
+
+uint16_t rte_eth_dev_data_get_nb_tx_queues(struct rte_eth_dev_data *data)
+{
+    return data->nb_tx_queues;
+}
+
+struct rte_ether_addr* rte_eth_dev_data_get_mac_addrs(struct rte_eth_dev_data *data)
+{
+    return data->mac_addrs;
+}
+
+int rte_eth_dev_data_get_numa_node(struct rte_eth_dev_data *data)
+{
+    return data->numa_node;
+}
+
+char* rte_eth_dev_data_get_name(struct rte_eth_dev_data *data)
+{
+    return data->name;
+}
+
+void* rte_eth_dev_data_get_dev_private(struct rte_eth_dev_data *data)
+{
+    return data->dev_private;
+}
+
+struct rte_eth_link* rte_eth_dev_data_get_dev_link_ptr(struct rte_eth_dev_data *data)
+{
+    return &data->dev_link;
+}
+
+uint16_t rte_eth_dev_data_get_mtu(struct rte_eth_dev_data *data)
+{
+    return data->mtu;
+}
+
+uint8_t rte_eth_dev_data_get_dev_started(struct rte_eth_dev_data *data)
+{
+    return data->dev_started;
+}
+
+struct eth_dev_ops* rte_eth_dev_ops_allocate(void)
+{
+    return calloc(1,sizeof(struct eth_dev_ops));
+}
+
+void rte_eth_dev_ops_free(struct eth_dev_ops *edev_ops)
+{
+    free(edev_ops);
+}
+
+void rte_eth_dev_ops_set_dev_configure(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->dev_configure = arg;
+}
+
+void rte_eth_dev_ops_set_dev_start(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->dev_start = arg;
+}
+
+void rte_eth_dev_ops_set_dev_stop(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->dev_stop = arg;
+}
+
+void rte_eth_dev_ops_set_dev_close(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->dev_close = arg;
+}
+
+void rte_eth_dev_ops_set_dev_set_link_down(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->dev_set_link_down = arg;
+}
+
+void rte_eth_dev_ops_set_dev_set_link_up(struct eth_dev_ops *edev_ops,void *arg)
+{
+    edev_ops->dev_set_link_up = arg;
+}
+
+void rte_eth_dev_ops_set_dev_infos_get(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->dev_infos_get = arg;
+}
+
+void rte_eth_dev_ops_set_stats_get(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->stats_get = arg;
+}
+
+void rte_eth_dev_ops_set_stats_reset(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->stats_reset = arg;
+}
+
+void rte_eth_dev_ops_set_xstats_get(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->xstats_get = arg;
+}
+
+void rte_eth_dev_ops_set_xstats_reset(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->xstats_reset = arg;
+}
+
+void rte_eth_dev_ops_set_xstats_get_names(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->xstats_get_names = arg;
+}
+
+void rte_eth_dev_ops_set_link_update(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->link_update = arg;
+}
+
+void rte_eth_dev_ops_set_mtu_set(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->mtu_set = arg;
+}
+
+void rte_eth_dev_ops_set_rx_queue_setup(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->rx_queue_setup = arg;
+}
+
+void rte_eth_dev_ops_set_tx_queue_setup(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->tx_queue_setup = arg;
+}
+
+void rte_eth_dev_ops_set_rx_queue_release(struct eth_dev_ops *edev_ops, void *arg)
+{
+    
+}
+
+void rte_eth_dev_ops_set_tx_queue_release(struct eth_dev_ops *edev_ops, void *arg)
+{
+    
+}
+void
+rte_eth_dev_ops_set_rx_queue_release_dpdk2011(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->rx_queue_release = arg;
+}
+
+void rte_eth_dev_ops_set_tx_queue_release_dpdk2011(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->tx_queue_release = arg;
+}
+
+void rte_eth_dev_ops_set_filter_ctrl(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->filter_ctrl = arg;
+}
+
+void rte_eth_dev_ops_set_flow_ops_get(struct eth_dev_ops *edev_ops, void *arg)
+{
+    
+}
+
+void rte_eth_dev_ops_set_extra_config_set(struct eth_dev_ops *edev_ops, void *arg)
+{
+    edev_ops->extra_config_set = arg;
+}
diff --git a/dpdk-20.11/adapter/rte_ethdev_pci_adapter.c b/dpdk-20.11/adapter/rte_ethdev_pci_adapter.c
new file mode 100644
index 0000000..81aa79d
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_ethdev_pci_adapter.c
@@ -0,0 +1,14 @@
+#include "rte_ethdev_pci.h"
+#include "rte_adapter.h"
+
+int rte_eth_dev_pci_generic_probe_stub(struct rte_pci_device *pci_dev,
+    size_t private_data_size, eth_dev_pci_callback_t dev_init)
+{
+    return rte_eth_dev_pci_generic_probe(pci_dev, private_data_size, dev_init);
+}
+
+int rte_eth_dev_pci_generic_remove_stub(struct rte_pci_device *pci_dev,
+    eth_dev_pci_callback_t dev_uninit)
+{
+    return rte_eth_dev_pci_generic_remove(pci_dev, dev_uninit);
+}
diff --git a/dpdk-20.11/adapter/rte_flow_adapter.c b/dpdk-20.11/adapter/rte_flow_adapter.c
new file mode 100644
index 0000000..5678472
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_flow_adapter.c
@@ -0,0 +1,38 @@
+#include "rte_flow.h"
+#include "rte_flow_driver.h"
+#include "rte_adapter.h"
+
+struct rte_flow_ops* rte_flow_ops_allocate(void)
+{
+    return calloc(1, sizeof(struct rte_flow_ops));
+}
+
+void rte_flow_ops_free(struct rte_flow_ops *flow_ops)
+{
+    free(flow_ops);
+}
+
+void rte_flow_ops_set_validate(struct rte_flow_ops *flow_ops, void *arg)
+{
+    flow_ops->validate = arg;
+}
+
+void rte_flow_ops_set_create(struct rte_flow_ops *flow_ops, void *arg)
+{
+    flow_ops->create = arg;
+}
+
+void rte_flow_ops_set_destroy(struct rte_flow_ops *flow_ops, void *arg)
+{
+    flow_ops->destroy = arg;
+}
+
+void rte_flow_ops_set_flush(struct rte_flow_ops *flow_ops, void *arg)
+{
+    flow_ops->flush = arg;
+}
+
+void rte_flow_ops_set_query(struct rte_flow_ops *flow_ops, void *arg)
+{
+    flow_ops->query = arg;
+}
diff --git a/dpdk-20.11/adapter/rte_mbuf_adapter.c b/dpdk-20.11/adapter/rte_mbuf_adapter.c
new file mode 100644
index 0000000..ba356dd
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_mbuf_adapter.c
@@ -0,0 +1,63 @@
+#include "rte_mbuf.h"
+#include "rte_adapter.h"
+
+size_t rte_mbuf_struct_size(void)
+{
+    return sizeof(struct rte_mbuf);
+}
+
+void* rte_mbuf_get_udata64_ptr(struct rte_mbuf *mbuf)
+{
+    return &mbuf->udata64;
+}
+
+void* rte_pktmbuf_get_data(struct rte_mbuf *mbuf)
+{
+    return rte_pktmbuf_mtod(mbuf, void*);
+}
+
+uint32_t rte_pktmbuf_get_data_len(struct rte_mbuf *mbuf)
+{
+    return rte_pktmbuf_data_len(mbuf);
+}
+
+uint32_t rte_pktmbuf_get_pkt_len(struct rte_mbuf *mbuf)
+{
+    return rte_pktmbuf_pkt_len(mbuf);
+}
+
+uint64_t rte_mbuf_get_ol_flags(struct rte_mbuf *mbuf)
+{
+    return mbuf->ol_flags;
+}
+
+uint16_t rte_mbuf_get_vlan_tci(struct rte_mbuf *mbuf)
+{
+    return mbuf->vlan_tci;
+}
+
+uint32_t rte_mbuf_get_hash_rss(struct rte_mbuf *mbuf)
+{
+    return mbuf->hash.rss;
+}
+
+void rte_mbuf_set_ol_flags(struct rte_mbuf *mbuf, uint64_t flag)
+{
+    mbuf->ol_flags = flag;
+}
+
+struct rte_mbuf* rte_pktmbuf_alloc_stub(struct rte_mempool *mp)
+{
+    return rte_pktmbuf_alloc(mp);
+}
+
+int rte_pktmbuf_alloc_bulk_stub(struct rte_mempool *pool,
+    struct rte_mbuf **mbufs, unsigned count)
+{
+    return rte_pktmbuf_alloc_bulk(pool, mbufs, count);
+}
+
+void rte_pktmbuf_free_stub(struct rte_mbuf *m)
+{
+    rte_pktmbuf_free(m);
+}
diff --git a/dpdk-20.11/adapter/rte_mempool_adapter.c b/dpdk-20.11/adapter/rte_mempool_adapter.c
new file mode 100644
index 0000000..2cbbd4d
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_mempool_adapter.c
@@ -0,0 +1,18 @@
+#include "rte_mempool.h"
+#include "rte_adapter.h"
+
+int rte_mempool_get_stub(struct rte_mempool *mp, void **obj_p)
+{
+    return rte_mempool_get(mp, obj_p);
+}
+
+void rte_mempool_put_bulk_stub(struct rte_mempool *mp, void *const *obj_table, 
+    unsigned int n)
+{
+    rte_mempool_put_bulk(mp, obj_table, n);
+}
+
+void rte_mempool_put_stub(struct rte_mempool *mp, void *obj)
+{
+    rte_mempool_put(mp, obj);
+}
diff --git a/dpdk-20.11/adapter/rte_ring_adapter.c b/dpdk-20.11/adapter/rte_ring_adapter.c
new file mode 100644
index 0000000..475430f
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_ring_adapter.c
@@ -0,0 +1,19 @@
+#include "rte_ring.h"
+#include "rte_adapter.h"
+
+unsigned int rte_ring_enqueue_burst_stub(struct rte_ring *r, void *const *obj_table,
+    unsigned int n, unsigned int *free_space)
+{
+    return rte_ring_enqueue_burst(r, obj_table, n, free_space);
+}
+
+unsigned int rte_ring_dequeue_burst_stub(struct rte_ring *r, void **obj_table,
+    unsigned int n, unsigned int *available)
+{
+    return rte_ring_dequeue_burst(r, obj_table, n, available);
+}
+
+unsigned int rte_ring_count_stub(const struct rte_ring *r)
+{
+    return rte_ring_count(r);
+}
diff --git a/dpdk-20.11/adapter/rte_spinlock_adapter.c b/dpdk-20.11/adapter/rte_spinlock_adapter.c
new file mode 100644
index 0000000..dd0dca6
--- /dev/null
+++ b/dpdk-20.11/adapter/rte_spinlock_adapter.c
@@ -0,0 +1,22 @@
+#include "rte_spinlock.h"
+#include "rte_adapter.h"
+
+void rte_spinlock_init_stub(rte_spinlock_t *sl)
+{
+    rte_spinlock_init(sl);
+}
+
+void rte_spinlock_lock_stub(rte_spinlock_t *sl)
+{
+    rte_spinlock_lock(sl);
+}
+
+void rte_spinlock_unlock_stub(rte_spinlock_t *sl)
+{
+    rte_spinlock_unlock(sl);
+}
+
+void rte_spinlock_trylock_stub(rte_spinlock_t *sl)
+{
+    rte_spinlock_trylock(sl);
+}
diff --git a/dpdk-20.11/adapter/version.map b/dpdk-20.11/adapter/version.map
new file mode 100644
index 0000000..76787bc
--- /dev/null
+++ b/dpdk-20.11/adapter/version.map
@@ -0,0 +1,169 @@
+DPDK_22 {
+    global:
+
+    rte_eth_dev_set_device;
+    rte_eth_dev_set_dev_ops;
+    rte_eth_dev_set_rx_pkt_burst;
+    rte_eth_dev_set_tx_pkt_burst;
+    rte_eth_dev_get_device;
+    rte_eth_dev_get_data;
+    rte_eth_dev_get_data_dev_private;
+    rte_eth_dev_get_data_dev_link_ptr;
+    rte_eth_dev_get_pci_device_ptr;
+
+    rte_eth_dev_data_set_rx_queues;
+    rte_eth_dev_data_set_rx_queue_single;
+    rte_eth_dev_data_set_tx_queues;
+    rte_eth_dev_data_set_tx_queue_single;
+    rte_eth_dev_data_set_dev_private;
+    rte_eth_dev_data_set_nb_rx_queues;
+    rte_eth_dev_data_set_nb_tx_queues;
+    rte_eth_dev_data_set_dev_link;
+    rte_eth_dev_data_set_mac_addrs;
+    rte_eth_dev_data_set_numa_node;
+    rte_eth_dev_data_set_mtu;
+    rte_eth_dev_data_set_dev_started;
+    rte_eth_dev_data_get_rx_queue_single;
+    rte_eth_dev_data_get_tx_queue_single;
+    rte_eth_dev_data_get_nb_rx_queues;
+    rte_eth_dev_data_get_nb_tx_queues;
+    rte_eth_dev_data_get_mac_addrs;
+    rte_eth_dev_data_get_numa_node;
+    rte_eth_dev_data_get_name;
+    rte_eth_dev_data_get_dev_private;
+    rte_eth_dev_data_get_dev_link_ptr;
+    rte_eth_dev_data_get_mtu;
+    rte_eth_dev_data_get_dev_started;
+
+    rte_eth_dev_ops_allocate;
+    rte_eth_dev_ops_free;
+    rte_eth_dev_ops_set_dev_configure;
+    rte_eth_dev_ops_set_dev_start;
+    rte_eth_dev_ops_set_dev_stop;
+    rte_eth_dev_ops_set_dev_close;
+    rte_eth_dev_ops_set_dev_set_link_down;
+    rte_eth_dev_ops_set_dev_set_link_up;
+    rte_eth_dev_ops_set_dev_infos_get;
+    rte_eth_dev_ops_set_stats_get;
+    rte_eth_dev_ops_set_stats_reset;
+    rte_eth_dev_ops_set_xstats_get;
+    rte_eth_dev_ops_set_xstats_reset;
+    rte_eth_dev_ops_set_xstats_get_names;
+    rte_eth_dev_ops_set_link_update;
+    rte_eth_dev_ops_set_mtu_set;
+    rte_eth_dev_ops_set_rx_queue_setup;
+    rte_eth_dev_ops_set_tx_queue_setup;
+    rte_eth_dev_ops_set_rx_queue_release;
+    rte_eth_dev_ops_set_tx_queue_release;
+    rte_eth_dev_ops_set_rx_queue_release_dpdk2011;
+    rte_eth_dev_ops_set_tx_queue_release_dpdk2011;
+    rte_eth_dev_ops_set_flow_ops_get;
+    rte_eth_dev_ops_set_extra_config_set;
+    rte_eth_dev_ops_set_filter_ctrl;
+
+    rte_eth_dev_pci_generic_probe_stub;
+    rte_eth_dev_pci_generic_remove_stub;
+
+    rte_atomic16_init_stub;
+    rte_atomic16_read_stub;
+    rte_atomic16_set_stub;
+    rte_atomic16_add_stub;
+    rte_atomic16_sub_stub;
+    rte_atomic16_inc_stub;
+    rte_atomic16_dec_stub;
+
+    rte_atomic32_init_stub;
+    rte_atomic32_read_stub;
+    rte_atomic32_set_stub;
+    rte_atomic32_add_stub;
+    rte_atomic32_sub_stub;
+    rte_atomic32_inc_stub;
+    rte_atomic32_dec_stub;
+
+    rte_pci_bus_get_device_list_ptr;
+    rte_pci_device_list_get_first;
+    rte_pci_driver_allocate;
+    rte_pci_driver_free;
+    rte_pci_driver_set_name;
+    rte_pci_driver_set_id_table;
+    rte_pci_driver_set_drv_flags;
+    rte_pci_driver_set_probe;
+    rte_pci_driver_set_remove;
+
+    rte_pci_device_get_next;
+    rte_pci_device_get_addr_ptr;
+    rte_pci_device_get_id_ptr;
+    rte_pci_device_get_mem_resource;
+    rte_pci_device_get_device_ptr;
+    rte_pci_device_get_name;
+
+    rte_vdev_device_get_device_ptr;
+    rte_vdev_device_name_stub;
+
+    rte_vdev_driver_allocate;
+    rte_vdev_driver_free;
+    rte_vdev_driver_set_probe;
+    rte_vdev_driver_set_remove;
+    rte_vdev_driver_set_name;
+    rte_vdev_driver_set_alias;
+
+    rte_get_tsc_cycles_stub;
+    rte_rdtsc_stub;
+    rte_delay_ms_stub;
+    rte_get_tsc_hz_stub;
+
+    rte_device_get_driver;
+    rte_device_get_devargs;
+    rte_device_get_name;
+    rte_driver_get_name;
+
+    rte_devargs_get_args;
+    
+    rte_eth_dev_info_allocate;
+    rte_eth_dev_info_free;
+    rte_eth_dev_info_set_driver_name;
+    rte_eth_dev_info_set_max_rx_queues;
+    rte_eth_dev_info_set_max_tx_queues;
+    rte_eth_dev_info_set_max_rx_pktlen;
+    rte_eth_dev_info_set_min_mtu;
+    rte_eth_dev_info_set_max_mtu;
+    rte_eth_dev_info_set_if_index;
+    rte_eth_dev_info_get_driver_name;
+    rte_eth_dev_info_get_if_index;
+
+    rte_flow_ops_allocate;
+    rte_flow_ops_free;
+    rte_flow_ops_set_validate;
+    rte_flow_ops_set_create;
+    rte_flow_ops_set_destroy;
+    rte_flow_ops_set_flush;
+    rte_flow_ops_set_query;
+
+    rte_pktmbuf_alloc_stub;
+    rte_pktmbuf_alloc_bulk_stub;
+    rte_pktmbuf_free_stub;
+    rte_mbuf_struct_size;
+    rte_mbuf_get_udata64_ptr;
+    rte_pktmbuf_get_data;
+    rte_pktmbuf_get_pkt_len;
+    rte_pktmbuf_get_data_len;
+    rte_mbuf_get_ol_flags;
+    rte_mbuf_get_vlan_tci;
+    rte_mbuf_get_hash_rss;
+    rte_mbuf_set_ol_flags;
+
+    rte_mempool_get_stub;
+    rte_mempool_put_bulk_stub;
+    rte_mempool_put_stub;
+
+    rte_spinlock_init_stub;
+    rte_spinlock_lock_stub;
+    rte_spinlock_unlock_stub;
+    rte_spinlock_trylock_stub;
+
+    rte_ring_enqueue_burst_stub;
+    rte_ring_dequeue_burst_stub;
+    rte_ring_count_stub;
+
+    local: *;
+};
\ No newline at end of file
diff --git a/dpdk-20.11/drivers/bus/pci/linux/pci.c b/dpdk-20.11/drivers/bus/pci/linux/pci.c
index 2e1808b..d3ee2e5 100644
--- a/dpdk-20.11/drivers/bus/pci/linux/pci.c
+++ b/dpdk-20.11/drivers/bus/pci/linux/pci.c
@@ -212,6 +212,22 @@ error:
 	return -1;
 }
 
+#define HW_VIRTIO_VF_BAR_NUM    3
+#define VIRTIO_PCI_VENDORID    0x1AF4
+#define VIRTIO_PCI_LEGACY_DEVICEID_NET    0x1000
+
+static int pci_get_virtio_device_bar_num(struct rte_pci_device *dev)
+{
+	int num = 0;
+	if (dev->id.vendor_id == VIRTIO_PCI_VENDORID && dev->id.device_id == VIRTIO_PCI_LEGACY_DEVICEID_NET) {
+		for (int i = 0; i < PCI_MAX_RESOURCE; i++) {
+			if (dev->mem_resource[i].len != 0) {
+				num++;
+			}
+		}
+	}
+	return num;
+}
 /* Scan one pci sysfs entry, and fill the devices list from it. */
 static int
 pci_scan_one(const char *dirname, const struct rte_pci_addr *addr)
@@ -331,8 +347,13 @@ pci_scan_one(const char *dirname, const struct rte_pci_addr *addr)
 		else
 			dev->kdrv = RTE_PCI_KDRV_UNKNOWN;
 	} else {
-		dev->kdrv = RTE_PCI_KDRV_NONE;
-		return 0;
+		int num = pci_get_virtio_device_bar_num(dev);
+		if (num == HW_VIRTIO_VF_BAR_NUM) {
+			dev->kdrv = RTE_PCI_KDRV_NONE;
+		} else {
+			free(dev);
+			return 0;
+		}
 	}
 	/* device is valid, add in list (sorted) */
 	if (TAILQ_EMPTY(&rte_pci_bus.device_list)) {
diff --git a/dpdk-20.11/drivers/net/virtio/virtio_ethdev.c b/dpdk-20.11/drivers/net/virtio/virtio_ethdev.c
index 6c233b7..86786a5 100644
--- a/dpdk-20.11/drivers/net/virtio/virtio_ethdev.c
+++ b/dpdk-20.11/drivers/net/virtio/virtio_ethdev.c
@@ -89,6 +89,8 @@ static int virtio_dev_queue_stats_mapping_set(
 static void virtio_notify_peers(struct rte_eth_dev *dev);
 static void virtio_ack_link_announce(struct rte_eth_dev *dev);
 
+#define HUAWEI_VIRTIO_BAR_NUM    3
+
 /*
  * The set of PCI devices this driver supports
  */
@@ -2136,12 +2138,32 @@ exit:
 	return ret;
 }
 
+static int
+device_check_bar_num(struct rte_mem_resource *mem_resource, int len)
+{
+    int num = 0;
+    for (int i = 0; i < len; i++) {
+        if (mem_resource[i].len != 0) {
+            num++;
+        }
+    }
+    if (num == HUAWEI_VIRTIO_BAR_NUM) {
+        return 0;
+    }
+    return -1;
+}
+
 static int eth_virtio_pci_probe(struct rte_pci_driver *pci_drv __rte_unused,
 	struct rte_pci_device *pci_dev)
 {
 	int vdpa = 0;
 	int ret = 0;
 
+	/* virtio pmd skips probe if device is huawei virtio */
+	if (device_check_bar_num(pci_dev->mem_resource, PCI_MAX_RESOURCE) == 0) {
+		return 1;
+	}
+
 	ret = virtio_dev_devargs_parse(pci_dev->device.devargs, &vdpa, NULL,
 		NULL);
 	if (ret < 0) {
diff --git a/dpdk-20.11/lib/librte_eal/common/rte_malloc.c b/dpdk-20.11/lib/librte_eal/common/rte_malloc.c
index 9d39e58..04ebd6b 100644
--- a/dpdk-20.11/lib/librte_eal/common/rte_malloc.c
+++ b/dpdk-20.11/lib/librte_eal/common/rte_malloc.c
@@ -49,6 +49,42 @@ rte_free(void *addr)
 	return mem_free(addr, true);
 }
 
+int rte_free_ex(void *addr)
+{
+    struct malloc_elem *elem = NULL;
+
+    if (!addr) {
+        return -1;
+    }
+
+    elem = malloc_elem_from_data(addr);
+    if (!elem) {
+        return -1;
+    }
+
+    return malloc_heap_free(elem);
+}
+
+void* rte_malloc_socket_ex(const char *type, size_t size, int socket_arg, unsigned int flags, size_t align,
+                           size_t bound, int contig)
+{
+    return malloc_heap_alloc(type, size, socket_arg, flags, align, bound, (bool)contig);
+}
+
+int rte_malloc_elem_from_addr(const void *data, unsigned long long *pg_size, int *socket_id)
+{
+    struct malloc_elem *elem = NULL;
+
+    elem = malloc_elem_from_data(data);
+    if (!elem) {
+        return -1;
+    }
+
+    *socket_id = elem->msl->socket_id;
+    *pg_size = elem->msl->page_sz;
+    return 0;
+}
+
 void
 eal_free_no_trace(void *addr)
 {
diff --git a/dpdk-20.11/lib/librte_eal/include/generic/rte_atomic.h b/dpdk-20.11/lib/librte_eal/include/generic/rte_atomic.h
index 276272f..6c4bbbe 100644
--- a/dpdk-20.11/lib/librte_eal/include/generic/rte_atomic.h
+++ b/dpdk-20.11/lib/librte_eal/include/generic/rte_atomic.h
@@ -186,7 +186,7 @@ rte_atomic16_exchange(volatile uint16_t *dst, uint16_t val)
 /**
  * The atomic counter structure.
  */
-typedef struct {
+typedef struct rte_atomic16{
 	volatile int16_t cnt; /**< An internal counter value. */
 } rte_atomic16_t;
 
@@ -469,7 +469,7 @@ rte_atomic32_exchange(volatile uint32_t *dst, uint32_t val)
 /**
  * The atomic counter structure.
  */
-typedef struct {
+typedef struct rte_atomic32{
 	volatile int32_t cnt; /**< An internal counter value. */
 } rte_atomic32_t;
 
@@ -751,7 +751,7 @@ rte_atomic64_exchange(volatile uint64_t *dst, uint64_t val)
 /**
  * The atomic counter structure.
  */
-typedef struct {
+typedef struct rte_atomic64{
 	volatile int64_t cnt;  /**< Internal counter value. */
 } rte_atomic64_t;
 
diff --git a/dpdk-20.11/lib/librte_eal/include/generic/rte_spinlock.h b/dpdk-20.11/lib/librte_eal/include/generic/rte_spinlock.h
index 87ae7a4..f724f49 100644
--- a/dpdk-20.11/lib/librte_eal/include/generic/rte_spinlock.h
+++ b/dpdk-20.11/lib/librte_eal/include/generic/rte_spinlock.h
@@ -27,7 +27,7 @@
 /**
  * The rte_spinlock_t type.
  */
-typedef struct {
+typedef struct rte_spinlock{
 	volatile int locked; /**< lock status 0 = unlocked, 1 = locked */
 } rte_spinlock_t;
 
diff --git a/dpdk-20.11/lib/librte_eal/include/rte_malloc.h b/dpdk-20.11/lib/librte_eal/include/rte_malloc.h
index 3af64f8..93784f3 100644
--- a/dpdk-20.11/lib/librte_eal/include/rte_malloc.h
+++ b/dpdk-20.11/lib/librte_eal/include/rte_malloc.h
@@ -189,6 +189,13 @@ void *
 rte_malloc_socket(const char *type, size_t size, unsigned align, int socket)
 	__rte_alloc_size(2);
 
+void* rte_malloc_socket_ex(const char *type, size_t size, int socket_arg, unsigned int flags, size_t align,
+    size_t bound, int contig);
+
+int rte_malloc_elem_from_addr(const void *data, unsigned long long *pg_size, int *socket_id);
+
+int rte_free_ex(void *addr);
+
 /**
  * Allocate zero'ed memory from the heap.
  *
diff --git a/dpdk-20.11/lib/librte_eal/version.map b/dpdk-20.11/lib/librte_eal/version.map
index 354c068..18c1a3b 100644
--- a/dpdk-20.11/lib/librte_eal/version.map
+++ b/dpdk-20.11/lib/librte_eal/version.map
@@ -119,6 +119,9 @@ DPDK_21 {
 	rte_malloc_get_socket_stats;
 	rte_malloc_set_limit;
 	rte_malloc_socket;
+	rte_malloc_socket_ex;
+	rte_malloc_elem_from_addr;
+	rte_free_ex;
 	rte_malloc_validate;
 	rte_malloc_virt2iova;
 	rte_mcfg_mem_read_lock;
diff --git a/dpdk-20.11/lib/librte_ethdev/rte_ethdev.c b/dpdk-20.11/lib/librte_ethdev/rte_ethdev.c
index 17ddacc..075c2e4 100644
--- a/dpdk-20.11/lib/librte_ethdev/rte_ethdev.c
+++ b/dpdk-20.11/lib/librte_ethdev/rte_ethdev.c
@@ -1554,6 +1554,14 @@ rollback:
 	return ret;
 }
 
+void *rte_eth_dev_get_private_data(uint16_t port_id)
+{
+    struct rte_eth_dev *dev;
+    RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, NULL);
+    dev = &rte_eth_devices[port_id];
+    return dev->data->dev_private;
+}
+
 void
 rte_eth_dev_internal_reset(struct rte_eth_dev *dev)
 {
@@ -5764,6 +5772,16 @@ rte_eth_hairpin_queue_peer_unbind(uint16_t cur_port, uint16_t cur_queue,
 							  direction);
 }
 
+int
+rte_eth_port_extra_config_set(uint16_t port_id, char* type, char* conf)
+{
+    struct rte_eth_dev *dev;
+    RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
+    dev = &rte_eth_devices[port_id];
+    RTE_FUNC_PTR_OR_ERR_RET(*dev->dev_ops->extra_config_set, -ENOTSUP);
+    return eth_err(port_id, (*dev->dev_ops->extra_config_set)(dev, type, conf));
+}
+
 RTE_LOG_REGISTER(rte_eth_dev_logtype, lib.ethdev, INFO);
 
 RTE_INIT(ethdev_init_telemetry)
diff --git a/dpdk-20.11/lib/librte_ethdev/rte_ethdev.h b/dpdk-20.11/lib/librte_ethdev/rte_ethdev.h
index f5f8919..25fcd1f 100644
--- a/dpdk-20.11/lib/librte_ethdev/rte_ethdev.h
+++ b/dpdk-20.11/lib/librte_ethdev/rte_ethdev.h
@@ -2101,6 +2101,11 @@ const char *rte_eth_dev_tx_offload_name(uint64_t offload);
 int rte_eth_dev_configure(uint16_t port_id, uint16_t nb_rx_queue,
 		uint16_t nb_tx_queue, const struct rte_eth_conf *eth_conf);
 
+/*
+ * Get Ethernet device private data.
+ */
+void *rte_eth_dev_get_private_data(uint16_t port_id);
+
 /**
  * @warning
  * @b EXPERIMENTAL: this API may change without prior notice.
@@ -4741,6 +4746,9 @@ __rte_experimental
 int rte_eth_dev_hairpin_capability_get(uint16_t port_id,
 				       struct rte_eth_hairpin_cap *cap);
 
+__rte_experimental
+int rte_eth_port_extra_config_set(uint16_t port_id, char* type, char* conf);
+
 #include <rte_ethdev_core.h>
 
 /**
diff --git a/dpdk-20.11/lib/librte_ethdev/rte_ethdev_driver.h b/dpdk-20.11/lib/librte_ethdev/rte_ethdev_driver.h
index 0eacfd8..9c48af1 100644
--- a/dpdk-20.11/lib/librte_ethdev/rte_ethdev_driver.h
+++ b/dpdk-20.11/lib/librte_ethdev/rte_ethdev_driver.h
@@ -463,6 +463,14 @@ typedef int (*eth_get_module_info_t)(struct rte_eth_dev *dev,
 
 typedef int (*eth_get_module_eeprom_t)(struct rte_eth_dev *dev,
 				       struct rte_dev_eeprom_info *info);
+
+typedef int (*eth_dev_extra_config_set_t)(struct rte_eth_dev *dev,
+				char* type,
+				char* conf);
+typedef int (*eth_dev_extra_config_get_t)(struct rte_eth_dev *dev,
+				char* type,
+				char* conf);
+
 /**< @internal Retrieve plugin module eeprom data */
 
 /**
@@ -917,6 +925,9 @@ struct eth_dev_ops {
 	/**< Set up the connection between the pair of hairpin queues. */
 	eth_hairpin_queue_peer_unbind_t hairpin_queue_peer_unbind;
 	/**< Disconnect the hairpin queues of a pair from each other. */
+
+	eth_dev_extra_config_set_t extra_config_set;
+	eth_dev_extra_config_get_t extra_config_get;
 };
 
 /**
diff --git a/dpdk-20.11/lib/librte_ethdev/rte_flow.h b/dpdk-20.11/lib/librte_ethdev/rte_flow.h
index 0977a78..045ea39 100644
--- a/dpdk-20.11/lib/librte_ethdev/rte_flow.h
+++ b/dpdk-20.11/lib/librte_ethdev/rte_flow.h
@@ -543,6 +543,105 @@ enum rte_flow_item_type {
 	 * See struct rte_flow_item_ipv6_frag_ext.
 	 */
 	RTE_FLOW_ITEM_TYPE_IPV6_FRAG_EXT,
+
+	/**
+	 * Matches Geneve Variable Length Option
+	 *
+	 * See struct rte_flow_item_geneve_opt
+	 */
+	RTE_FLOW_ITEM_TYPE_GENEVE_OPT,
+
+	/**
+	 * [META]
+	 *
+	 * Matches on packet integrity.
+	 * For some devices application needs to enable integration checks in HW
+	 * before using this item.
+	 *
+	 * @see struct rte_flow_item_integrity.
+	 */
+	RTE_FLOW_ITEM_TYPE_INTEGRITY,
+
+	/**
+	 * [META]
+	 *
+	 * Matches conntrack state.
+	 *
+	 * @see struct rte_flow_item_conntrack.
+	 */
+	RTE_FLOW_ITEM_TYPE_CONNTRACK,
+
+	/**
+	 * [META]
+	 *
+	 * Matches traffic entering the embedded switch from the given ethdev.
+	 *
+	 * @see struct rte_flow_item_ethdev
+	 */
+	RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR,
+
+	/**
+	 * [META]
+	 *
+	 * Matches traffic entering the embedded switch from
+	 * the entity represented by the given ethdev.
+	 *
+	 * @see struct rte_flow_item_ethdev
+	 */
+	RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT,
+
+	/**
+	 * Matches a configured set of fields at runtime calculated offsets
+	 * over the generic network header with variable length and
+	 * flexible pattern
+	 *
+	 * @see struct rte_flow_item_flex.
+	 */
+	RTE_FLOW_ITEM_TYPE_FLEX,
+
+	/**
+	 * Matches L2TPv2 Header.
+	 *
+	 * See struct rte_flow_item_l2tpv2.
+	 */
+	RTE_FLOW_ITEM_TYPE_L2TPV2,
+
+	/**
+	 * Matches PPP Header.
+	 *
+	 * See struct rte_flow_item_ppp.
+	 */
+	RTE_FLOW_ITEM_TYPE_PPP,
+
+	/**
+	 * special type for hiovs offload
+	 * which pmd offload the flow
+	 */
+	RTE_FLOW_ITEM_TYPE_PMD_ID,
+
+	/**
+	 * special type for hiovs offload
+	 * offload packets batch
+	 */
+	RTE_FLOW_ITEM_TYPE_PACKETS,
+
+	/**
+	 * special type for hiovs offload
+	 * ovs flow ufid
+	 */
+	RTE_FLOW_ITEM_TYPE_SW_UFID,
+
+	/**
+	 * special type for hiovs offload
+	 * recircle rte flow
+	 */
+	RTE_FLOW_ITEM_TYPE_FLOW,
+
+	/**
+	 * special type for hiovs offload
+	 * the input port type, hiovs port or no
+	 */
+	RTE_FLOW_ITEM_TYPE_PORT_TYPE,
 };
 
 /**
@@ -2198,6 +2297,71 @@ enum rte_flow_action_type {
 	 * struct rte_flow_shared_action).
 	 */
 	RTE_FLOW_ACTION_TYPE_SHARED,
+
+	/**
+	 * Modify a packet header field, tag, mark or metadata.
+	 *
+	 * Allow the modification of an arbitrary header field via
+	 * set, add and sub operations or copying its content into
+	 * tag, meta or mark for future processing.
+	 *
+	 * See struct rte_flow_action_modify_field.
+	 */
+	RTE_FLOW_ACTION_TYPE_MODIFY_FIELD,
+
+	/**
+	 * An action handle is referenced in a rule through an indirect action.
+	 *
+	 * The same action handle may be used in multiple rules for the same
+	 * or different ethdev ports.
+	 */
+	RTE_FLOW_ACTION_TYPE_INDIRECT,
+
+	/**
+	 * [META]
+	 *
+	 * Enable tracking a TCP connection state.
+	 *
+	 * @see struct rte_flow_action_conntrack.
+	 */
+	RTE_FLOW_ACTION_TYPE_CONNTRACK,
+
+	/**
+	 * Color the packet to reflect the meter color result.
+	 * Set the meter color in the mbuf to the selected color.
+	 *
+	 * See struct rte_flow_action_meter_color.
+	 */
+	RTE_FLOW_ACTION_TYPE_METER_COLOR,
+
+	/**
+	 * At embedded switch level, sends matching traffic to the given ethdev.
+	 *
+	 * @see struct rte_flow_action_ethdev
+	 */
+	RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR,
+
+	/**
+	 * At embedded switch level, send matching traffic to
+	 * the entity represented by the given ethdev.
+	 *
+	 * @see struct rte_flow_action_ethdev
+	 */
+	RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT,
+#ifdef HAVE_HWOFF_AGENT
+	/*
+	 * conntrack action.
+	 *
+	 * See struct .
+	 */
+	RTE_FLOW_ACTION_TYPE_CT,
+	/*
+	 * recirle.
+	 *
+	 * See struct .
+	 */
+	RTE_FLOW_ACTION_TYPE_RECIRC,
+#endif
 };
 
 /**
diff --git a/dpdk-20.11/lib/librte_ethdev/version.map b/dpdk-20.11/lib/librte_ethdev/version.map
index d3f5410..2a272fd 100644
--- a/dpdk-20.11/lib/librte_ethdev/version.map
+++ b/dpdk-20.11/lib/librte_ethdev/version.map
@@ -12,6 +12,7 @@ DPDK_21 {
 	rte_eth_dev_callback_unregister;
 	rte_eth_dev_close;
 	rte_eth_dev_configure;
+	rte_eth_dev_get_private_data;
 	rte_eth_dev_count_avail;
 	rte_eth_dev_count_total;
 	rte_eth_dev_default_mac_addr_set;
@@ -240,6 +241,8 @@ EXPERIMENTAL {
 	rte_flow_get_restore_info;
 	rte_flow_tunnel_action_decap_release;
 	rte_flow_tunnel_item_release;
+
+	rte_eth_port_extra_config_set;
 };
 
 INTERNAL {
diff --git a/dpdk-20.11/lib/librte_kvargs/rte_kvargs.c b/dpdk-20.11/lib/librte_kvargs/rte_kvargs.c
index 285081c..2bd5c71 100644
--- a/dpdk-20.11/lib/librte_kvargs/rte_kvargs.c
+++ b/dpdk-20.11/lib/librte_kvargs/rte_kvargs.c
@@ -160,6 +160,35 @@ rte_kvargs_free(struct rte_kvargs *kvlist)
 	free(kvlist);
 }
 
+/* Lookup a value in an rte_kvargs list by its key and value. */
+const char *
+rte_kvargs_get_with_value(const struct rte_kvargs *kvlist, const char *key,
+			  const char *value)
+{
+	unsigned int i;
+
+	if (kvlist == NULL)
+		return NULL;
+	for (i = 0; i < kvlist->count; ++i) {
+		if (key != NULL && strcmp(kvlist->pairs[i].key, key) != 0)
+			continue;
+		if (value != NULL && strcmp(kvlist->pairs[i].value, value) != 0)
+			continue;
+		return kvlist->pairs[i].value;
+	}
+	return NULL;
+}
+
+/* Lookup a value in an rte_kvargs list by its key. */
+const char *
+rte_kvargs_get(const struct rte_kvargs *kvlist, const char *key)
+{
+	if (kvlist == NULL || key == NULL)
+		return NULL;
+	return rte_kvargs_get_with_value(kvlist, key, NULL);
+}
+
+
 /*
  * Parse the arguments "key=value,key=value,..." string and return
  * an allocated structure that contains a key/value list. Also
diff --git a/dpdk-20.11/lib/librte_kvargs/rte_kvargs.h b/dpdk-20.11/lib/librte_kvargs/rte_kvargs.h
index eff598e..3163f1c 100644
--- a/dpdk-20.11/lib/librte_kvargs/rte_kvargs.h
+++ b/dpdk-20.11/lib/librte_kvargs/rte_kvargs.h
@@ -114,6 +114,53 @@ struct rte_kvargs *rte_kvargs_parse_delim(const char *args,
  */
 void rte_kvargs_free(struct rte_kvargs *kvlist);
 
+
+/**
+ * Get the value associated with a given key.
+ *
+ * If multiple keys match, the value of the first one is returned.
+ *
+ * The memory returned is allocated as part of the rte_kvargs structure,
+ * it must never be modified.
+ *
+ * @param kvlist
+ *   A list of rte_kvargs pair of 'key=value'.
+ * @param key
+ *   The matching key.
+ *
+ * @return
+ *   NULL if no key matches the input,
+ *   a value associated with a matching key otherwise.
+ */
+const char *rte_kvargs_get(const struct rte_kvargs *kvlist, const char *key);
+
+/**
+ * @warning
+ * @b EXPERIMENTAL: this API may change without prior notice
+ *
+ * Get the value associated with a given key and value.
+ *
+ * Find the first entry in the kvlist whose key and value match the
+ * ones passed as argument.
+ *
+ * The memory returned is allocated as part of the rte_kvargs structure,
+ * it must never be modified.
+ *
+ * @param kvlist
+ *   A list of rte_kvargs pair of 'key=value'.
+ * @param key
+ *   The matching key. If NULL, any key will match.
+ * @param value
+ *   The matching value. If NULL, any value will match.
+ *
+ * @return
+ *   NULL if no key matches the input,
+ *   a value associated with a matching key otherwise.
+ */
+__rte_experimental
+const char *rte_kvargs_get_with_value(const struct rte_kvargs *kvlist,
+				      const char *key, const char *value);
+					  
 /**
  * Call a handler function for each key/value matching the key
  *
diff --git a/dpdk-20.11/lib/librte_kvargs/version.map b/dpdk-20.11/lib/librte_kvargs/version.map
index ed375bf..16330d8 100644
--- a/dpdk-20.11/lib/librte_kvargs/version.map
+++ b/dpdk-20.11/lib/librte_kvargs/version.map
@@ -5,6 +5,7 @@ DPDK_21 {
 	rte_kvargs_free;
 	rte_kvargs_parse;
 	rte_kvargs_process;
+	rte_kvargs_get;
 
 	local: *;
 };
@@ -14,5 +15,6 @@ EXPERIMENTAL {
 
 	rte_kvargs_parse_delim;
 	rte_kvargs_strcmp;
+	rte_kvargs_get_with_value;
 
 };
diff --git a/dpdk-20.11/lib/librte_mbuf/rte_mbuf_core.h b/dpdk-20.11/lib/librte_mbuf/rte_mbuf_core.h
index 567551d..82d3a2e 100644
--- a/dpdk-20.11/lib/librte_mbuf/rte_mbuf_core.h
+++ b/dpdk-20.11/lib/librte_mbuf/rte_mbuf_core.h
@@ -643,8 +643,16 @@ struct rte_mbuf {
 
 	/** Timesync flags for use with IEEE1588. */
 	uint16_t timesync;
+	uint32_t dynfield0;
 
-	uint32_t dynfield1[9]; /**< Reserved for dynamic fields. */
+    RTE_STD_C11
+	union {
+		void *userdata;   /**< Can be used for external metadata */
+		uint64_t udata64; /**< Allow 8-byte userdata on 32-bit */
+	};
+
+	uint32_t internal;     /**< internal use mbuf, evs set it to 0 */
+	uint32_t dynfield1[5]; /**< Reserved for dynamic fields. */
 } __rte_cache_aligned;
 
 /**
diff --git a/dpdk-20.11/lib/librte_mbuf/rte_mbuf_dyn.h b/dpdk-20.11/lib/librte_mbuf/rte_mbuf_dyn.h
index d88e7ba..afef7d9 100644
--- a/dpdk-20.11/lib/librte_mbuf/rte_mbuf_dyn.h
+++ b/dpdk-20.11/lib/librte_mbuf/rte_mbuf_dyn.h
@@ -65,8 +65,10 @@
  * - "rte_net_<pmd>_dynfield_<name>" if defined in a PMD
  * - any name that does not start with "rte_" in an application
  */
-
+#include <stdio.h>
+#include <stdint.h>
 #include <sys/types.h>
+#include <rte_compat.h>
 /**
  * Maximum length of the dynamic field or flag string.
  */
diff --git a/dpdk-20.11/meson.build b/dpdk-20.11/meson.build
index 45d974c..1870232 100644
--- a/dpdk-20.11/meson.build
+++ b/dpdk-20.11/meson.build
@@ -48,6 +48,7 @@ subdir('config')
 subdir('buildtools/pmdinfogen')
 subdir('lib')
 subdir('drivers')
+subdir('adapter')
 
 # build binaries and installable tools
 subdir('usertools')
