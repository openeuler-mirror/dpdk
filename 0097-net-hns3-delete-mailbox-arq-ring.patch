From b46465d9deb6c1e0ef26cc53f4050cb7f6322d56 Mon Sep 17 00:00:00 2001
From: Chengwen Feng <fengchengwen@huawei.com>
Date: Tue, 13 Apr 2021 19:50:00 +0800
Subject: [PATCH 097/189] net/hns3: delete mailbox arq ring

Currently, driver will copy mailbox messages body into arq ring when
process HNS3_MBX_LINK_STAT_CHANGE and HNS3_MBX_LINK_STAT_CHANGE
message, and then call hns3_mbx_handler API which will direct process
pre-copy messages. In the whole process, the arq ring don't have a
substantial effect.

Note: The arq ring is designed for kernel environment which could not
do much job in interrupt context, but for DPDK it's not required.

Also we rename hns3_handle_link_change_event to
hns3pf_handle_link_change_event which add 'pf' suffix to make it
better to distinguish.

Fixes: 463e748964f5 ("net/hns3: support mailbox")
Cc: stable@dpdk.org

Signed-off-by: Chengwen Feng <fengchengwen@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_ethdev.h |  1 -
 drivers/net/hns3/hns3_mbx.c    | 83 +++++++++++++++++-------------------------
 drivers/net/hns3/hns3_mbx.h    | 14 -------
 3 files changed, 33 insertions(+), 65 deletions(-)

diff --git a/drivers/net/hns3/hns3_ethdev.h b/drivers/net/hns3/hns3_ethdev.h
index 47d998d..1763cc9 100644
--- a/drivers/net/hns3/hns3_ethdev.h
+++ b/drivers/net/hns3/hns3_ethdev.h
@@ -438,7 +438,6 @@ struct hns3_hw {
 	uint8_t revision;           /* PCI revision, low byte of class word */
 	struct hns3_cmq cmq;
 	struct hns3_mbx_resp_status mbx_resp; /* mailbox response */
-	struct hns3_mbx_arq_ring arq;         /* mailbox async rx queue */
 	struct hns3_mac mac;
 	unsigned int secondary_cnt; /* Number of secondary processes init'd. */
 	struct hns3_tqp_stats tqp_stats;
diff --git a/drivers/net/hns3/hns3_mbx.c b/drivers/net/hns3/hns3_mbx.c
index 2a96f6c..6768207 100644
--- a/drivers/net/hns3/hns3_mbx.c
+++ b/drivers/net/hns3/hns3_mbx.c
@@ -173,55 +173,42 @@ hns3_cmd_crq_empty(struct hns3_hw *hw)
 }
 
 static void
-hns3_mbx_handler(struct hns3_hw *hw)
+hns3vf_handle_link_change_event(struct hns3_hw *hw,
+				struct hns3_mbx_pf_to_vf_cmd *req)
 {
-	enum hns3_reset_level reset_level;
 	uint8_t link_status, link_duplex;
+	uint16_t *msg_q = req->msg;
 	uint8_t support_push_lsc;
 	uint32_t link_speed;
-	uint16_t *msg_q;
-	uint8_t opcode;
-	uint32_t tail;
 
-	tail = hw->arq.tail;
-
-	/* process all the async queue messages */
-	while (tail != hw->arq.head) {
-		msg_q = hw->arq.msg_q[hw->arq.head];
+	memcpy(&link_speed, &msg_q[2], sizeof(link_speed));
+	link_status = rte_le_to_cpu_16(msg_q[1]);
+	link_duplex = (uint8_t)rte_le_to_cpu_16(msg_q[4]);
+	hns3vf_update_link_status(hw, link_status, link_speed,
+				  link_duplex);
+	support_push_lsc = (*(uint8_t *)&msg_q[5]) & 1u;
+	hns3vf_update_push_lsc_cap(hw, support_push_lsc);
+}
 
-		opcode = msg_q[0] & 0xff;
-		switch (opcode) {
-		case HNS3_MBX_LINK_STAT_CHANGE:
-			memcpy(&link_speed, &msg_q[2], sizeof(link_speed));
-			link_status = rte_le_to_cpu_16(msg_q[1]);
-			link_duplex = (uint8_t)rte_le_to_cpu_16(msg_q[4]);
-			hns3vf_update_link_status(hw, link_status, link_speed,
-						  link_duplex);
-			support_push_lsc = (*(uint8_t *)&msg_q[5]) & 1u;
-			hns3vf_update_push_lsc_cap(hw, support_push_lsc);
-			break;
-		case HNS3_MBX_ASSERTING_RESET:
-			/* PF has asserted reset hence VF should go in pending
-			 * state and poll for the hardware reset status till it
-			 * has been completely reset. After this stack should
-			 * eventually be re-initialized.
-			 */
-			reset_level = rte_le_to_cpu_16(msg_q[1]);
-			hns3_atomic_set_bit(reset_level, &hw->reset.pending);
+static void
+hns3_handle_asserting_reset(struct hns3_hw *hw,
+			    struct hns3_mbx_pf_to_vf_cmd *req)
+{
+	enum hns3_reset_level reset_level;
+	uint16_t *msg_q = req->msg;
 
-			hns3_warn(hw, "PF inform reset level %d", reset_level);
-			hw->reset.stats.request_cnt++;
-			hns3_schedule_reset(HNS3_DEV_HW_TO_ADAPTER(hw));
-			break;
-		default:
-			hns3_err(hw, "Fetched unsupported(%u) message from arq",
-				 opcode);
-			break;
-		}
+	/*
+	 * PF has asserted reset hence VF should go in pending
+	 * state and poll for the hardware reset status till it
+	 * has been completely reset. After this stack should
+	 * eventually be re-initialized.
+	 */
+	reset_level = rte_le_to_cpu_16(msg_q[1]);
+	hns3_atomic_set_bit(reset_level, &hw->reset.pending);
 
-		hns3_mbx_head_ptr_move_arq(hw->arq);
-		msg_q = hw->arq.msg_q[hw->arq.head];
-	}
+	hns3_warn(hw, "PF inform reset level %d", reset_level);
+	hw->reset.stats.request_cnt++;
+	hns3_schedule_reset(HNS3_DEV_HW_TO_ADAPTER(hw));
 }
 
 /*
@@ -278,7 +265,7 @@ hns3_link_fail_parse(struct hns3_hw *hw, uint8_t link_fail_code)
 }
 
 static void
-hns3_handle_link_change_event(struct hns3_hw *hw,
+hns3pf_handle_link_change_event(struct hns3_hw *hw,
 			      struct hns3_mbx_pf_to_vf_cmd *req)
 {
 #define LINK_STATUS_OFFSET     1
@@ -337,7 +324,6 @@ hns3_dev_handle_mbx_msg(struct hns3_hw *hw)
 	struct hns3_mbx_pf_to_vf_cmd *req;
 	struct hns3_cmd_desc *desc;
 	uint32_t msg_data;
-	uint16_t *msg_q;
 	uint8_t opcode;
 	uint16_t flag;
 	uint8_t *temp;
@@ -380,16 +366,13 @@ hns3_dev_handle_mbx_msg(struct hns3_hw *hw)
 			hns3_update_resp_position(hw, msg_data);
 			break;
 		case HNS3_MBX_LINK_STAT_CHANGE:
+			hns3vf_handle_link_change_event(hw, req);
+			break;
 		case HNS3_MBX_ASSERTING_RESET:
-			msg_q = hw->arq.msg_q[hw->arq.tail];
-			memcpy(&msg_q[0], req->msg,
-			       HNS3_MBX_MAX_ARQ_MSG_SIZE * sizeof(uint16_t));
-			hns3_mbx_tail_ptr_move_arq(hw->arq);
-
-			hns3_mbx_handler(hw);
+			hns3_handle_asserting_reset(hw, req);
 			break;
 		case HNS3_MBX_PUSH_LINK_STATUS:
-			hns3_handle_link_change_event(hw, req);
+			hns3pf_handle_link_change_event(hw, req);
 			break;
 		case HNS3_MBX_PUSH_VLAN_INFO:
 			/*
diff --git a/drivers/net/hns3/hns3_mbx.h b/drivers/net/hns3/hns3_mbx.h
index 7f7ade1..adb77b5 100644
--- a/drivers/net/hns3/hns3_mbx.h
+++ b/drivers/net/hns3/hns3_mbx.h
@@ -144,22 +144,8 @@ struct hns3_pf_rst_done_cmd {
 
 #define HNS3_PF_RESET_DONE_BIT		BIT(0)
 
-/* used by VF to store the received Async responses from PF */
-struct hns3_mbx_arq_ring {
-#define HNS3_MBX_MAX_ARQ_MSG_SIZE	8
-#define HNS3_MBX_MAX_ARQ_MSG_NUM	1024
-	uint32_t head;
-	uint32_t tail;
-	uint32_t count;
-	uint16_t msg_q[HNS3_MBX_MAX_ARQ_MSG_NUM][HNS3_MBX_MAX_ARQ_MSG_SIZE];
-};
-
 #define hns3_mbx_ring_ptr_move_crq(crq) \
 	((crq)->next_to_use = ((crq)->next_to_use + 1) % (crq)->desc_num)
-#define hns3_mbx_tail_ptr_move_arq(arq) \
-	((arq).tail = ((arq).tail + 1) % HNS3_MBX_MAX_ARQ_MSG_SIZE)
-#define hns3_mbx_head_ptr_move_arq(arq) \
-		((arq).head = ((arq).head + 1) % HNS3_MBX_MAX_ARQ_MSG_SIZE)
 
 struct hns3_hw;
 void hns3_dev_handle_mbx_msg(struct hns3_hw *hw);
-- 
2.7.4

