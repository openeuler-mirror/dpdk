From 89b2b315c94308c77bdd662fa564c9d4a43bd647 Mon Sep 17 00:00:00 2001
From: Chengwen Feng <fengchengwen@huawei.com>
Date: Fri, 30 Apr 2021 14:28:47 +0800
Subject: [PATCH 148/189] net/hns3: use existing macro to get array size

This patch uses RTE_DIM() instead of ARRAY_SIZE().

Signed-off-by: Chengwen Feng <fengchengwen@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_cmd.c    |  4 ++--
 drivers/net/hns3/hns3_ethdev.h |  2 --
 drivers/net/hns3/hns3_flow.c   | 18 +++++++++---------
 drivers/net/hns3/hns3_intr.c   |  4 ++--
 4 files changed, 13 insertions(+), 15 deletions(-)

diff --git a/drivers/net/hns3/hns3_cmd.c b/drivers/net/hns3/hns3_cmd.c
index a43385b..5f4d74d 100644
--- a/drivers/net/hns3/hns3_cmd.c
+++ b/drivers/net/hns3/hns3_cmd.c
@@ -245,7 +245,7 @@ hns3_is_special_opcode(uint16_t opcode)
 				  HNS3_OPC_QUERY_ALL_ERR_INFO,};
 	uint32_t i;
 
-	for (i = 0; i < ARRAY_SIZE(spec_opcode); i++)
+	for (i = 0; i < RTE_DIM(spec_opcode); i++)
 		if (spec_opcode[i] == opcode)
 			return true;
 
@@ -276,7 +276,7 @@ hns3_cmd_convert_err_code(uint16_t desc_ret)
 
 	uint32_t i;
 
-	for (i = 0; i < ARRAY_SIZE(hns3_cmdq_status); i++)
+	for (i = 0; i < RTE_DIM(hns3_cmdq_status); i++)
 		if (hns3_cmdq_status[i].imp_errcode == desc_ret)
 			return hns3_cmdq_status[i].linux_errcode;
 
diff --git a/drivers/net/hns3/hns3_ethdev.h b/drivers/net/hns3/hns3_ethdev.h
index 091512e..00fedf0 100644
--- a/drivers/net/hns3/hns3_ethdev.h
+++ b/drivers/net/hns3/hns3_ethdev.h
@@ -1001,8 +1001,6 @@ static inline uint32_t hns3_read_reg(void *base, uint32_t reg)
 #define hns3_read_dev(a, reg) \
 	hns3_read_reg((a)->io_base, (reg))
 
-#define ARRAY_SIZE(x) RTE_DIM(x)
-
 #define NEXT_ITEM_OF_ACTION(act, actions, index)                        \
 	do {								\
 		act = (actions) + (index);				\
diff --git a/drivers/net/hns3/hns3_flow.c b/drivers/net/hns3/hns3_flow.c
index c07929f..1513992 100644
--- a/drivers/net/hns3/hns3_flow.c
+++ b/drivers/net/hns3/hns3_flow.c
@@ -1054,37 +1054,37 @@ hns3_parse_normal(const struct rte_flow_item *item, struct hns3_fdir_rule *rule,
 	case RTE_FLOW_ITEM_TYPE_ETH:
 		ret = hns3_parse_eth(item, rule, error);
 		step_mngr->items = L2_next_items;
-		step_mngr->count = ARRAY_SIZE(L2_next_items);
+		step_mngr->count = RTE_DIM(L2_next_items);
 		break;
 	case RTE_FLOW_ITEM_TYPE_VLAN:
 		ret = hns3_parse_vlan(item, rule, error);
 		step_mngr->items = L2_next_items;
-		step_mngr->count = ARRAY_SIZE(L2_next_items);
+		step_mngr->count = RTE_DIM(L2_next_items);
 		break;
 	case RTE_FLOW_ITEM_TYPE_IPV4:
 		ret = hns3_parse_ipv4(item, rule, error);
 		step_mngr->items = L3_next_items;
-		step_mngr->count = ARRAY_SIZE(L3_next_items);
+		step_mngr->count = RTE_DIM(L3_next_items);
 		break;
 	case RTE_FLOW_ITEM_TYPE_IPV6:
 		ret = hns3_parse_ipv6(item, rule, error);
 		step_mngr->items = L3_next_items;
-		step_mngr->count = ARRAY_SIZE(L3_next_items);
+		step_mngr->count = RTE_DIM(L3_next_items);
 		break;
 	case RTE_FLOW_ITEM_TYPE_TCP:
 		ret = hns3_parse_tcp(item, rule, error);
 		step_mngr->items = L4_next_items;
-		step_mngr->count = ARRAY_SIZE(L4_next_items);
+		step_mngr->count = RTE_DIM(L4_next_items);
 		break;
 	case RTE_FLOW_ITEM_TYPE_UDP:
 		ret = hns3_parse_udp(item, rule, error);
 		step_mngr->items = L4_next_items;
-		step_mngr->count = ARRAY_SIZE(L4_next_items);
+		step_mngr->count = RTE_DIM(L4_next_items);
 		break;
 	case RTE_FLOW_ITEM_TYPE_SCTP:
 		ret = hns3_parse_sctp(item, rule, error);
 		step_mngr->items = L4_next_items;
-		step_mngr->count = ARRAY_SIZE(L4_next_items);
+		step_mngr->count = RTE_DIM(L4_next_items);
 		break;
 	default:
 		return rte_flow_error_set(error, ENOTSUP,
@@ -1188,7 +1188,7 @@ hns3_parse_fdir_filter(struct rte_eth_dev *dev,
 					  "Fdir not supported in VF");
 
 	step_mngr.items = first_items;
-	step_mngr.count = ARRAY_SIZE(first_items);
+	step_mngr.count = RTE_DIM(first_items);
 	for (item = pattern; item->type != RTE_FLOW_ITEM_TYPE_END; item++) {
 		if (item->type == RTE_FLOW_ITEM_TYPE_VOID)
 			continue;
@@ -1202,7 +1202,7 @@ hns3_parse_fdir_filter(struct rte_eth_dev *dev,
 			if (ret)
 				return ret;
 			step_mngr.items = tunnel_next_items;
-			step_mngr.count = ARRAY_SIZE(tunnel_next_items);
+			step_mngr.count = RTE_DIM(tunnel_next_items);
 		} else {
 			ret = hns3_parse_normal(item, rule, &step_mngr, error);
 			if (ret)
diff --git a/drivers/net/hns3/hns3_intr.c b/drivers/net/hns3/hns3_intr.c
index 482541b..e216788 100644
--- a/drivers/net/hns3/hns3_intr.c
+++ b/drivers/net/hns3/hns3_intr.c
@@ -2206,8 +2206,8 @@ hns3_handle_type_reg_error_data(struct hns3_hw *hw,
 	type_id = err_info->type_id & HNS3_ERR_TYPE_MASK;
 	is_ras = err_info->type_id >> HNS3_ERR_TYPE_IS_RAS_OFFSET;
 
-	total_module = ARRAY_SIZE(hns3_hw_module_name);
-	total_type = ARRAY_SIZE(hns3_hw_error_type);
+	total_module = RTE_DIM(hns3_hw_module_name);
+	total_type = RTE_DIM(hns3_hw_error_type);
 
 	hns3_err(hw, "total_module:%u, total_type:%u",
 		 total_module, total_type);
-- 
2.7.4

