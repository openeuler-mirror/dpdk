From 15c150affb3d486df5e7a4ab55e3ed1cdf8504ef Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Mon, 26 Jul 2021 18:59:39 +0800
Subject: [PATCH] net/hns3: add start/stop Tx datapath request for MP

Currently, hns3 PMD has supported start/stop RxTx datapath request message
between the primary and secondary processes. However, there are some cases
only to start/stop Tx datapath. This patch adds start/stop Tx datapath
request for MP.

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_ethdev.h |  4 +++-
 drivers/net/hns3/hns3_mp.c     | 50 ++++++++++++++++++++++++++++++++++--------
 drivers/net/hns3/hns3_mp.h     |  3 +++
 drivers/net/hns3/hns3_rxtx.c   |  4 ++--
 drivers/net/hns3/hns3_rxtx.h   |  6 +++++
 5 files changed, 55 insertions(+), 12 deletions(-)

diff --git a/drivers/net/hns3/hns3_ethdev.h b/drivers/net/hns3/hns3_ethdev.h
index 8e66d9f..2e48ff6 100644
--- a/drivers/net/hns3/hns3_ethdev.h
+++ b/drivers/net/hns3/hns3_ethdev.h
@@ -699,7 +699,9 @@ struct hns3_vtag_cfg {
 /* Request types for IPC. */
 enum hns3_mp_req_type {
 	HNS3_MP_REQ_START_RXTX = 1,
-	HNS3_MP_REQ_STOP_RXTX,
+	HNS3_MP_REQ_STOP_RXTX  = 2,
+	HNS3_MP_REQ_START_TX   = 3,
+	HNS3_MP_REQ_STOP_TX    = 4,
 	HNS3_MP_REQ_MAX
 };
 
diff --git a/drivers/net/hns3/hns3_mp.c b/drivers/net/hns3/hns3_mp.c
index a8485f5..cd514ac 100644
--- a/drivers/net/hns3/hns3_mp.c
+++ b/drivers/net/hns3/hns3_mp.c
@@ -73,6 +73,7 @@ mp_secondary_handle(const struct rte_mp_msg *mp_msg, const void *peer)
 	struct hns3_mp_param *res = (struct hns3_mp_param *)mp_res.param;
 	const struct hns3_mp_param *param =
 		(const struct hns3_mp_param *)mp_msg->param;
+	eth_tx_prep_t prep = NULL;
 	struct rte_eth_dev *dev;
 	int ret;
 
@@ -87,19 +88,23 @@ mp_secondary_handle(const struct rte_mp_msg *mp_msg, const void *peer)
 		PMD_INIT_LOG(INFO, "port %u starting datapath",
 			     dev->data->port_id);
 		hns3_set_rxtx_function(dev);
-		rte_mb();
-		mp_init_msg(dev, &mp_res, param->type);
-		res->result = 0;
-		ret = rte_mp_reply(&mp_res, peer);
 		break;
 	case HNS3_MP_REQ_STOP_RXTX:
 		PMD_INIT_LOG(INFO, "port %u stopping datapath",
 			     dev->data->port_id);
 		hns3_set_rxtx_function(dev);
-		rte_mb();
-		mp_init_msg(dev, &mp_res, param->type);
-		res->result = 0;
-		ret = rte_mp_reply(&mp_res, peer);
+		break;
+	case HNS3_MP_REQ_START_TX:
+		PMD_INIT_LOG(INFO, "port %u starting Tx datapath",
+			     dev->data->port_id);
+		dev->tx_pkt_burst = hns3_get_tx_function(dev, &prep);
+		dev->tx_pkt_prepare = prep;
+		break;
+	case HNS3_MP_REQ_STOP_TX:
+		PMD_INIT_LOG(INFO, "port %u stopping Tx datapath",
+			     dev->data->port_id);
+		dev->tx_pkt_burst = hns3_dummy_rxtx_burst;
+		dev->tx_pkt_prepare = NULL;
 		break;
 	default:
 		rte_errno = EINVAL;
@@ -107,9 +112,24 @@ mp_secondary_handle(const struct rte_mp_msg *mp_msg, const void *peer)
 			     dev->data->port_id);
 		return -rte_errno;
 	}
+
+	rte_mb();
+	mp_init_msg(dev, &mp_res, param->type);
+	res->result = 0;
+	ret = rte_mp_reply(&mp_res, peer);
+
 	return ret;
 }
 
+static bool
+mp_req_type_is_valid(enum hns3_mp_req_type type)
+{
+	return type == HNS3_MP_REQ_START_RXTX ||
+		type == HNS3_MP_REQ_STOP_RXTX ||
+		type == HNS3_MP_REQ_START_TX ||
+		type == HNS3_MP_REQ_STOP_TX;
+}
+
 /*
  * Broadcast request of stopping/starting data-path to secondary processes.
  *
@@ -132,7 +152,7 @@ mp_req_on_rxtx(struct rte_eth_dev *dev, enum hns3_mp_req_type type)
 
 	if (rte_eal_process_type() == RTE_PROC_SECONDARY || !hw->secondary_cnt)
 		return;
-	if (type != HNS3_MP_REQ_START_RXTX && type != HNS3_MP_REQ_STOP_RXTX) {
+	if (!mp_req_type_is_valid(type)) {
 		hns3_err(hw, "port %u unknown request (req_type %d)",
 			 dev->data->port_id, type);
 		return;
@@ -189,6 +209,18 @@ void hns3_mp_req_stop_rxtx(struct rte_eth_dev *dev)
 	mp_req_on_rxtx(dev, HNS3_MP_REQ_STOP_RXTX);
 }
 
+void
+hns3_mp_req_stop_tx(struct rte_eth_dev *dev)
+{
+	mp_req_on_rxtx(dev, HNS3_MP_REQ_STOP_TX);
+}
+
+void
+hns3_mp_req_start_tx(struct rte_eth_dev *dev)
+{
+	mp_req_on_rxtx(dev, HNS3_MP_REQ_START_TX);
+}
+
 /*
  * Initialize by primary process.
  */
diff --git a/drivers/net/hns3/hns3_mp.h b/drivers/net/hns3/hns3_mp.h
index 1a73598..e0e4aea 100644
--- a/drivers/net/hns3/hns3_mp.h
+++ b/drivers/net/hns3/hns3_mp.h
@@ -7,6 +7,9 @@
 
 void hns3_mp_req_start_rxtx(struct rte_eth_dev *dev);
 void hns3_mp_req_stop_rxtx(struct rte_eth_dev *dev);
+void hns3_mp_req_start_tx(struct rte_eth_dev *dev);
+void hns3_mp_req_stop_tx(struct rte_eth_dev *dev);
+
 int hns3_mp_init_primary(void);
 void hns3_mp_uninit_primary(void);
 int hns3_mp_init_secondary(void);
diff --git a/drivers/net/hns3/hns3_rxtx.c b/drivers/net/hns3/hns3_rxtx.c
index d3fbe08..7d8176f 100644
--- a/drivers/net/hns3/hns3_rxtx.c
+++ b/drivers/net/hns3/hns3_rxtx.c
@@ -4309,7 +4309,7 @@ hns3_get_tx_prep_needed(struct rte_eth_dev *dev)
 #endif
 }
 
-static eth_tx_burst_t
+eth_tx_burst_t
 hns3_get_tx_function(struct rte_eth_dev *dev, eth_tx_prep_t *prep)
 {
 	struct hns3_adapter *hns = dev->data->dev_private;
@@ -4346,7 +4346,7 @@ hns3_get_tx_function(struct rte_eth_dev *dev, eth_tx_prep_t *prep)
 	return hns3_xmit_pkts;
 }
 
-static uint16_t
+uint16_t
 hns3_dummy_rxtx_burst(void *dpdk_txq __rte_unused,
 		      struct rte_mbuf **pkts __rte_unused,
 		      uint16_t pkts_n __rte_unused)
diff --git a/drivers/net/hns3/hns3_rxtx.h b/drivers/net/hns3/hns3_rxtx.h
index 56c1b80..141de7a 100644
--- a/drivers/net/hns3/hns3_rxtx.h
+++ b/drivers/net/hns3/hns3_rxtx.h
@@ -729,6 +729,12 @@ int hns3_tx_burst_mode_get(struct rte_eth_dev *dev,
 const uint32_t *hns3_dev_supported_ptypes_get(struct rte_eth_dev *dev);
 void hns3_init_rx_ptype_tble(struct rte_eth_dev *dev);
 void hns3_set_rxtx_function(struct rte_eth_dev *eth_dev);
+eth_tx_burst_t hns3_get_tx_function(struct rte_eth_dev *dev,
+				    eth_tx_prep_t *prep);
+uint16_t hns3_dummy_rxtx_burst(void *dpdk_txq __rte_unused,
+			       struct rte_mbuf **pkts __rte_unused,
+			       uint16_t pkts_n __rte_unused);
+
 uint32_t hns3_get_tqp_intr_reg_offset(uint16_t tqp_intr_id);
 void hns3_set_queue_intr_gl(struct hns3_hw *hw, uint16_t queue_id,
 			    uint8_t gl_idx, uint16_t gl_value);
-- 
2.7.4

