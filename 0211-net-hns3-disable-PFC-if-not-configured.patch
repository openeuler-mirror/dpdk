From adcff6f726ed3345c9d4ad0182de22d2e57459d8 Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Sat, 17 Jul 2021 09:04:19 +0800
Subject: [PATCH 25/26] net/hns3: disable PFC if not configured

If "dcb_capability_en" in "data->dev_conf" delivered from the dev_configure
does not have the ETH_DCB_PFC_SUPPORT flag, the user wants to disable PFC,
and only enable ETS. Therefore, this patch supports the function of
disabling PFC by the field. In addition, this patch updates
"current_fc_status" of the driver based on the flow control mode requested
by user so as to enable the flow control mode in multi-TC scenarios.

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_dcb.c | 112 ++++++++++++++++++--------------------------
 1 file changed, 45 insertions(+), 67 deletions(-)

diff --git a/drivers/net/hns3/hns3_dcb.c b/drivers/net/hns3/hns3_dcb.c
index 61a2404..4d5b00b 100644
--- a/drivers/net/hns3/hns3_dcb.c
+++ b/drivers/net/hns3/hns3_dcb.c
@@ -1400,42 +1400,22 @@ hns3_dcb_undrop_tc_map(struct hns3_hw *hw, uint8_t pfc_en)
 	return pfc_map;
 }
 
-static void
-hns3_dcb_cfg_validate(struct hns3_adapter *hns, uint8_t *tc, bool *changed)
+static uint8_t
+hns3_dcb_parse_num_tc(struct hns3_adapter *hns)
 {
 	struct rte_eth_dcb_rx_conf *dcb_rx_conf;
 	struct hns3_hw *hw = &hns->hw;
-	uint16_t nb_rx_q = hw->data->nb_rx_queues;
-	uint16_t nb_tx_q = hw->data->nb_tx_queues;
-	uint8_t max_tc = 0;
-	uint8_t pfc_en;
+	uint8_t max_tc_id = 0;
 	int i;
 
 	dcb_rx_conf = &hw->data->dev_conf.rx_adv_conf.dcb_rx_conf;
 	for (i = 0; i < HNS3_MAX_USER_PRIO; i++) {
-		if (dcb_rx_conf->dcb_tc[i] != hw->dcb_info.prio_tc[i])
-			*changed = true;
-
-		if (dcb_rx_conf->dcb_tc[i] > max_tc)
-			max_tc = dcb_rx_conf->dcb_tc[i];
+		if (dcb_rx_conf->dcb_tc[i] > max_tc_id)
+			max_tc_id = dcb_rx_conf->dcb_tc[i];
 	}
-	*tc = max_tc + 1;
-	if (*tc != hw->dcb_info.num_tc)
-		*changed = true;
-
-	/*
-	 * We ensure that dcb information can be reconfigured
-	 * after the hns3_priority_flow_ctrl_set function called.
-	 */
-	if (hw->requested_fc_mode != HNS3_FC_FULL)
-		*changed = true;
-	pfc_en = RTE_LEN2MASK((uint8_t)dcb_rx_conf->nb_tcs, uint8_t);
-	if (hw->dcb_info.pfc_en != pfc_en)
-		*changed = true;
 
-	/* tx/rx queue number is reconfigured. */
-	if (nb_rx_q != hw->used_rx_queues || nb_tx_q != hw->used_tx_queues)
-		*changed = true;
+	/* Number of TC is equal to max_tc_id plus 1. */
+	return max_tc_id + 1;
 }
 
 static int
@@ -1567,36 +1547,30 @@ hns3_dcb_hw_configure(struct hns3_adapter *hns)
 		hw->dcb_info.hw_pfc_map =
 				hns3_dcb_undrop_tc_map(hw, hw->dcb_info.pfc_en);
 
-		ret = hns3_buffer_alloc(hw);
-		if (ret)
-			goto buffer_alloc_fail;
-
 		hw->current_fc_status = HNS3_FC_STATUS_PFC;
 		hw->requested_fc_mode = HNS3_FC_FULL;
-		ret = hns3_dcb_pause_setup_hw(hw);
-		if (ret) {
-			hns3_err(hw, "setup pfc failed! ret = %d", ret);
-			goto pfc_setup_fail;
-		}
 	} else {
-		/*
-		 * Although dcb_capability_en is lack of ETH_DCB_PFC_SUPPORT
-		 * flag, the DCB information is configured, such as tc numbers.
-		 * Therefore, refreshing the allocation of packet buffer is
-		 * necessary.
-		 */
-		ret = hns3_buffer_alloc(hw);
-		if (ret)
-			return ret;
+		hw->current_fc_status = HNS3_FC_STATUS_NONE;
+		hw->requested_fc_mode = HNS3_FC_NONE;
+		hw->dcb_info.pfc_en = 0;
+		hw->dcb_info.hw_pfc_map = 0;
+	}
+
+	ret = hns3_buffer_alloc(hw);
+	if (ret)
+		goto cfg_fail;
+
+	ret = hns3_dcb_pause_setup_hw(hw);
+	if (ret) {
+		hns3_err(hw, "setup pfc failed! ret = %d", ret);
+		goto cfg_fail;
 	}
 
 	return 0;
 
-pfc_setup_fail:
+cfg_fail:
 	hw->requested_fc_mode = requested_fc_mode;
 	hw->current_fc_status = fc_status;
-
-buffer_alloc_fail:
 	hw->dcb_info.pfc_en = pfc_en;
 	hw->dcb_info.hw_pfc_map = hw_pfc_map;
 
@@ -1612,23 +1586,20 @@ int
 hns3_dcb_configure(struct hns3_adapter *hns)
 {
 	struct hns3_hw *hw = &hns->hw;
-	bool map_changed = false;
-	uint8_t num_tc = 0;
+	uint8_t num_tc;
 	int ret;
 
-	hns3_dcb_cfg_validate(hns, &num_tc, &map_changed);
-	if (map_changed) {
-		ret = hns3_dcb_info_update(hns, num_tc);
-		if (ret) {
-			hns3_err(hw, "dcb info update failed: %d", ret);
-			return ret;
-		}
+	num_tc = hns3_dcb_parse_num_tc(hns);
+	ret = hns3_dcb_info_update(hns, num_tc);
+	if (ret) {
+		hns3_err(hw, "dcb info update failed: %d", ret);
+		return ret;
+	}
 
-		ret = hns3_dcb_hw_configure(hns);
-		if (ret) {
-			hns3_err(hw, "dcb sw configure failed: %d", ret);
-			return ret;
-		}
+	ret = hns3_dcb_hw_configure(hns);
+	if (ret) {
+		hns3_err(hw, "dcb sw configure failed: %d", ret);
+		return ret;
 	}
 
 	return 0;
@@ -1781,15 +1752,21 @@ hns3_dcb_pfc_enable(struct rte_eth_dev *dev, struct rte_eth_pfc_conf *pfc_conf)
 	uint16_t pause_time = pf->pause_time;
 	int ret;
 
-	pf->pause_time = pfc_conf->fc.pause_time;
-	hns3_get_fc_mode(hw, pfc_conf->fc.mode);
-	hw->current_fc_status = HNS3_FC_STATUS_PFC;
 	hw->dcb_info.pfc_en |= BIT(priority);
 	hw->dcb_info.hw_pfc_map =
 			hns3_dcb_undrop_tc_map(hw, hw->dcb_info.pfc_en);
 	ret = hns3_buffer_alloc(hw);
-	if (ret)
-		goto pfc_setup_fail;
+	if (ret) {
+		hns3_err(hw, "update packet buffer failed, ret = %d", ret);
+		goto buffer_alloc_fail;
+	}
+
+	pf->pause_time = pfc_conf->fc.pause_time;
+	hns3_get_fc_mode(hw, pfc_conf->fc.mode);
+	if (hw->requested_fc_mode == HNS3_FC_NONE)
+		hw->current_fc_status = HNS3_FC_STATUS_NONE;
+	else
+		hw->current_fc_status = HNS3_FC_STATUS_PFC;
 
 	/*
 	 * The flow control mode of all UPs will be changed based on
@@ -1807,6 +1784,7 @@ hns3_dcb_pfc_enable(struct rte_eth_dev *dev, struct rte_eth_pfc_conf *pfc_conf)
 	hw->requested_fc_mode = old_fc_mode;
 	hw->current_fc_status = fc_status;
 	pf->pause_time = pause_time;
+buffer_alloc_fail:
 	hw->dcb_info.pfc_en = pfc_en;
 	hw->dcb_info.hw_pfc_map = hw_pfc_map;
 
-- 
2.7.4

