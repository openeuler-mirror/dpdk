From ecfa2e7054530f4a1eb9118a30a9bc6439b29bd8 Mon Sep 17 00:00:00 2001
From: Raja Zidane <rzidane@nvidia.com>
Date: Tue, 15 Nov 2022 12:06:11 +0800
Subject: app/testpmd: fix GENEVE parsing in checksum mode

[ upstream commit 993677affe391be8bb390c2625bc3d8bb857f0a5 ]

The csum FWD mode parses any received packet to set mbuf offloads for
the transmitting burst, mainly in the checksum/TSO areas.
In the case of a tunnel header, the csum FWD tries to detect known
tunnels by the standard definition using the header's data and fallback
to check the packet type in the mbuf to see if the Rx port driver
already sign the packet as a tunnel.
In the fallback case, the csum assumes the tunnel is VXLAN and parses
the tunnel as VXLAN.
When the GENEVE tunnel was added to the known tunnels in csum, its
parsing trial was wrongly located after the pkt type detection, causing
the csum to parse the GENEVE header as VXLAN when the Rx port set the
tunnel packet type.

Remove the fall back case to VXLAN.
Log error of unrecognized tunnel if no tunnel was parsed successfully.

Fixes: c10a026c3b03 ("app/testpmd: introduce vxlan parsing function in csum fwd engine")
Cc: stable@dpdk.org

Signed-off-by: Raja Zidane <rzidane@nvidia.com>
Acked-by: Aman Singh <aman.deep.singh@intel.com>
Acked-by: Ferruh Yigit <ferruh.yigit@intel.com>
---
 app/test-pmd/csumonly.c | 15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

diff --git a/app/test-pmd/csumonly.c b/app/test-pmd/csumonly.c
index d8cb8c89aa..7c4c04be26 100644
--- a/app/test-pmd/csumonly.c
+++ b/app/test-pmd/csumonly.c
@@ -257,8 +257,7 @@ parse_gtp(struct rte_udp_hdr *udp_hdr,
 /* Parse a vxlan header */
 static void
 parse_vxlan(struct rte_udp_hdr *udp_hdr,
-	    struct testpmd_offload_info *info,
-	    uint32_t pkt_type)
+	    struct testpmd_offload_info *info)
 {
 	struct rte_ether_hdr *eth_hdr;
 
@@ -266,8 +265,7 @@ parse_vxlan(struct rte_udp_hdr *udp_hdr,
 	 * default vxlan port (rfc7348) or that the rx offload flag is set
 	 * (i40e only currently)
 	 */
-	if (udp_hdr->dst_port != _htons(RTE_VXLAN_DEFAULT_PORT) &&
-		RTE_ETH_IS_TUNNEL_PKT(pkt_type) == 0)
+	if (udp_hdr->dst_port != _htons(RTE_VXLAN_DEFAULT_PORT))
 		return;
 
 	update_tunnel_outer(info);
@@ -914,8 +912,7 @@ pkt_burst_checksum_forward(struct fwd_stream *fs)
 						RTE_MBUF_F_TX_TUNNEL_VXLAN_GPE;
 					goto tunnel_update;
 				}
-				parse_vxlan(udp_hdr, &info,
-					    m->packet_type);
+				parse_vxlan(udp_hdr, &info);
 				if (info.is_tunnel) {
 					tx_ol_flags |=
 						RTE_MBUF_F_TX_TUNNEL_VXLAN;
@@ -927,6 +924,12 @@ pkt_burst_checksum_forward(struct fwd_stream *fs)
 						RTE_MBUF_F_TX_TUNNEL_GENEVE;
 					goto tunnel_update;
 				}
+				/* Always keep last. */
+				if (unlikely(RTE_ETH_IS_TUNNEL_PKT(
+							m->packet_type) != 0)) {
+					TESTPMD_LOG(DEBUG, "Unknown tunnel packet. UDP dst port: %hu",
+						udp_hdr->dst_port);
+				}
 			} else if (info.l4_proto == IPPROTO_GRE) {
 				struct simple_gre_hdr *gre_hdr;
 
-- 
2.23.0

