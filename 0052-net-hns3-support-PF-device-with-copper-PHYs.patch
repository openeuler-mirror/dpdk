From ed40b1477365a3c581f487ba3c8261c53dcdc255 Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Thu, 4 Mar 2021 15:44:48 +0800
Subject: [PATCH 052/189] net/hns3: support PF device with copper PHYs

The normal operation of devices with copper phys depends on the
initialization and configuration of the PHY chip. The task of
driving the PHY chip is implemented in some firmware versions.
If firmware supports the phy driver, it will report a capability
flag to driver in probing process. The driver determines whether
to support PF device with copper phys based on the capability bit.
If supported, the driver set a flag indicating that the firmware
takes over the PHY, and then the firmware initializes the PHY.

This patch supports the query of link status and link info, and
existing basic features for PF device with copper phys.

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Lijun Ou <oulijun@huawei.com>
---
 drivers/net/hns3/hns3_cmd.c    |   8 +--
 drivers/net/hns3/hns3_cmd.h    |  37 +++++++++++++
 drivers/net/hns3/hns3_ethdev.c | 115 ++++++++++++++++++++++++++++++++++++++---
 drivers/net/hns3/hns3_ethdev.h |   5 ++
 4 files changed, 152 insertions(+), 13 deletions(-)

diff --git a/drivers/net/hns3/hns3_cmd.c b/drivers/net/hns3/hns3_cmd.c
index f0bc177..0590898 100644
--- a/drivers/net/hns3/hns3_cmd.c
+++ b/drivers/net/hns3/hns3_cmd.c
@@ -423,14 +423,8 @@ static void hns3_parse_capability(struct hns3_hw *hw,
 		hns3_set_bit(hw->capability, HNS3_DEV_SUPPORT_PTP_B, 1);
 	if (hns3_get_bit(caps, HNS3_CAPS_TX_PUSH_B))
 		hns3_set_bit(hw->capability, HNS3_DEV_SUPPORT_TX_PUSH_B, 1);
-	/*
-	 * Currently, the query of link status and link info on copper ports
-	 * are not supported. So it is necessary for driver to set the copper
-	 * capability bit to zero when the firmware supports the configuration
-	 * of the PHY.
-	 */
 	if (hns3_get_bit(caps, HNS3_CAPS_PHY_IMP_B))
-		hns3_set_bit(hw->capability, HNS3_DEV_SUPPORT_COPPER_B, 0);
+		hns3_set_bit(hw->capability, HNS3_DEV_SUPPORT_COPPER_B, 1);
 	if (hns3_get_bit(caps, HNS3_CAPS_TQP_TXRX_INDEP_B))
 		hns3_set_bit(hw->capability, HNS3_DEV_SUPPORT_INDEP_TXRX_B, 1);
 	if (hns3_get_bit(caps, HNS3_CAPS_STASH_B))
diff --git a/drivers/net/hns3/hns3_cmd.h b/drivers/net/hns3/hns3_cmd.h
index 93bfa74..7f567cb 100644
--- a/drivers/net/hns3/hns3_cmd.h
+++ b/drivers/net/hns3/hns3_cmd.h
@@ -222,6 +222,8 @@ enum hns3_opcode_type {
 
 	/* Firmware stats command */
 	HNS3_OPC_FIRMWARE_COMPAT_CFG    = 0x701A,
+	/* Firmware control phy command */
+	HNS3_OPC_PHY_PARAM_CFG          = 0x7025,
 
 	/* SFP command */
 	HNS3_OPC_GET_SFP_EEPROM         = 0x7100,
@@ -659,11 +661,46 @@ enum hns3_promisc_type {
 
 #define HNS3_LINK_EVENT_REPORT_EN_B	0
 #define HNS3_NCSI_ERROR_REPORT_EN_B	1
+#define HNS3_FIRMWARE_PHY_DRIVER_EN_B	2
 struct hns3_firmware_compat_cmd {
 	uint32_t compat;
 	uint8_t rsv[20];
 };
 
+/* Bitmap flags in supported, advertising and lp_advertising */
+#define HNS3_PHY_LINK_SPEED_10M_HD_BIT		BIT(0)
+#define HNS3_PHY_LINK_SPEED_10M_BIT		BIT(1)
+#define HNS3_PHY_LINK_SPEED_100M_HD_BIT		BIT(2)
+#define HNS3_PHY_LINK_SPEED_100M_BIT		BIT(3)
+#define HNS3_PHY_LINK_MODE_AUTONEG_BIT		BIT(6)
+#define HNS3_PHY_LINK_MODE_PAUSE_BIT		BIT(13)
+#define HNS3_PHY_LINK_MODE_ASYM_PAUSE_BIT	BIT(14)
+
+#define HNS3_PHY_PARAM_CFG_BD_NUM	2
+struct hns3_phy_params_bd0_cmd {
+	uint32_t speed;
+#define HNS3_PHY_DUPLEX_CFG_B		0
+	uint8_t duplex;
+#define HNS3_PHY_AUTONEG_CFG_B	0
+	uint8_t autoneg;
+	uint8_t eth_tp_mdix;
+	uint8_t eth_tp_mdix_ctrl;
+	uint8_t port;
+	uint8_t transceiver;
+	uint8_t phy_address;
+	uint8_t rsv;
+	uint32_t supported;
+	uint32_t advertising;
+	uint32_t lp_advertising;
+};
+
+struct hns3_phy_params_bd1_cmd {
+	uint8_t master_slave_cfg;
+	uint8_t master_slave_state;
+	uint8_t rsv1[2];
+	uint32_t rsv2[5];
+};
+
 #define HNS3_MAC_TX_EN_B		6
 #define HNS3_MAC_RX_EN_B		7
 #define HNS3_MAC_PAD_TX_B		11
diff --git a/drivers/net/hns3/hns3_ethdev.c b/drivers/net/hns3/hns3_ethdev.c
index 94c08e8..6cb6bec 100644
--- a/drivers/net/hns3/hns3_ethdev.c
+++ b/drivers/net/hns3/hns3_ethdev.c
@@ -3090,6 +3090,37 @@ hns3_get_capability(struct hns3_hw *hw)
 }
 
 static int
+hns3_check_media_type(struct hns3_hw *hw, uint8_t media_type)
+{
+	int ret;
+
+	switch (media_type) {
+	case HNS3_MEDIA_TYPE_COPPER:
+		if (!hns3_dev_copper_supported(hw)) {
+			PMD_INIT_LOG(ERR,
+				     "Media type is copper, not supported.");
+			ret = -EOPNOTSUPP;
+		} else {
+			ret = 0;
+		}
+		break;
+	case HNS3_MEDIA_TYPE_FIBER:
+		ret = 0;
+		break;
+	case HNS3_MEDIA_TYPE_BACKPLANE:
+		PMD_INIT_LOG(ERR, "Media type is Backplane, not supported.");
+		ret = -EOPNOTSUPP;
+		break;
+	default:
+		PMD_INIT_LOG(ERR, "Unknown media type = %u!", media_type);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int
 hns3_get_board_configuration(struct hns3_hw *hw)
 {
 	struct hns3_adapter *hns = HNS3_DEV_HW_TO_ADAPTER(hw);
@@ -3103,11 +3134,9 @@ hns3_get_board_configuration(struct hns3_hw *hw)
 		return ret;
 	}
 
-	if (cfg.media_type == HNS3_MEDIA_TYPE_COPPER &&
-	    !hns3_dev_copper_supported(hw)) {
-		PMD_INIT_LOG(ERR, "media type is copper, not supported.");
-		return -EOPNOTSUPP;
-	}
+	ret = hns3_check_media_type(hw, cfg.media_type);
+	if (ret)
+		return ret;
 
 	hw->mac.media_type = cfg.media_type;
 	hw->rss_size_max = cfg.rss_size_max;
@@ -3952,6 +3981,8 @@ hns3_firmware_compat_config(struct hns3_hw *hw, bool is_init)
 	if (is_init) {
 		hns3_set_bit(compat, HNS3_LINK_EVENT_REPORT_EN_B, 1);
 		hns3_set_bit(compat, HNS3_NCSI_ERROR_REPORT_EN_B, 0);
+		if (hw->mac.media_type == HNS3_MEDIA_TYPE_COPPER)
+			hns3_set_bit(compat, HNS3_FIRMWARE_PHY_DRIVER_EN_B, 1);
 	}
 
 	req->compat = rte_cpu_to_le_32(compat);
@@ -4429,6 +4460,78 @@ hns3_update_fiber_link_info(struct hns3_hw *hw)
 	return hns3_cfg_mac_speed_dup(hw, speed, ETH_LINK_FULL_DUPLEX);
 }
 
+static void
+hns3_parse_phy_params(struct hns3_cmd_desc *desc, struct hns3_mac *mac)
+{
+	struct hns3_phy_params_bd0_cmd *req;
+
+	req = (struct hns3_phy_params_bd0_cmd *)desc[0].data;
+	mac->link_speed = rte_le_to_cpu_32(req->speed);
+	mac->link_duplex = hns3_get_bit(req->duplex,
+					   HNS3_PHY_DUPLEX_CFG_B);
+	mac->link_autoneg = hns3_get_bit(req->autoneg,
+					   HNS3_PHY_AUTONEG_CFG_B);
+	mac->supported_capa = rte_le_to_cpu_32(req->supported);
+	mac->advertising = rte_le_to_cpu_32(req->advertising);
+	mac->lp_advertising = rte_le_to_cpu_32(req->lp_advertising);
+	mac->support_autoneg = !!(mac->supported_capa &
+				HNS3_PHY_LINK_MODE_AUTONEG_BIT);
+}
+
+static int
+hns3_get_phy_params(struct hns3_hw *hw, struct hns3_mac *mac)
+{
+	struct hns3_cmd_desc desc[HNS3_PHY_PARAM_CFG_BD_NUM];
+	uint16_t i;
+	int ret;
+
+	for (i = 0; i < HNS3_PHY_PARAM_CFG_BD_NUM - 1; i++) {
+		hns3_cmd_setup_basic_desc(&desc[i], HNS3_OPC_PHY_PARAM_CFG,
+					  true);
+		desc[i].flag |= rte_cpu_to_le_16(HNS3_CMD_FLAG_NEXT);
+	}
+	hns3_cmd_setup_basic_desc(&desc[i], HNS3_OPC_PHY_PARAM_CFG, true);
+
+	ret = hns3_cmd_send(hw, desc, HNS3_PHY_PARAM_CFG_BD_NUM);
+	if (ret) {
+		hns3_err(hw, "get phy parameters failed, ret = %d.", ret);
+		return ret;
+	}
+
+	hns3_parse_phy_params(desc, mac);
+
+	return 0;
+}
+
+static int
+hns3_update_phy_link_info(struct hns3_hw *hw)
+{
+	struct hns3_mac *mac = &hw->mac;
+	struct hns3_mac mac_info;
+	int ret;
+
+	memset(&mac_info, 0, sizeof(struct hns3_mac));
+	ret = hns3_get_phy_params(hw, &mac_info);
+	if (ret)
+		return ret;
+
+	if (mac_info.link_speed != mac->link_speed) {
+		ret = hns3_port_shaper_update(hw, mac_info.link_speed);
+		if (ret)
+			return ret;
+	}
+
+	mac->link_speed = mac_info.link_speed;
+	mac->link_duplex = mac_info.link_duplex;
+	mac->link_autoneg = mac_info.link_autoneg;
+	mac->supported_capa = mac_info.supported_capa;
+	mac->advertising = mac_info.advertising;
+	mac->lp_advertising = mac_info.lp_advertising;
+	mac->support_autoneg = mac_info.support_autoneg;
+
+	return 0;
+}
+
 static int
 hns3_update_link_info(struct rte_eth_dev *eth_dev)
 {
@@ -4437,7 +4540,7 @@ hns3_update_link_info(struct rte_eth_dev *eth_dev)
 	int ret = 0;
 
 	if (hw->mac.media_type == HNS3_MEDIA_TYPE_COPPER)
-		return 0;
+		ret = hns3_update_phy_link_info(hw);
 	else if (hw->mac.media_type == HNS3_MEDIA_TYPE_FIBER)
 		ret = hns3_update_fiber_link_info(hw);
 
diff --git a/drivers/net/hns3/hns3_ethdev.h b/drivers/net/hns3/hns3_ethdev.h
index 2954422..3cbc2f2 100644
--- a/drivers/net/hns3/hns3_ethdev.h
+++ b/drivers/net/hns3/hns3_ethdev.h
@@ -180,6 +180,11 @@ struct hns3_mac {
 	uint8_t link_autoneg : 1; /* ETH_LINK_[AUTONEG/FIXED] */
 	uint8_t link_status  : 1; /* ETH_LINK_[DOWN/UP] */
 	uint32_t link_speed;      /* ETH_SPEED_NUM_ */
+	uint32_t supported_capa;  /* supported capability for current media */
+	uint32_t advertising;     /* advertised capability in the local part */
+	/* advertised capability in the link partner */
+	uint32_t lp_advertising;
+	uint8_t support_autoneg;
 };
 
 struct hns3_fake_queue_data {
-- 
2.7.4

