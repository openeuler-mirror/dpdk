From b9fbefb52b791730d5720946713e6cb187337652 Mon Sep 17 00:00:00 2001
From: Hongbo Zheng <zhenghongbo3@huawei.com>
Date: Thu, 4 Mar 2021 15:44:53 +0800
Subject: [PATCH 057/189] net/hns3: process MAC interrupt

TNL is the abbreviation of tunnel, which means port
here. MAC TNL interrupt indicates the MAC status
report of the network port, which will be generated
when the MAC status changes.

This patch enables MAC TNL interrupt reporting, and
queries and prints the corresponding MAC status when
the interrupt is received, then clear the MAC interrupt
status. Because this interrupt uses the same interrupt
as RAS, the interrupt log is adjusted.

Signed-off-by: Hongbo Zheng <zhenghongbo3@huawei.com>
Signed-off-by: Lijun Ou <oulijun@huawei.com>
---
 drivers/net/hns3/hns3_cmd.h    |  3 +++
 drivers/net/hns3/hns3_ethdev.c | 57 ++++++++++++++++++++++++++++++++++++------
 drivers/net/hns3/hns3_intr.c   | 20 +++++++++++++++
 drivers/net/hns3/hns3_intr.h   |  4 +++
 4 files changed, 76 insertions(+), 8 deletions(-)

diff --git a/drivers/net/hns3/hns3_cmd.h b/drivers/net/hns3/hns3_cmd.h
index 6ceb655..094bf7e 100644
--- a/drivers/net/hns3/hns3_cmd.h
+++ b/drivers/net/hns3/hns3_cmd.h
@@ -116,6 +116,9 @@ enum hns3_opcode_type {
 	HNS3_OPC_QUERY_LINK_STATUS      = 0x0307,
 	HNS3_OPC_CONFIG_MAX_FRM_SIZE    = 0x0308,
 	HNS3_OPC_CONFIG_SPEED_DUP       = 0x0309,
+	HNS3_OPC_QUERY_MAC_TNL_INT      = 0x0310,
+	HNS3_OPC_MAC_TNL_INT_EN         = 0x0311,
+	HNS3_OPC_CLEAR_MAC_TNL_INT      = 0x0312,
 	HNS3_OPC_CONFIG_FEC_MODE        = 0x031A,
 
 	/* PFC/Pause commands */
diff --git a/drivers/net/hns3/hns3_ethdev.c b/drivers/net/hns3/hns3_ethdev.c
index 1d56916..80f91a7 100644
--- a/drivers/net/hns3/hns3_ethdev.c
+++ b/drivers/net/hns3/hns3_ethdev.c
@@ -217,9 +217,6 @@ hns3_check_event_cause(struct hns3_adapter *hns, uint32_t *clearval)
 		goto out;
 	}
 
-	if (clearval && (vector0_int_stats || cmdq_src_val || hw_err_src_reg))
-		hns3_warn(hw, "vector0_int_stats:0x%x cmdq_src_val:0x%x hw_err_src_reg:0x%x",
-			  vector0_int_stats, cmdq_src_val, hw_err_src_reg);
 	val = vector0_int_stats;
 	ret = HNS3_VECTOR0_EVENT_OTHER;
 out:
@@ -258,6 +255,34 @@ hns3_clear_all_event_cause(struct hns3_hw *hw)
 }
 
 static void
+hns3_handle_mac_tnl(struct hns3_hw *hw)
+{
+	struct hns3_cmd_desc desc;
+	uint32_t status;
+	int ret;
+
+	/* query and clear mac tnl interruptions */
+	hns3_cmd_setup_basic_desc(&desc, HNS3_OPC_QUERY_MAC_TNL_INT, true);
+	ret = hns3_cmd_send(hw, &desc, 1);
+	if (ret) {
+		hns3_err(hw, "failed to query mac tnl int, ret = %d.", ret);
+		return;
+	}
+
+	status = rte_le_to_cpu_32(desc.data[0]);
+	if (status) {
+		hns3_warn(hw, "mac tnl int occurs, status = 0x%x.", status);
+		hns3_cmd_setup_basic_desc(&desc, HNS3_OPC_CLEAR_MAC_TNL_INT,
+					  false);
+		desc.data[0] = rte_cpu_to_le_32(HNS3_MAC_TNL_INT_CLR);
+		ret = hns3_cmd_send(hw, &desc, 1);
+		if (ret)
+			hns3_err(hw, "failed to clear mac tnl int, ret = %d.",
+				 ret);
+	}
+}
+
+static void
 hns3_interrupt_handler(void *param)
 {
 	struct rte_eth_dev *dev = (struct rte_eth_dev *)param;
@@ -265,24 +290,36 @@ hns3_interrupt_handler(void *param)
 	struct hns3_hw *hw = &hns->hw;
 	enum hns3_evt_cause event_cause;
 	uint32_t clearval = 0;
+	uint32_t vector0_int;
+	uint32_t ras_int;
+	uint32_t cmdq_int;
 
 	/* Disable interrupt */
 	hns3_pf_disable_irq0(hw);
 
 	event_cause = hns3_check_event_cause(hns, &clearval);
+	vector0_int = hns3_read_dev(hw, HNS3_VECTOR0_OTHER_INT_STS_REG);
+	ras_int = hns3_read_dev(hw, HNS3_RAS_PF_OTHER_INT_STS_REG);
+	cmdq_int = hns3_read_dev(hw, HNS3_VECTOR0_CMDQ_SRC_REG);
 	/* vector 0 interrupt is shared with reset and mailbox source events. */
 	if (event_cause == HNS3_VECTOR0_EVENT_ERR) {
-		hns3_warn(hw, "Received err interrupt");
+		hns3_warn(hw, "received interrupt: vector0_int_stat:0x%x "
+			  "ras_int_stat:0x%x cmdq_int_stat:0x%x",
+			  vector0_int, ras_int, cmdq_int);
 		hns3_handle_msix_error(hns, &hw->reset.request);
 		hns3_handle_ras_error(hns, &hw->reset.request);
+		hns3_handle_mac_tnl(hw);
 		hns3_schedule_reset(hns);
 	} else if (event_cause == HNS3_VECTOR0_EVENT_RST) {
-		hns3_warn(hw, "Received reset interrupt");
+		hns3_warn(hw, "received reset interrupt");
 		hns3_schedule_reset(hns);
-	} else if (event_cause == HNS3_VECTOR0_EVENT_MBX)
+	} else if (event_cause == HNS3_VECTOR0_EVENT_MBX) {
 		hns3_dev_handle_mbx_msg(hw);
-	else
-		hns3_err(hw, "Received unknown event");
+	} else {
+		hns3_warn(hw, "received unknown event: vector0_int_stat:0x%x "
+			  "ras_int_stat:0x%x cmdq_int_stat:0x%x",
+			  vector0_int, ras_int, cmdq_int);
+	}
 
 	hns3_clear_event_cause(hw, event_cause, clearval);
 	/* Enable interrupt if it is not cause by reset */
@@ -4639,6 +4676,8 @@ hns3_update_link_status(struct hns3_hw *hw)
 	if (state != hw->mac.link_status) {
 		hw->mac.link_status = state;
 		hns3_warn(hw, "Link status change to %s!", state ? "up" : "down");
+		hns3_config_mac_tnl_int(hw,
+					state == ETH_LINK_UP ? true : false);
 		return true;
 	}
 
@@ -4957,6 +4996,7 @@ hns3_uninit_pf(struct rte_eth_dev *eth_dev)
 	(void)hns3_firmware_compat_config(hw, false);
 	hns3_uninit_umv_space(hw);
 	hns3_tqp_stats_uninit(hw);
+	hns3_config_mac_tnl_int(hw, false);
 	hns3_pf_disable_irq0(hw);
 	rte_intr_disable(&pci_dev->intr_handle);
 	hns3_intr_unregister(&pci_dev->intr_handle, hns3_interrupt_handler,
@@ -5282,6 +5322,7 @@ hns3_dev_stop(struct rte_eth_dev *dev)
 	rte_spinlock_lock(&hw->lock);
 	if (__atomic_load_n(&hw->reset.resetting, __ATOMIC_RELAXED) == 0) {
 		hns3_tm_dev_stop_proc(hw);
+		hns3_config_mac_tnl_int(hw, false);
 		hns3_stop_tqps(hw);
 		hns3_do_stop(hns);
 		hns3_unmap_rx_interrupt(dev);
diff --git a/drivers/net/hns3/hns3_intr.c b/drivers/net/hns3/hns3_intr.c
index 88ce4c6..2563504 100644
--- a/drivers/net/hns3/hns3_intr.c
+++ b/drivers/net/hns3/hns3_intr.c
@@ -1248,6 +1248,26 @@ enable_ssu_err_intr(struct hns3_adapter *hns, bool en)
 	return ret;
 }
 
+void
+hns3_config_mac_tnl_int(struct hns3_hw *hw, bool en)
+{
+	struct hns3_cmd_desc desc;
+	int ret;
+
+	hns3_cmd_setup_basic_desc(&desc, HNS3_OPC_MAC_TNL_INT_EN, false);
+	if (en)
+		desc.data[0] = rte_cpu_to_le_32(HNS3_MAC_TNL_INT_EN);
+	else
+		desc.data[0] = 0;
+
+	desc.data[1] = rte_cpu_to_le_32(HNS3_MAC_TNL_INT_EN_MASK);
+
+	ret = hns3_cmd_send(hw, &desc, 1);
+	if (ret)
+		hns3_err(hw, "fail to %s mac tnl intr, ret = %d",
+			 en ? "enable" : "disable", ret);
+}
+
 static int
 config_ppu_err_intrs(struct hns3_adapter *hns, uint32_t cmd, bool en)
 {
diff --git a/drivers/net/hns3/hns3_intr.h b/drivers/net/hns3/hns3_intr.h
index 19de1aa..c569a9d 100644
--- a/drivers/net/hns3/hns3_intr.h
+++ b/drivers/net/hns3/hns3_intr.h
@@ -22,6 +22,9 @@
 
 #define HNS3_MAC_COMMON_ERR_INT_EN		0x107FF
 #define HNS3_MAC_COMMON_ERR_INT_EN_MASK		0x107FF
+#define HNS3_MAC_TNL_INT_EN			GENMASK(9, 0)
+#define HNS3_MAC_TNL_INT_EN_MASK		GENMASK(9, 0)
+#define HNS3_MAC_TNL_INT_CLR			GENMASK(9, 0)
 
 #define HNS3_IMP_TCM_ECC_ERR_INT_EN		0xFFFF0000
 #define HNS3_IMP_TCM_ECC_ERR_INT_EN_MASK	0xFFFF0000
@@ -99,6 +102,7 @@ struct hns3_hw_error_desc {
 int hns3_enable_hw_error_intr(struct hns3_adapter *hns, bool state);
 void hns3_handle_msix_error(struct hns3_adapter *hns, uint64_t *levels);
 void hns3_handle_ras_error(struct hns3_adapter *hns, uint64_t *levels);
+void hns3_config_mac_tnl_int(struct hns3_hw *hw, bool en);
 
 void hns3_intr_unregister(const struct rte_intr_handle *hdl,
 			  rte_intr_callback_fn cb_fn, void *cb_arg);
-- 
2.7.4

