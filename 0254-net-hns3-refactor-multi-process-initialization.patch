From 8388c42414d8f33ba97b01cbe4bf4e945a9819b4 Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Tue, 2 Nov 2021 09:38:29 +0800
Subject: [PATCH 21/33] net/hns3: refactor multi-process initialization

Currently, the logic of the PF and VF initialization codes for multiple
process is the same. A common function can be extracted to initialize
and unload multiple process.

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_ethdev.c    | 34 +++++------------
 drivers/net/hns3/hns3_ethdev_vf.c | 33 +++++-----------
 drivers/net/hns3/hns3_mp.c        | 62 ++++++++++++++++++++++++-------
 drivers/net/hns3/hns3_mp.h        |  6 +--
 4 files changed, 68 insertions(+), 67 deletions(-)

diff --git a/drivers/net/hns3/hns3_ethdev.c b/drivers/net/hns3/hns3_ethdev.c
index b4f375bf2..ecf912a9f 100644
--- a/drivers/net/hns3/hns3_ethdev.c
+++ b/drivers/net/hns3/hns3_ethdev.c
@@ -5895,8 +5895,7 @@ hns3_dev_close(struct rte_eth_dev *eth_dev)
 	int ret = 0;
 
 	if (rte_eal_process_type() != RTE_PROC_PRIMARY) {
-		__atomic_fetch_sub(&hw->secondary_cnt, 1, __ATOMIC_RELAXED);
-		hns3_mp_uninit();
+		hns3_mp_uninit(eth_dev);
 		return 0;
 	}
 
@@ -5913,7 +5912,7 @@ hns3_dev_close(struct rte_eth_dev *eth_dev)
 	hns3_uninit_pf(eth_dev);
 	hns3_free_all_queues(eth_dev);
 	rte_free(hw->reset.wait_data);
-	hns3_mp_uninit();
+	hns3_mp_uninit(eth_dev);
 	hns3_warn(hw, "Close port %u finished", hw->data->port_id);
 
 	return ret;
@@ -7417,28 +7416,15 @@ hns3_dev_init(struct rte_eth_dev *eth_dev)
 	hns3_set_rxtx_function(eth_dev);
 	eth_dev->dev_ops = &hns3_eth_dev_ops;
 	eth_dev->rx_queue_count = hns3_rx_queue_count;
+	ret = hns3_mp_init(eth_dev);
+	if (ret)
+		goto err_mp_init;
+
 	if (rte_eal_process_type() != RTE_PROC_PRIMARY) {
-		ret = hns3_mp_init_secondary();
-		if (ret) {
-			PMD_INIT_LOG(ERR, "Failed to init for secondary "
-				     "process, ret = %d", ret);
-			goto err_mp_init_secondary;
-		}
-		__atomic_fetch_add(&hw->secondary_cnt, 1, __ATOMIC_RELAXED);
-		process_data.eth_dev_cnt++;
 		hns3_tx_push_init(eth_dev);
 		return 0;
 	}
 
-	ret = hns3_mp_init_primary();
-	if (ret) {
-		PMD_INIT_LOG(ERR,
-			     "Failed to init for primary process, ret = %d",
-			     ret);
-		goto err_mp_init_primary;
-	}
-	process_data.eth_dev_cnt++;
-
 	hw->adapter_state = HNS3_NIC_UNINITIALIZED;
 	hns->is_vf = false;
 	hw->data = eth_dev->data;
@@ -7508,10 +7494,9 @@ hns3_dev_init(struct rte_eth_dev *eth_dev)
 	rte_free(hw->reset.wait_data);
 
 err_init_reset:
-	hns3_mp_uninit();
+	hns3_mp_uninit(eth_dev);
 
-err_mp_init_primary:
-err_mp_init_secondary:
+err_mp_init:
 	eth_dev->dev_ops = NULL;
 	eth_dev->rx_pkt_burst = NULL;
 	eth_dev->rx_descriptor_status = NULL;
@@ -7530,8 +7515,7 @@ hns3_dev_uninit(struct rte_eth_dev *eth_dev)
 	PMD_INIT_FUNC_TRACE();
 
 	if (rte_eal_process_type() != RTE_PROC_PRIMARY) {
-		__atomic_fetch_sub(&hw->secondary_cnt, 1, __ATOMIC_RELAXED);
-		hns3_mp_uninit();
+		hns3_mp_uninit(eth_dev);
 		return 0;
 	}
 
diff --git a/drivers/net/hns3/hns3_ethdev_vf.c b/drivers/net/hns3/hns3_ethdev_vf.c
index ac0dcbe36..1e0cb1b63 100644
--- a/drivers/net/hns3/hns3_ethdev_vf.c
+++ b/drivers/net/hns3/hns3_ethdev_vf.c
@@ -1922,8 +1922,7 @@ hns3vf_dev_close(struct rte_eth_dev *eth_dev)
 	int ret = 0;
 
 	if (rte_eal_process_type() != RTE_PROC_PRIMARY) {
-		__atomic_fetch_sub(&hw->secondary_cnt, 1, __ATOMIC_RELAXED);
-		hns3_mp_uninit();
+		hns3_mp_uninit(eth_dev);
 		return 0;
 	}
 
@@ -1939,7 +1938,7 @@ hns3vf_dev_close(struct rte_eth_dev *eth_dev)
 	hns3vf_uninit_vf(eth_dev);
 	hns3_free_all_queues(eth_dev);
 	rte_free(hw->reset.wait_data);
-	hns3_mp_uninit();
+	hns3_mp_uninit(eth_dev);
 	hns3_warn(hw, "Close port %u finished", hw->data->port_id);
 
 	return ret;
@@ -2706,28 +2705,15 @@ hns3vf_dev_init(struct rte_eth_dev *eth_dev)
 	hns3_set_rxtx_function(eth_dev);
 	eth_dev->dev_ops = &hns3vf_eth_dev_ops;
 	eth_dev->rx_queue_count = hns3_rx_queue_count;
+	ret = hns3_mp_init(eth_dev);
+	if (ret)
+		goto err_mp_init;
+
 	if (rte_eal_process_type() != RTE_PROC_PRIMARY) {
-		ret = hns3_mp_init_secondary();
-		if (ret) {
-			PMD_INIT_LOG(ERR, "Failed to init for secondary "
-					  "process, ret = %d", ret);
-			goto err_mp_init_secondary;
-		}
-		__atomic_fetch_add(&hw->secondary_cnt, 1, __ATOMIC_RELAXED);
-		process_data.eth_dev_cnt++;
 		hns3_tx_push_init(eth_dev);
 		return 0;
 	}
 
-	ret = hns3_mp_init_primary();
-	if (ret) {
-		PMD_INIT_LOG(ERR,
-			     "Failed to init for primary process, ret = %d",
-			     ret);
-		goto err_mp_init_primary;
-	}
-	process_data.eth_dev_cnt++;
-
 	hw->adapter_state = HNS3_NIC_UNINITIALIZED;
 	hns->is_vf = true;
 	hw->data = eth_dev->data;
@@ -2795,10 +2781,9 @@ hns3vf_dev_init(struct rte_eth_dev *eth_dev)
 	rte_free(hw->reset.wait_data);
 
 err_init_reset:
-	hns3_mp_uninit();
+	hns3_mp_uninit(eth_dev);
 
-err_mp_init_primary:
-err_mp_init_secondary:
+err_mp_init:
 	eth_dev->dev_ops = NULL;
 	eth_dev->rx_pkt_burst = NULL;
 	eth_dev->rx_descriptor_status = NULL;
@@ -2819,7 +2804,7 @@ hns3vf_dev_uninit(struct rte_eth_dev *eth_dev)
 
 	if (rte_eal_process_type() != RTE_PROC_PRIMARY) {
 		__atomic_fetch_sub(&hw->secondary_cnt, 1, __ATOMIC_RELAXED);
-		hns3_mp_uninit();
+		hns3_mp_uninit(eth_dev);
 		return 0;
 	}
 
diff --git a/drivers/net/hns3/hns3_mp.c b/drivers/net/hns3/hns3_mp.c
index 2ecb16861..63d22bcd3 100644
--- a/drivers/net/hns3/hns3_mp.c
+++ b/drivers/net/hns3/hns3_mp.c
@@ -13,7 +13,7 @@
 #include "hns3_mp.h"
 
 /* local data for primary or secondary process. */
-struct hns3_process_local_data process_data;
+static struct hns3_process_local_data process_data;
 
 /*
  * Initialize IPC message.
@@ -227,7 +227,8 @@ hns3_mp_req_start_tx(struct rte_eth_dev *dev)
 /*
  * Initialize by primary process.
  */
-int hns3_mp_init_primary(void)
+static int
+hns3_mp_init_primary(void)
 {
 	int ret;
 
@@ -244,20 +245,11 @@ int hns3_mp_init_primary(void)
 	return 0;
 }
 
-void hns3_mp_uninit(void)
-{
-	process_data.eth_dev_cnt--;
-
-	if (process_data.eth_dev_cnt == 0) {
-		rte_mp_action_unregister(HNS3_MP_NAME);
-		process_data.init_done = false;
-	}
-}
-
 /*
  * Initialize by secondary process.
  */
-int hns3_mp_init_secondary(void)
+static int
+hns3_mp_init_secondary(void)
 {
 	int ret;
 
@@ -265,10 +257,52 @@ int hns3_mp_init_secondary(void)
 		return 0;
 
 	ret = rte_mp_action_register(HNS3_MP_NAME, mp_secondary_handle);
-	if (ret)
+	if (ret && rte_errno != ENOTSUP)
 		return ret;
 
 	process_data.init_done = true;
 
 	return 0;
 }
+
+int
+hns3_mp_init(struct rte_eth_dev *dev)
+{
+	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
+	int ret;
+
+	if (rte_eal_process_type() != RTE_PROC_PRIMARY) {
+		ret = hns3_mp_init_secondary();
+		if (ret) {
+			PMD_INIT_LOG(ERR, "Failed to init for secondary process, ret = %d",
+				     ret);
+			return ret;
+		}
+		__atomic_fetch_add(&hw->secondary_cnt, 1, __ATOMIC_RELAXED);
+	} else {
+		ret = hns3_mp_init_primary();
+		if (ret) {
+			PMD_INIT_LOG(ERR, "Failed to init for primary process, ret = %d",
+				     ret);
+			return ret;
+		}
+	}
+
+	process_data.eth_dev_cnt++;
+
+	return 0;
+}
+
+void hns3_mp_uninit(struct rte_eth_dev *dev)
+{
+	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
+
+	if (rte_eal_process_type() != RTE_PROC_PRIMARY)
+		__atomic_fetch_sub(&hw->secondary_cnt, 1, __ATOMIC_RELAXED);
+
+	process_data.eth_dev_cnt--;
+	if (process_data.eth_dev_cnt == 0) {
+		rte_mp_action_unregister(HNS3_MP_NAME);
+		process_data.init_done = false;
+	}
+}
diff --git a/drivers/net/hns3/hns3_mp.h b/drivers/net/hns3/hns3_mp.h
index 5738ab74a..a74221d08 100644
--- a/drivers/net/hns3/hns3_mp.h
+++ b/drivers/net/hns3/hns3_mp.h
@@ -10,15 +10,13 @@ struct hns3_process_local_data {
 	bool init_done; /* Process action register completed flag. */
 	int eth_dev_cnt; /* Ethdev count under the current process. */
 };
-extern struct hns3_process_local_data process_data;
 
 void hns3_mp_req_start_rxtx(struct rte_eth_dev *dev);
 void hns3_mp_req_stop_rxtx(struct rte_eth_dev *dev);
 void hns3_mp_req_start_tx(struct rte_eth_dev *dev);
 void hns3_mp_req_stop_tx(struct rte_eth_dev *dev);
 
-int hns3_mp_init_primary(void);
-void hns3_mp_uninit(void);
-int hns3_mp_init_secondary(void);
+int hns3_mp_init(struct rte_eth_dev *dev);
+void hns3_mp_uninit(struct rte_eth_dev *dev);
 
 #endif /* _HNS3_MP_H_ */
-- 
2.33.0

