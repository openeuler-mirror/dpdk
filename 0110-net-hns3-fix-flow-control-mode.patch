From ad7b090b87b90f4348cc257b22f4253e466e46f3 Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Tue, 13 Apr 2021 21:47:13 +0800
Subject: [PATCH 110/189] net/hns3: fix flow control mode

Currently, hns3 driver doesn't support to flow control auto-negotiation.
The FC mode requested by user is the same as the current FC mode. It is
not necessary to maintain the current FC mode. We only report the current
FC mode based on actual flow control mode in hns3_flow_ctrl_get().

This patch removes this redundant field. In addition, "requested_mode" in
hns3_hw struct indicates the FC mode requested by user, and the name is
unreasonable. It needs to be modified to "requested_fc_mode".

Fixes: 62e3ccc2b94c ("net/hns3: support flow control")
Cc: stable@dpdk.org

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_dcb.c    | 23 ++++++++---------------
 drivers/net/hns3/hns3_ethdev.c | 28 ++++++++++------------------
 drivers/net/hns3/hns3_ethdev.h |  3 +--
 3 files changed, 19 insertions(+), 35 deletions(-)

diff --git a/drivers/net/hns3/hns3_dcb.c b/drivers/net/hns3/hns3_dcb.c
index ebfc240..49b8be7 100644
--- a/drivers/net/hns3/hns3_dcb.c
+++ b/drivers/net/hns3/hns3_dcb.c
@@ -1238,7 +1238,7 @@ hns3_qs_bp_cfg(struct hns3_hw *hw, uint8_t tc, uint8_t grp_id, uint32_t bit_map)
 static void
 hns3_get_rx_tx_en_status(struct hns3_hw *hw, bool *tx_en, bool *rx_en)
 {
-	switch (hw->current_mode) {
+	switch (hw->requested_fc_mode) {
 	case HNS3_FC_NONE:
 		*tx_en = false;
 		*rx_en = false;
@@ -1415,7 +1415,7 @@ hns3_dcb_cfg_validate(struct hns3_adapter *hns, uint8_t *tc, bool *changed)
 	 * We ensure that dcb information can be reconfigured
 	 * after the hns3_priority_flow_ctrl_set function called.
 	 */
-	if (hw->current_mode != HNS3_FC_FULL)
+	if (hw->requested_fc_mode != HNS3_FC_FULL)
 		*changed = true;
 	pfc_en = RTE_LEN2MASK((uint8_t)dcb_rx_conf->nb_tcs, uint8_t);
 	if (hw->dcb_info.pfc_en != pfc_en)
@@ -1529,7 +1529,7 @@ hns3_dcb_hw_configure(struct hns3_adapter *hns)
 	struct hns3_pf *pf = &hns->pf;
 	struct hns3_hw *hw = &hns->hw;
 	enum hns3_fc_status fc_status = hw->current_fc_status;
-	enum hns3_fc_mode current_mode = hw->current_mode;
+	enum hns3_fc_mode requested_fc_mode = hw->requested_fc_mode;
 	uint8_t hw_pfc_map = hw->dcb_info.hw_pfc_map;
 	int ret, status;
 
@@ -1559,7 +1559,7 @@ hns3_dcb_hw_configure(struct hns3_adapter *hns)
 			return ret;
 
 		hw->current_fc_status = HNS3_FC_STATUS_PFC;
-		hw->current_mode = HNS3_FC_FULL;
+		hw->requested_fc_mode = HNS3_FC_FULL;
 		ret = hns3_dcb_pause_setup_hw(hw);
 		if (ret) {
 			hns3_err(hw, "setup pfc failed! ret = %d", ret);
@@ -1580,7 +1580,7 @@ hns3_dcb_hw_configure(struct hns3_adapter *hns)
 	return 0;
 
 pfc_setup_fail:
-	hw->current_mode = current_mode;
+	hw->requested_fc_mode = requested_fc_mode;
 	hw->current_fc_status = fc_status;
 	hw->dcb_info.hw_pfc_map = hw_pfc_map;
 	status = hns3_buffer_alloc(hw);
@@ -1659,8 +1659,7 @@ hns3_dcb_init(struct hns3_hw *hw)
 	 * will be changed.
 	 */
 	if (hw->adapter_state == HNS3_NIC_UNINITIALIZED) {
-		hw->requested_mode = HNS3_FC_NONE;
-		hw->current_mode = hw->requested_mode;
+		hw->requested_fc_mode = HNS3_FC_NONE;
 		pf->pause_time = HNS3_DEFAULT_PAUSE_TRANS_TIME;
 		hw->current_fc_status = HNS3_FC_STATUS_NONE;
 
@@ -1761,7 +1760,6 @@ hns3_dcb_pfc_enable(struct rte_eth_dev *dev, struct rte_eth_pfc_conf *pfc_conf)
 	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
 	struct hns3_pf *pf = HNS3_DEV_PRIVATE_TO_PF(dev->data->dev_private);
 	enum hns3_fc_status fc_status = hw->current_fc_status;
-	enum hns3_fc_mode current_mode = hw->current_mode;
 	uint8_t hw_pfc_map = hw->dcb_info.hw_pfc_map;
 	uint8_t pfc_en = hw->dcb_info.pfc_en;
 	uint8_t priority = pfc_conf->priority;
@@ -1769,7 +1767,6 @@ hns3_dcb_pfc_enable(struct rte_eth_dev *dev, struct rte_eth_pfc_conf *pfc_conf)
 	int ret, status;
 
 	pf->pause_time = pfc_conf->fc.pause_time;
-	hw->current_mode = hw->requested_mode;
 	hw->current_fc_status = HNS3_FC_STATUS_PFC;
 	hw->dcb_info.pfc_en |= BIT(priority);
 	hw->dcb_info.hw_pfc_map =
@@ -1780,7 +1777,7 @@ hns3_dcb_pfc_enable(struct rte_eth_dev *dev, struct rte_eth_pfc_conf *pfc_conf)
 
 	/*
 	 * The flow control mode of all UPs will be changed based on
-	 * current_mode coming from user.
+	 * requested_fc_mode coming from user.
 	 */
 	ret = hns3_dcb_pause_setup_hw(hw);
 	if (ret) {
@@ -1791,7 +1788,6 @@ hns3_dcb_pfc_enable(struct rte_eth_dev *dev, struct rte_eth_pfc_conf *pfc_conf)
 	return 0;
 
 pfc_setup_fail:
-	hw->current_mode = current_mode;
 	hw->current_fc_status = fc_status;
 	pf->pause_time = pause_time;
 	hw->dcb_info.pfc_en = pfc_en;
@@ -1815,18 +1811,16 @@ hns3_fc_enable(struct rte_eth_dev *dev, struct rte_eth_fc_conf *fc_conf)
 	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
 	struct hns3_pf *pf = HNS3_DEV_PRIVATE_TO_PF(dev->data->dev_private);
 	enum hns3_fc_status fc_status = hw->current_fc_status;
-	enum hns3_fc_mode current_mode = hw->current_mode;
 	uint16_t pause_time = pf->pause_time;
 	int ret;
 
 	pf->pause_time = fc_conf->pause_time;
-	hw->current_mode = hw->requested_mode;
 
 	/*
 	 * In fact, current_fc_status is HNS3_FC_STATUS_NONE when mode
 	 * of flow control is configured to be HNS3_FC_NONE.
 	 */
-	if (hw->current_mode == HNS3_FC_NONE)
+	if (hw->requested_fc_mode == HNS3_FC_NONE)
 		hw->current_fc_status = HNS3_FC_STATUS_NONE;
 	else
 		hw->current_fc_status = HNS3_FC_STATUS_MAC_PAUSE;
@@ -1840,7 +1834,6 @@ hns3_fc_enable(struct rte_eth_dev *dev, struct rte_eth_fc_conf *fc_conf)
 	return 0;
 
 setup_fc_fail:
-	hw->current_mode = current_mode;
 	hw->current_fc_status = fc_status;
 	pf->pause_time = pause_time;
 
diff --git a/drivers/net/hns3/hns3_ethdev.c b/drivers/net/hns3/hns3_ethdev.c
index e57163b..5e7ac54 100644
--- a/drivers/net/hns3/hns3_ethdev.c
+++ b/drivers/net/hns3/hns3_ethdev.c
@@ -5496,8 +5496,11 @@ hns3_flow_ctrl_get(struct rte_eth_dev *dev, struct rte_eth_fc_conf *fc_conf)
 
 	fc_conf->pause_time = pf->pause_time;
 
-	/* return fc current mode */
-	switch (hw->current_mode) {
+	/*
+	 * If fc auto-negotiation is not supported, the configured fc mode
+	 * from user is the current fc mode.
+	 */
+	switch (hw->requested_fc_mode) {
 	case HNS3_FC_FULL:
 		fc_conf->mode = RTE_FC_FULL;
 		break;
@@ -5521,19 +5524,19 @@ hns3_get_fc_mode(struct hns3_hw *hw, enum rte_eth_fc_mode mode)
 {
 	switch (mode) {
 	case RTE_FC_NONE:
-		hw->requested_mode = HNS3_FC_NONE;
+		hw->requested_fc_mode = HNS3_FC_NONE;
 		break;
 	case RTE_FC_RX_PAUSE:
-		hw->requested_mode = HNS3_FC_RX_PAUSE;
+		hw->requested_fc_mode = HNS3_FC_RX_PAUSE;
 		break;
 	case RTE_FC_TX_PAUSE:
-		hw->requested_mode = HNS3_FC_TX_PAUSE;
+		hw->requested_fc_mode = HNS3_FC_TX_PAUSE;
 		break;
 	case RTE_FC_FULL:
-		hw->requested_mode = HNS3_FC_FULL;
+		hw->requested_fc_mode = HNS3_FC_FULL;
 		break;
 	default:
-		hw->requested_mode = HNS3_FC_NONE;
+		hw->requested_fc_mode = HNS3_FC_NONE;
 		hns3_warn(hw, "fc_mode(%u) exceeds member scope and is "
 			  "configured to RTE_FC_NONE", mode);
 		break;
@@ -5544,7 +5547,6 @@ static int
 hns3_flow_ctrl_set(struct rte_eth_dev *dev, struct rte_eth_fc_conf *fc_conf)
 {
 	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
-	struct hns3_pf *pf = HNS3_DEV_PRIVATE_TO_PF(dev->data->dev_private);
 	int ret;
 
 	if (fc_conf->high_water || fc_conf->low_water ||
@@ -5579,9 +5581,6 @@ hns3_flow_ctrl_set(struct rte_eth_dev *dev, struct rte_eth_fc_conf *fc_conf)
 	}
 
 	hns3_get_fc_mode(hw, fc_conf->mode);
-	if (hw->requested_mode == hw->current_mode &&
-	    pf->pause_time == fc_conf->pause_time)
-		return 0;
 
 	rte_spinlock_lock(&hw->lock);
 	ret = hns3_fc_enable(dev, fc_conf);
@@ -5595,8 +5594,6 @@ hns3_priority_flow_ctrl_set(struct rte_eth_dev *dev,
 			    struct rte_eth_pfc_conf *pfc_conf)
 {
 	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
-	struct hns3_pf *pf = HNS3_DEV_PRIVATE_TO_PF(dev->data->dev_private);
-	uint8_t priority;
 	int ret;
 
 	if (!hns3_dev_dcb_supported(hw)) {
@@ -5631,12 +5628,7 @@ hns3_priority_flow_ctrl_set(struct rte_eth_dev *dev,
 		return -EOPNOTSUPP;
 	}
 
-	priority = pfc_conf->priority;
 	hns3_get_fc_mode(hw, pfc_conf->fc.mode);
-	if (hw->dcb_info.pfc_en & BIT(priority) &&
-	    hw->requested_mode == hw->current_mode &&
-	    pfc_conf->fc.pause_time == pf->pause_time)
-		return 0;
 
 	rte_spinlock_lock(&hw->lock);
 	ret = hns3_dcb_pfc_enable(dev, pfc_conf);
diff --git a/drivers/net/hns3/hns3_ethdev.h b/drivers/net/hns3/hns3_ethdev.h
index 986bf26..03bb783 100644
--- a/drivers/net/hns3/hns3_ethdev.h
+++ b/drivers/net/hns3/hns3_ethdev.h
@@ -469,8 +469,7 @@ struct hns3_hw {
 
 	uint8_t num_tc;             /* Total number of enabled TCs */
 	uint8_t hw_tc_map;
-	enum hns3_fc_mode current_mode;
-	enum hns3_fc_mode requested_mode;
+	enum hns3_fc_mode requested_fc_mode; /* FC mode requested by user */
 	struct hns3_dcb_info dcb_info;
 	enum hns3_fc_status current_fc_status; /* current flow control status */
 	struct hns3_tc_queue_info tc_queue[HNS3_MAX_TC_NUM];
-- 
2.7.4

