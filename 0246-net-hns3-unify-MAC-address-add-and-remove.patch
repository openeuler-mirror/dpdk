From f1e4c77136cc5d65606ad07cd7204c0994c14904 Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Fri, 22 Oct 2021 17:20:02 +0800
Subject: [PATCH 13/33] net/hns3: unify MAC address add and remove

The code logic of adding and removing MAC address in PF and VF is the
same.
This patch extracts two common interfaces to add and remove them
separately.

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_ethdev.c    | 11 ++---
 drivers/net/hns3/hns3_ethdev.h    |  5 ++-
 drivers/net/hns3/hns3_ethdev_vf.c | 70 +------------------------------
 3 files changed, 9 insertions(+), 77 deletions(-)

diff --git a/drivers/net/hns3/hns3_ethdev.c b/drivers/net/hns3/hns3_ethdev.c
index bdd29220a..bf49d5f75 100644
--- a/drivers/net/hns3/hns3_ethdev.c
+++ b/drivers/net/hns3/hns3_ethdev.c
@@ -1609,7 +1609,7 @@ hns3_add_uc_mac_addr(struct hns3_hw *hw, struct rte_ether_addr *mac_addr)
 	return ret;
 }
 
-bool
+static bool
 hns3_find_duplicate_mc_addr(struct hns3_hw *hw, struct rte_ether_addr *mc_addr)
 {
 	char mac_str[RTE_ETHER_ADDR_FMT_SIZE];
@@ -1632,7 +1632,7 @@ hns3_find_duplicate_mc_addr(struct hns3_hw *hw, struct rte_ether_addr *mc_addr)
 	return false;
 }
 
-static int
+int
 hns3_add_mac_addr(struct rte_eth_dev *dev, struct rte_ether_addr *mac_addr,
 		  __rte_unused uint32_t idx, __rte_unused uint32_t pool)
 {
@@ -1660,17 +1660,14 @@ hns3_add_mac_addr(struct rte_eth_dev *dev, struct rte_ether_addr *mac_addr,
 	} else {
 		ret = hw->ops.add_uc_mac_addr(hw, mac_addr);
 	}
+	rte_spinlock_unlock(&hw->lock);
 	if (ret) {
-		rte_spinlock_unlock(&hw->lock);
 		hns3_ether_format_addr(mac_str, RTE_ETHER_ADDR_FMT_SIZE,
 				      mac_addr);
 		hns3_err(hw, "failed to add mac addr(%s), ret = %d", mac_str,
 			 ret);
-		return ret;
 	}
 
-	rte_spinlock_unlock(&hw->lock);
-
 	return ret;
 }
 
@@ -1702,7 +1699,7 @@ hns3_remove_uc_mac_addr(struct hns3_hw *hw, struct rte_ether_addr *mac_addr)
 	return ret;
 }
 
-static void
+void
 hns3_remove_mac_addr(struct rte_eth_dev *dev, uint32_t idx)
 {
 	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
diff --git a/drivers/net/hns3/hns3_ethdev.h b/drivers/net/hns3/hns3_ethdev.h
index 942e8419c..276ac8b54 100644
--- a/drivers/net/hns3/hns3_ethdev.h
+++ b/drivers/net/hns3/hns3_ethdev.h
@@ -1063,10 +1063,11 @@ void hns3vf_update_link_status(struct hns3_hw *hw, uint8_t link_status,
 void hns3_parse_devargs(struct rte_eth_dev *dev);
 void hns3vf_update_push_lsc_cap(struct hns3_hw *hw, bool supported);
 
-bool hns3_find_duplicate_mc_addr(struct hns3_hw *hw,
-				struct rte_ether_addr *mc_addr);
 int hns3_configure_all_mc_mac_addr(struct hns3_adapter *hns, bool del);
 int hns3_configure_all_mac_addr(struct hns3_adapter *hns, bool del);
+int hns3_add_mac_addr(struct rte_eth_dev *dev, struct rte_ether_addr *mac_addr,
+		__rte_unused uint32_t idx, __rte_unused uint32_t pool);
+void hns3_remove_mac_addr(struct rte_eth_dev *dev, uint32_t idx);
 
 int hns3_restore_ptp(struct hns3_adapter *hns);
 int hns3_mbuf_dyn_rx_timestamp_register(struct rte_eth_dev *dev,
diff --git a/drivers/net/hns3/hns3_ethdev_vf.c b/drivers/net/hns3/hns3_ethdev_vf.c
index cce4d3450..fb7eda21d 100644
--- a/drivers/net/hns3/hns3_ethdev_vf.c
+++ b/drivers/net/hns3/hns3_ethdev_vf.c
@@ -204,72 +204,6 @@ hns3vf_remove_uc_mac_addr(struct hns3_hw *hw, struct rte_ether_addr *mac_addr)
 	return ret;
 }
 
-static int
-hns3vf_add_mac_addr(struct rte_eth_dev *dev, struct rte_ether_addr *mac_addr,
-		    __rte_unused uint32_t idx,
-		    __rte_unused uint32_t pool)
-{
-	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
-	char mac_str[RTE_ETHER_ADDR_FMT_SIZE];
-	int ret;
-
-	rte_spinlock_lock(&hw->lock);
-
-	/*
-	 * In hns3 network engine adding UC and MC mac address with different
-	 * commands with firmware. We need to determine whether the input
-	 * address is a UC or a MC address to call different commands.
-	 * By the way, it is recommended calling the API function named
-	 * rte_eth_dev_set_mc_addr_list to set the MC mac address, because
-	 * using the rte_eth_dev_mac_addr_add API function to set MC mac address
-	 * may affect the specifications of UC mac addresses.
-	 */
-	if (rte_is_multicast_ether_addr(mac_addr)) {
-		if (hns3_find_duplicate_mc_addr(hw, mac_addr)) {
-			rte_spinlock_unlock(&hw->lock);
-			return -EINVAL;
-		}
-		ret = hw->ops.add_mc_mac_addr(hw, mac_addr);
-	} else {
-		ret = hw->ops.add_uc_mac_addr(hw, mac_addr);
-	}
-
-	rte_spinlock_unlock(&hw->lock);
-	if (ret) {
-		hns3_ether_format_addr(mac_str, RTE_ETHER_ADDR_FMT_SIZE,
-				      mac_addr);
-		hns3_err(hw, "failed to add mac addr(%s), ret = %d", mac_str,
-			 ret);
-	}
-
-	return ret;
-}
-
-static void
-hns3vf_remove_mac_addr(struct rte_eth_dev *dev, uint32_t idx)
-{
-	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
-	/* index will be checked by upper level rte interface */
-	struct rte_ether_addr *mac_addr = &dev->data->mac_addrs[idx];
-	char mac_str[RTE_ETHER_ADDR_FMT_SIZE];
-	int ret;
-
-	rte_spinlock_lock(&hw->lock);
-
-	if (rte_is_multicast_ether_addr(mac_addr))
-		ret = hw->ops.del_mc_mac_addr(hw, mac_addr);
-	else
-		ret = hw->ops.del_uc_mac_addr(hw, mac_addr);
-
-	rte_spinlock_unlock(&hw->lock);
-	if (ret) {
-		hns3_ether_format_addr(mac_str, RTE_ETHER_ADDR_FMT_SIZE,
-				      mac_addr);
-		hns3_err(hw, "failed to remove mac addr(%s), ret = %d",
-			 mac_str, ret);
-	}
-}
-
 static int
 hns3vf_set_default_mac_addr(struct rte_eth_dev *dev,
 			    struct rte_ether_addr *mac_addr)
@@ -2831,8 +2765,8 @@ static const struct eth_dev_ops hns3vf_eth_dev_ops = {
 	.txq_info_get       = hns3_txq_info_get,
 	.rx_burst_mode_get  = hns3_rx_burst_mode_get,
 	.tx_burst_mode_get  = hns3_tx_burst_mode_get,
-	.mac_addr_add       = hns3vf_add_mac_addr,
-	.mac_addr_remove    = hns3vf_remove_mac_addr,
+	.mac_addr_add       = hns3_add_mac_addr,
+	.mac_addr_remove    = hns3_remove_mac_addr,
 	.mac_addr_set       = hns3vf_set_default_mac_addr,
 	.set_mc_addr_list   = hns3vf_set_mc_mac_addr_list,
 	.link_update        = hns3vf_dev_link_update,
-- 
2.33.0

