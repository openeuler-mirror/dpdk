From 190de70e4c72d4abb356c8f8a24fec9ec17ce6c1 Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Fri, 10 Mar 2023 17:35:18 +0800
Subject: net/hns3: add verification of RSS types

[ upstream commit eb3ef9e0d7eb54b47ab58d3d14f9f5fff3f4120b ]

Add the verification of RSS types from ethdev ops and rte flow without
pattern attribute. The following cases are invalid:
1. types contains unsupported RSS type but hasn't type driver support.
2. types has L3 src/dst but hasn't supported packet type.
3. types has L4 src/dst but hasn't supported packet type and hasn't IP
   packet type.

Fixes: 13c3993240c8 ("net/hns3: add L3 and L4 RSS types")
Cc: stable@dpdk.org

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Dongdong Liu <liudongdong3@huawei.com>
---
 drivers/net/hns3/hns3_flow.c | 12 +++---
 drivers/net/hns3/hns3_rss.c  | 74 +++++++++++++++++++++++++-----------
 drivers/net/hns3/hns3_rss.h  |  3 +-
 3 files changed, 60 insertions(+), 29 deletions(-)

diff --git a/drivers/net/hns3/hns3_flow.c b/drivers/net/hns3/hns3_flow.c
index c38bd9dd8b..c1f4f5cb0b 100644
--- a/drivers/net/hns3/hns3_flow.c
+++ b/drivers/net/hns3/hns3_flow.c
@@ -1652,9 +1652,10 @@ hns3_flow_parse_rss_types(struct hns3_hw *hw,
 
 	/* no pattern specified to set global RSS types. */
 	if (pattern_type == 0) {
-		if (rss_act->types & ~HNS3_ETH_RSS_SUPPORT)
-			hns3_warn(hw, "some types in the requested RSS types (0x%" PRIx64 ") aren't supported, they are ignored.",
-				  rss_act->types);
+		if (!hns3_check_rss_types_valid(hw, rss_act->types))
+			return rte_flow_error_set(error, EINVAL,
+					RTE_FLOW_ERROR_TYPE_ACTION_CONF,
+					NULL, "RSS types is invalid.");
 		rss_conf->hw_pctypes =
 				hns3_flow_get_all_hw_pctypes(rss_act->types);
 		return 0;
@@ -1929,15 +1930,14 @@ hns3_flow_set_rss_ptype_tuple(struct hns3_hw *hw,
 			uint64_t pctype = BIT_ULL(idx);
 
 			tuple_mask = hns3_flow_get_pctype_tuple_mask(pctype);
-			tuples = hns3_rss_calc_tuple_filed(hw,
-							rss_conf->conf.types);
+			tuples = hns3_rss_calc_tuple_filed(rss_conf->conf.types);
 			new_tuple_fields &= ~tuple_mask;
 			new_tuple_fields |= tuples;
 			hw_pctypes &= ~pctype;
 		}
 	} else {
 		new_tuple_fields =
-			hns3_rss_calc_tuple_filed(hw, rss_conf->conf.types);
+			hns3_rss_calc_tuple_filed(rss_conf->conf.types);
 	}
 
 	ret = hns3_set_rss_tuple_field(hw, new_tuple_fields);
diff --git a/drivers/net/hns3/hns3_rss.c b/drivers/net/hns3/hns3_rss.c
index dfa2901ae3..6126512bd7 100644
--- a/drivers/net/hns3/hns3_rss.c
+++ b/drivers/net/hns3/hns3_rss.c
@@ -492,34 +492,62 @@ hns3_rss_reset_indir_table(struct hns3_hw *hw)
 	return ret;
 }
 
-static void
-hns3_rss_check_l3l4_types(struct hns3_hw *hw, uint64_t rss_hf)
+bool
+hns3_check_rss_types_valid(struct hns3_hw *hw, uint64_t types)
 {
 	uint64_t ip_mask = RTE_ETH_RSS_IPV4 | RTE_ETH_RSS_FRAG_IPV4 |
 			   RTE_ETH_RSS_NONFRAG_IPV4_OTHER |
 			   RTE_ETH_RSS_IPV6 | RTE_ETH_RSS_FRAG_IPV6 |
 			   RTE_ETH_RSS_NONFRAG_IPV6_OTHER;
-	uint64_t l4_mask = RTE_ETH_RSS_NONFRAG_IPV4_TCP |
-			   RTE_ETH_RSS_NONFRAG_IPV4_UDP |
-			   RTE_ETH_RSS_NONFRAG_IPV4_SCTP |
-			   RTE_ETH_RSS_NONFRAG_IPV6_TCP |
-			   RTE_ETH_RSS_NONFRAG_IPV6_UDP |
-			   RTE_ETH_RSS_NONFRAG_IPV6_SCTP;
-	uint64_t l3_src_dst_mask = RTE_ETH_RSS_L3_SRC_ONLY |
-				   RTE_ETH_RSS_L3_DST_ONLY;
-	uint64_t l4_src_dst_mask = RTE_ETH_RSS_L4_SRC_ONLY |
-				   RTE_ETH_RSS_L4_DST_ONLY;
-
-	if (rss_hf & l3_src_dst_mask &&
-	    !(rss_hf & ip_mask || rss_hf & l4_mask))
-		hns3_warn(hw, "packet type isn't specified, L3_SRC/DST_ONLY is ignored.");
-
-	if (rss_hf & l4_src_dst_mask && !(rss_hf & l4_mask))
-		hns3_warn(hw, "packet type isn't specified, L4_SRC/DST_ONLY is ignored.");
+	uint64_t ip_l4_mask = RTE_ETH_RSS_NONFRAG_IPV4_TCP |
+			      RTE_ETH_RSS_NONFRAG_IPV4_UDP |
+			      RTE_ETH_RSS_NONFRAG_IPV4_SCTP |
+			      RTE_ETH_RSS_NONFRAG_IPV6_TCP |
+			      RTE_ETH_RSS_NONFRAG_IPV6_UDP |
+			      RTE_ETH_RSS_NONFRAG_IPV6_SCTP;
+	bool has_l4_src_dst = !!(types & HNS3_RSS_SUPPORT_L4_SRC_DST);
+	bool has_ip_pkt = !!(types & ip_mask);
+	uint64_t final_types;
+
+	if (types == 0)
+		return true;
+
+	if ((types & HNS3_ETH_RSS_SUPPORT) == 0) {
+		hns3_err(hw, "specified types(0x%" PRIx64 ") are unsupported.",
+			 types);
+		return false;
+	}
+
+	if ((types & HNS3_RSS_SUPPORT_L3_SRC_DST) != 0 &&
+	    (types & HNS3_RSS_SUPPORT_FLOW_TYPE) == 0) {
+		hns3_err(hw, "IP or IP-TCP/UDP/SCTP packet type isn't specified, L3_SRC/DST_ONLY cannot be set.");
+		return false;
+	}
+
+	if (has_l4_src_dst && (types & ip_l4_mask) == 0) {
+		if (!has_ip_pkt) {
+			hns3_err(hw, "IP-TCP/UDP/SCTP packet type isn't specified, L4_SRC/DST_ONLY cannot be set.");
+			return false;
+		}
+		/*
+		 * For the case that the types has L4_SRC/DST_ONLY but hasn't
+		 * IP-TCP/UDP/SCTP packet type, this types is considered valid
+		 * if it also has IP packet type.
+		 */
+		hns3_warn(hw, "L4_SRC/DST_ONLY is ignored because of no including L4 packet.");
+	}
+
+	if ((types & ~HNS3_ETH_RSS_SUPPORT) != 0) {
+		final_types = types & HNS3_ETH_RSS_SUPPORT;
+		hns3_warn(hw, "set RSS types based on hardware support, requested:0x%" PRIx64 " configured:0x%" PRIx64 "",
+			  types, final_types);
+	}
+
+	return true;
 }
 
 uint64_t
-hns3_rss_calc_tuple_filed(struct hns3_hw *hw, uint64_t rss_hf)
+hns3_rss_calc_tuple_filed(uint64_t rss_hf)
 {
 	uint64_t l3_only_mask = RTE_ETH_RSS_L3_SRC_ONLY |
 				RTE_ETH_RSS_L3_DST_ONLY;
@@ -548,7 +576,6 @@ hns3_rss_calc_tuple_filed(struct hns3_hw *hw, uint64_t rss_hf)
 		    !has_l3_l4_only)
 			tuple |= hns3_set_tuple_table[i].rss_field;
 	}
-	hns3_rss_check_l3l4_types(hw, rss_hf);
 
 	return tuple;
 }
@@ -576,7 +603,7 @@ hns3_set_rss_tuple_by_rss_hf(struct hns3_hw *hw, uint64_t rss_hf)
 	uint64_t tuple_fields;
 	int ret;
 
-	tuple_fields = hns3_rss_calc_tuple_filed(hw, rss_hf);
+	tuple_fields = hns3_rss_calc_tuple_filed(rss_hf);
 	ret = hns3_set_rss_tuple_field(hw, tuple_fields);
 	if (ret != 0)
 		hns3_err(hw, "Update RSS flow types tuples failed, ret = %d",
@@ -611,6 +638,9 @@ hns3_dev_rss_hash_update(struct rte_eth_dev *dev,
 		return -EINVAL;
 	}
 
+	if (!hns3_check_rss_types_valid(hw, rss_hf))
+		return -EINVAL;
+
 	rte_spinlock_lock(&hw->lock);
 	ret = hns3_set_rss_tuple_by_rss_hf(hw, rss_hf);
 	if (ret)
diff --git a/drivers/net/hns3/hns3_rss.h b/drivers/net/hns3/hns3_rss.h
index d672481a14..415430a399 100644
--- a/drivers/net/hns3/hns3_rss.h
+++ b/drivers/net/hns3/hns3_rss.h
@@ -186,6 +186,7 @@ int hns3_set_rss_indir_table(struct hns3_hw *hw, uint16_t *indir,
 int hns3_rss_reset_indir_table(struct hns3_hw *hw);
 int hns3_config_rss(struct hns3_adapter *hns);
 void hns3_rss_uninit(struct hns3_adapter *hns);
+bool hns3_check_rss_types_valid(struct hns3_hw *hw, uint64_t types);
 int hns3_set_rss_tuple_by_rss_hf(struct hns3_hw *hw, uint64_t rss_hf);
 int hns3_set_rss_tuple_field(struct hns3_hw *hw, uint64_t tuple_fields);
 int hns3_get_rss_tuple_field(struct hns3_hw *hw, uint64_t *tuple_fields);
@@ -193,7 +194,7 @@ int hns3_rss_set_algo_key(struct hns3_hw *hw, uint8_t hash_algo,
 			  const uint8_t *key, uint8_t key_len);
 int hns3_rss_get_algo_key(struct hns3_hw *hw,  uint8_t *hash_algo,
 			  uint8_t *key, uint8_t key_len);
-uint64_t hns3_rss_calc_tuple_filed(struct hns3_hw *hw, uint64_t rss_hf);
+uint64_t hns3_rss_calc_tuple_filed(uint64_t rss_hf);
 int hns3_update_rss_algo_key(struct hns3_hw *hw, uint8_t hash_algo,
 			     uint8_t *key, uint8_t key_len);
 
-- 
2.23.0

