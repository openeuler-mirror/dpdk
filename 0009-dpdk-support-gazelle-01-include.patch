From bca7c742a8f956212c5ad9661b602676c71b7028 Mon Sep 17 00:00:00 2001
From: wuchangsheng <wuchangsheng2@huawei.com>
Date: Tue, 30 Mar 2021 16:24:55 +0800
Subject: [PATCH] dpdk-support-gazelle-01-include

---
 lib/librte_eal/common/include/rte_eal.h     | 10 ++-
 lib/librte_eal/common/include/rte_fbarray.h |  7 ++
 lib/librte_eal/common/include/rte_memory.h  | 20 +++++-
 lib/librte_ring/rte_ring.h                  | 75 +++++++++++++++++++++
 4 files changed, 108 insertions(+), 4 deletions(-)

diff --git a/lib/librte_eal/common/include/rte_eal.h b/lib/librte_eal/common/include/rte_eal.h
index 2f9ed29..ac1dc1d 100644
--- a/lib/librte_eal/common/include/rte_eal.h
+++ b/lib/librte_eal/common/include/rte_eal.h
@@ -485,9 +485,17 @@ rte_eal_mbuf_user_pool_ops(void);
  * @return
  *  The runtime directory path of DPDK
  */
-const char *
+char *
 rte_eal_get_runtime_dir(void);
 
+/****** APIs for libnet ******/
+char *rte_eal_sec_get_runtime_dir(const int sec_idx);
+struct rte_config *rte_eal_sec_get_configuration(const int sec_idx);
+struct internal_config *rte_eal_sec_get_internal_config(const int sec_idx);
+
+int rte_eal_sec_attach(int argc, char **argv);
+int rte_eal_sec_detach(const char *file_prefix, int length);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/librte_eal/common/include/rte_fbarray.h b/lib/librte_eal/common/include/rte_fbarray.h
index 6dccdbe..dffee1e 100644
--- a/lib/librte_eal/common/include/rte_fbarray.h
+++ b/lib/librte_eal/common/include/rte_fbarray.h
@@ -101,6 +101,10 @@ __rte_experimental
 int
 rte_fbarray_attach(struct rte_fbarray *arr);
 
+int
+rte_sec_fbarray_attach(struct rte_fbarray *arr,
+		const int switch_pri_and_sec, const int sec_idx);
+
 
 /**
  * Deallocate resources for an already allocated and correctly set up
@@ -123,6 +127,9 @@ __rte_experimental
 int
 rte_fbarray_destroy(struct rte_fbarray *arr);
 
+int
+rte_sec_fbarray_destroy(struct rte_fbarray *arr,
+		const int sec_idx);
 
 /**
  * Deallocate resources for an already allocated and correctly set up
diff --git a/lib/librte_eal/common/include/rte_memory.h b/lib/librte_eal/common/include/rte_memory.h
index 3d8d0bd..4dd6daa 100644
--- a/lib/librte_eal/common/include/rte_memory.h
+++ b/lib/librte_eal/common/include/rte_memory.h
@@ -152,7 +152,12 @@ rte_mem_iova2virt(rte_iova_t iova);
 __rte_experimental
 struct rte_memseg *
 rte_mem_virt2memseg(const void *virt, const struct rte_memseg_list *msl);
-
+/*
+__rte_experimental
+struct rte_memseg *
+rte_sec_mem_virt2memseg(const void *addr, const struct rte_memseg_list *msl, 
+		const struct rte_config *rte_cfg);
+*/
 /**
  * Get memseg list corresponding to virtual memory address.
  *
@@ -164,7 +169,11 @@ rte_mem_virt2memseg(const void *virt, const struct rte_memseg_list *msl);
 __rte_experimental
 struct rte_memseg_list *
 rte_mem_virt2memseg_list(const void *virt);
-
+/*
+__rte_experimental
+struct rte_memseg_list *
+rte_sec_mem_virt2memseg_list(const void *addr, const struct rte_config *rte_cfg);
+*/
 /**
  * Memseg walk function prototype.
  *
@@ -282,7 +291,12 @@ rte_memseg_list_walk(rte_memseg_list_walk_t func, void *arg);
 __rte_experimental
 int
 rte_memseg_walk_thread_unsafe(rte_memseg_walk_t func, void *arg);
-
+/*
+__rte_experimental
+int
+rte_sec_memseg_list_walk_thread_unsafe(rte_memseg_list_walk_t func, void *arg,
+		struct rte_config *rte_cfg);
+*/
 /**
  * Walk each VA-contiguous area without performing any locking.
  *
diff --git a/lib/librte_ring/rte_ring.h b/lib/librte_ring/rte_ring.h
index 2a9f768..0eb3a48 100644
--- a/lib/librte_ring/rte_ring.h
+++ b/lib/librte_ring/rte_ring.h
@@ -953,6 +953,81 @@ rte_ring_dequeue_burst(struct rte_ring *r, void **obj_table,
 				r->cons.single, available);
 }
 
+/****** APIs for libnet ******/
+static __rte_always_inline unsigned
+rte_ring_cn_dequeue_burst(struct rte_ring *r, void **obj_table, unsigned int n)
+{
+	const uint32_t old_head = r->prod.tail;
+	rte_smp_rmb();
+
+	const uint32_t entries = r->cons.head - old_head;
+	if (n > entries) {
+		n = entries;
+	}
+	if (unlikely(n == 0)) {
+		return 0;
+	}
+
+	r->prod.head = old_head + n;
+	rte_smp_rmb();
+
+	DEQUEUE_PTRS(r, &r[1], old_head, obj_table, n, void *);
+	return n;
+}
+
+static __rte_always_inline void
+rte_ring_cn_enqueue(struct rte_ring *r)
+{
+	rte_smp_wmb();
+	r->prod.tail = r->prod.head;
+}
+
+static __rte_always_inline unsigned
+rte_ring_en_dequeue_burst(struct rte_ring *r, void **obj_table, unsigned int n)
+{
+	const uint32_t old_tail = r->cons.tail;
+	rte_smp_rmb();
+
+	const uint32_t entries = r->prod.tail - old_tail;
+	if (n > entries) {
+		n = entries;
+	}
+	if (unlikely(n == 0)) {
+		return 0;
+	}
+
+	const uint32_t new_tail = old_tail + n;
+	rte_smp_rmb();
+
+	DEQUEUE_PTRS(r, &r[1], old_tail, obj_table, n, void *);
+	rte_smp_rmb();
+
+	r->cons.tail = new_tail;
+	return n;
+}
+
+static __rte_always_inline unsigned
+rte_ring_en_enqueue_bulk(struct rte_ring *r, void **obj_table, unsigned int n)
+{
+	const uint32_t capacity = r->capacity;
+	const uint32_t old_head = r->cons.head;
+	rte_smp_rmb();
+
+	const uint32_t entries = capacity + r->cons.tail - old_head;
+	if (n > entries) {
+		return 0;
+	}
+
+	const uint32_t new_head = old_head + n;
+	rte_smp_rmb();
+
+	ENQUEUE_PTRS(r, &r[1], old_head, obj_table, n, void *);
+	rte_smp_wmb();
+
+	r->cons.head = new_head;
+	return n;
+}
+
 #ifdef __cplusplus
 }
 #endif
-- 
2.23.0

