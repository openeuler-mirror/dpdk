From ab23196a30701353f626b099fc9c957bcd5bf2a0 Mon Sep 17 00:00:00 2001
From: wuchangsheng <wuchangsheng2@huawei.com>
Date: Tue, 30 Mar 2021 16:29:00 +0800
Subject: [PATCH] dpdk-support-gazelle-05-fbarray-hugepageinfo

---
 lib/librte_eal/common/eal_common_fbarray.c   | 106 ++++++++++++++++---
 lib/librte_eal/linux/eal/eal_hugepage_info.c |   2 +-
 2 files changed, 95 insertions(+), 13 deletions(-)

diff --git a/lib/librte_eal/common/eal_common_fbarray.c b/lib/librte_eal/common/eal_common_fbarray.c
index 1312f93..b611ffa 100644
--- a/lib/librte_eal/common/eal_common_fbarray.c
+++ b/lib/librte_eal/common/eal_common_fbarray.c
@@ -833,8 +833,9 @@ fail:
 	return -1;
 }
 
-int
-rte_fbarray_attach(struct rte_fbarray *arr)
+static int
+__rte_fbarray_attach(struct rte_fbarray *arr, const char *runtime_dir,
+		const struct internal_config *internal_cfg)
 {
 	struct mem_area *ma = NULL, *tmp = NULL;
 	size_t page_sz, mmap_len;
@@ -870,13 +871,15 @@ rte_fbarray_attach(struct rte_fbarray *arr)
 
 	mmap_len = calc_data_size(page_sz, arr->elt_sz, arr->len);
 
-	/* check the tailq - maybe user has already mapped this address space */
-	rte_spinlock_lock(&mem_area_lock);
+	if (!internal_cfg->pri_and_sec) {
+		/* check the tailq - maybe user has already mapped this address space */
+		rte_spinlock_lock(&mem_area_lock);
 
-	TAILQ_FOREACH(tmp, &mem_area_tailq, next) {
-		if (overlap(tmp, arr->data, mmap_len)) {
-			rte_errno = EEXIST;
-			goto fail;
+		TAILQ_FOREACH(tmp, &mem_area_tailq, next) {
+			if (overlap(tmp, arr->data, mmap_len)) {
+				rte_errno = EEXIST;
+				goto fail;
+			}
 		}
 	}
 
@@ -886,7 +889,7 @@ rte_fbarray_attach(struct rte_fbarray *arr)
 	if (data == NULL)
 		goto fail;
 
-	eal_get_fbarray_path(path, sizeof(path), arr->name);
+	eal_sec_get_fbarray_path(path, sizeof(path), arr->name, runtime_dir);
 
 	fd = open(path, O_RDWR);
 	if (fd < 0) {
@@ -903,16 +906,27 @@ rte_fbarray_attach(struct rte_fbarray *arr)
 	if (resize_and_map(fd, data, mmap_len))
 		goto fail;
 
+	if (internal_cfg->pri_and_sec) {
+		if (flock(fd, LOCK_UN)) {
+			rte_errno = errno;
+			goto fail;
+		}
+		close(fd);
+		fd = -1;
+	}
+
 	/* store our new memory area */
 	ma->addr = data;
 	ma->fd = fd; /* keep fd until detach/destroy */
 	ma->len = mmap_len;
 
-	TAILQ_INSERT_TAIL(&mem_area_tailq, ma, next);
+	if (!internal_cfg->pri_and_sec) {
+		TAILQ_INSERT_TAIL(&mem_area_tailq, ma, next);
 
-	/* we're done */
+		/* we're done */
 
-	rte_spinlock_unlock(&mem_area_lock);
+		rte_spinlock_unlock(&mem_area_lock);
+	}
 	return 0;
 fail:
 	if (data)
@@ -924,6 +938,30 @@ fail:
 	return -1;
 }
 
+int
+rte_fbarray_attach(struct rte_fbarray *arr)
+{
+	return __rte_fbarray_attach(arr, rte_eal_get_runtime_dir(), &internal_config);
+}
+
+int
+rte_sec_fbarray_attach(struct rte_fbarray *arr,
+		const int switch_pri_and_sec, const int sec_idx)
+{
+	struct internal_config *internal_cfg = NULL;
+	char *runtime_dir = NULL;
+
+	if (!switch_pri_and_sec) {
+		runtime_dir = rte_eal_get_runtime_dir();
+		internal_cfg = &internal_config;
+	} else {
+		runtime_dir = rte_eal_sec_get_runtime_dir(sec_idx);
+		internal_cfg = rte_eal_sec_get_internal_config(sec_idx);
+	}
+
+	return __rte_fbarray_attach(arr, runtime_dir, internal_cfg);
+}
+
 int
 rte_fbarray_detach(struct rte_fbarray *arr)
 {
@@ -1063,6 +1101,50 @@ out:
 	return ret;
 }
 
+int
+rte_sec_fbarray_destroy(struct rte_fbarray *arr,
+		const int sec_idx)
+{
+	int fd, ret;
+	size_t mmap_len;
+	char path[PATH_MAX];
+
+	if (arr == NULL) {
+		rte_errno = EINVAL;
+		return -1;
+	}
+
+	size_t page_sz = sysconf(_SC_PAGESIZE);
+
+	if (page_sz == (size_t)-1)
+		return -1;
+
+	mmap_len = calc_data_size(page_sz, arr->elt_sz, arr->len);
+	munmap(arr->data, mmap_len);
+
+	/* try deleting the file */
+	eal_sec_get_fbarray_path(path, sizeof(path), arr->name, rte_eal_sec_get_runtime_dir(sec_idx));
+	
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		RTE_LOG(ERR, EAL, "Could not open fbarray file: %s\n",
+			strerror(errno));
+		return -1;
+	}
+	if (flock(fd, LOCK_EX | LOCK_NB)) {
+		RTE_LOG(DEBUG, EAL, "Cannot destroy fbarray - another process is using it\n");
+		rte_errno = EBUSY;
+		ret = -1;
+	} else {
+		ret = 0;
+		unlink(path);
+		memset(arr, 0, sizeof(*arr));
+	}
+	close(fd);
+	
+	return ret;
+}
+
 void *
 rte_fbarray_get(const struct rte_fbarray *arr, unsigned int idx)
 {
diff --git a/lib/librte_eal/linux/eal/eal_hugepage_info.c b/lib/librte_eal/linux/eal/eal_hugepage_info.c
index 91a4fed..911acec 100644
--- a/lib/librte_eal/linux/eal/eal_hugepage_info.c
+++ b/lib/librte_eal/linux/eal/eal_hugepage_info.c
@@ -350,7 +350,7 @@ calc_num_pages(struct hugepage_info *hpi, struct dirent *dirent)
 	 */
 	total_pages = 0;
 	/* we also don't want to do this for legacy init */
-	if (!internal_config.legacy_mem)
+	if (!internal_config.legacy_mem || internal_config.map_perfect)
 		for (i = 0; i < rte_socket_count(); i++) {
 			int socket = rte_socket_id_by_idx(i);
 			unsigned int num_pages =
-- 
2.23.0

