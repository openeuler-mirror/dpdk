From a2524d07bf2f71c925d363fbb7fcfc6d7def57c4 Mon Sep 17 00:00:00 2001
From: Chengchang Tang <tangchengchang@huawei.com>
Date: Wed, 3 Feb 2021 20:23:52 +0800
Subject: [PATCH 038/189] net/hns3: fix stats flip overflow

Currently, statistics may overflow in some scenarios.

For example, if HW statistics are reset by stats reset operation,
but there are still a lot of residual packets exist in the HW
queues and these packets are error packets, flip may occurred
because the ipacket is obtained by subtracting the number of
software error packets from the number of HW received packets.

This patch verifies the calculation and returns 0 when overflow
may occur.

Fixes: 8839c5e202f3 ("net/hns3: support device stats")
Cc: stable@dpdk.org

Signed-off-by: Chengchang Tang <tangchengchang@huawei.com>
Signed-off-by: Lijun Ou <oulijun@huawei.com>
---
 drivers/net/hns3/hns3_stats.c | 21 +++++++++++++++++----
 1 file changed, 17 insertions(+), 4 deletions(-)

diff --git a/drivers/net/hns3/hns3_stats.c b/drivers/net/hns3/hns3_stats.c
index 3ba09e2..e0e40ca 100644
--- a/drivers/net/hns3/hns3_stats.c
+++ b/drivers/net/hns3/hns3_stats.c
@@ -554,8 +554,14 @@ hns3_stats_get(struct rte_eth_dev *eth_dev, struct rte_eth_stats *rte_stats)
 	}
 
 	rte_stats->oerrors = 0;
-	rte_stats->ipackets  = stats->rcb_rx_ring_pktnum_rcd -
-		rte_stats->ierrors;
+	/*
+	 * If HW statistics are reset by stats_reset, but a lot of residual
+	 * packets exist in the hardware queue and these packets are error
+	 * packets, flip overflow may occurred. So return 0 in this case.
+	 */
+	rte_stats->ipackets =
+		stats->rcb_rx_ring_pktnum_rcd > rte_stats->ierrors ?
+		stats->rcb_rx_ring_pktnum_rcd - rte_stats->ierrors : 0;
 	rte_stats->opackets  = stats->rcb_tx_ring_pktnum_rcd -
 		rte_stats->oerrors;
 	rte_stats->rx_nombuf = eth_dev->data->rx_mbuf_alloc_failed;
@@ -792,8 +798,15 @@ hns3_rxq_basic_stats_get(struct rte_eth_dev *dev, struct rte_eth_xstat *xstats,
 		rxq_stats = &rxq->basic_stats;
 		rxq_stats->errors = rxq->err_stats.l2_errors +
 					rxq->err_stats.pkt_len_errors;
-		rxq_stats->packets = stats->rcb_rx_ring_pktnum[i] -
-			rxq_stats->errors;
+		/*
+		 * If HW statistics are reset by stats_reset, but a lot of
+		 * residual packets exist in the hardware queue and these
+		 * packets are error packets, flip overflow may occurred.
+		 * So return 0 in this case.
+		 */
+		rxq_stats->packets =
+			stats->rcb_rx_ring_pktnum[i] > rxq_stats->errors ?
+			stats->rcb_rx_ring_pktnum[i] - rxq_stats->errors : 0;
 		rxq_stats->bytes = 0;
 		for (j = 0; j < HNS3_NUM_RXQ_BASIC_STATS; j++) {
 			val = (char *)rxq_stats +
-- 
2.7.4

