From 607756d19e218e01a780551473e3f7c6f3851d45 Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Tue, 31 Oct 2023 20:23:55 +0800
Subject: [PATCH 379/394] net/hns3: fix LRO offload to report

[ upstream commit a4b2c6815abd3e39daca2e2c93334b813e6a0be4 ]

Some network engines, like part of HIP09, may not support LRO
offload, but this offload capability is also reported to user.
So this patch determines whether driver reports this capability
based on the capabilities from firmware.

In addition, some network engines, like HIP08, always support LRO
offload and their firmware don't report this capability. So this
patch has to move getting revision ID codes to earlier stage and set
default capabilities for these network engines based on revision ID.

Fixes: ab2e2e344163 ("net/hns3: get device capability in primary process")
Fixes: f5ed7d99cf45 ("net/hns3: extract common function to obtain revision ID")
Cc: stable@dpdk.org

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Jie Hai <haijie1@huawei.com>
---
 drivers/net/hns3/hns3_cmd.c       | 17 ++++++++++++++++-
 drivers/net/hns3/hns3_cmd.h       |  1 +
 drivers/net/hns3/hns3_common.c    |  5 +++--
 drivers/net/hns3/hns3_dump.c      |  3 ++-
 drivers/net/hns3/hns3_ethdev.c    |  8 ++++----
 drivers/net/hns3/hns3_ethdev.h    |  1 +
 drivers/net/hns3/hns3_ethdev_vf.c |  8 ++++----
 drivers/net/hns3/hns3_rxtx.c      |  3 +++
 8 files changed, 34 insertions(+), 12 deletions(-)

diff --git a/drivers/net/hns3/hns3_cmd.c b/drivers/net/hns3/hns3_cmd.c
index 62c55f347f..a5c4c11dc8 100644
--- a/drivers/net/hns3/hns3_cmd.c
+++ b/drivers/net/hns3/hns3_cmd.c
@@ -513,6 +513,8 @@ hns3_parse_capability(struct hns3_hw *hw,
 		hns3_set_bit(hw->capability, HNS3_DEV_SUPPORT_TM_B, 1);
 	if (hns3_get_bit(caps, HNS3_CAPS_FC_AUTO_B))
 		hns3_set_bit(hw->capability, HNS3_DEV_SUPPORT_FC_AUTO_B, 1);
+	if (hns3_get_bit(caps, HNS3_CAPS_GRO_B))
+		hns3_set_bit(hw->capability, HNS3_DEV_SUPPORT_GRO_B, 1);
 }
 
 static uint32_t
@@ -547,6 +549,19 @@ hns3_set_dcb_capability(struct hns3_hw *hw)
 		hns3_set_bit(hw->capability, HNS3_DEV_SUPPORT_DCB_B, 1);
 }
 
+static void
+hns3_set_default_capability(struct hns3_hw *hw)
+{
+	hns3_set_dcb_capability(hw);
+
+	/*
+	 * The firmware of the network engines with HIP08 do not report some
+	 * capabilities, like GRO. Set default capabilities for it.
+	 */
+	if (hw->revision < PCI_REVISION_ID_HIP09_A)
+		hns3_set_bit(hw->capability, HNS3_DEV_SUPPORT_GRO_B, 1);
+}
+
 static int
 hns3_cmd_query_firmware_version_and_capability(struct hns3_hw *hw)
 {
@@ -565,7 +580,7 @@ hns3_cmd_query_firmware_version_and_capability(struct hns3_hw *hw)
 
 	hw->fw_version = rte_le_to_cpu_32(resp->firmware);
 
-	hns3_set_dcb_capability(hw);
+	hns3_set_default_capability(hw);
 
 	/*
 	 * Make sure mask the capability before parse capability because it
diff --git a/drivers/net/hns3/hns3_cmd.h b/drivers/net/hns3/hns3_cmd.h
index 3f2bb4fd29..79a8c1edad 100644
--- a/drivers/net/hns3/hns3_cmd.h
+++ b/drivers/net/hns3/hns3_cmd.h
@@ -323,6 +323,7 @@ enum HNS3_CAPS_BITS {
 	HNS3_CAPS_RAS_IMP_B,
 	HNS3_CAPS_RXD_ADV_LAYOUT_B = 15,
 	HNS3_CAPS_TM_B = 19,
+	HNS3_CAPS_GRO_B = 20,
 	HNS3_CAPS_FC_AUTO_B = 30,
 };
 
diff --git a/drivers/net/hns3/hns3_common.c b/drivers/net/hns3/hns3_common.c
index 5dec62cbfb..6b1aeaa41b 100644
--- a/drivers/net/hns3/hns3_common.c
+++ b/drivers/net/hns3/hns3_common.c
@@ -70,8 +70,7 @@ hns3_dev_infos_get(struct rte_eth_dev *eth_dev, struct rte_eth_dev_info *info)
 				 RTE_ETH_RX_OFFLOAD_SCATTER |
 				 RTE_ETH_RX_OFFLOAD_VLAN_STRIP |
 				 RTE_ETH_RX_OFFLOAD_VLAN_FILTER |
-				 RTE_ETH_RX_OFFLOAD_RSS_HASH |
-				 RTE_ETH_RX_OFFLOAD_TCP_LRO);
+				 RTE_ETH_RX_OFFLOAD_RSS_HASH);
 	info->tx_offload_capa = (RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM |
 				 RTE_ETH_TX_OFFLOAD_IPV4_CKSUM |
 				 RTE_ETH_TX_OFFLOAD_TCP_CKSUM |
@@ -99,6 +98,8 @@ hns3_dev_infos_get(struct rte_eth_dev *eth_dev, struct rte_eth_dev_info *info)
 
 	if (hns3_dev_get_support(hw, PTP))
 		info->rx_offload_capa |= RTE_ETH_RX_OFFLOAD_TIMESTAMP;
+	if (hns3_dev_get_support(hw, GRO))
+		info->rx_offload_capa |= RTE_ETH_RX_OFFLOAD_TCP_LRO;
 
 	info->rx_desc_lim = (struct rte_eth_desc_lim) {
 		.nb_max = HNS3_MAX_RING_DESC,
diff --git a/drivers/net/hns3/hns3_dump.c b/drivers/net/hns3/hns3_dump.c
index b6e8b621f5..8d4c4d0a3b 100644
--- a/drivers/net/hns3/hns3_dump.c
+++ b/drivers/net/hns3/hns3_dump.c
@@ -104,7 +104,8 @@ hns3_get_dev_feature_capability(FILE *file, struct hns3_hw *hw)
 		{HNS3_DEV_SUPPORT_RAS_IMP_B, "RAS IMP"},
 		{HNS3_DEV_SUPPORT_TM_B, "TM"},
 		{HNS3_DEV_SUPPORT_VF_VLAN_FLT_MOD_B, "VF VLAN FILTER MOD"},
-		{HNS3_DEV_SUPPORT_FC_AUTO_B, "FC AUTO"}
+		{HNS3_DEV_SUPPORT_FC_AUTO_B, "FC AUTO"},
+		{HNS3_DEV_SUPPORT_GRO_B, "GRO"}
 	};
 	uint32_t i;
 
diff --git a/drivers/net/hns3/hns3_ethdev.c b/drivers/net/hns3/hns3_ethdev.c
index 022696d204..2d4af9f3ea 100644
--- a/drivers/net/hns3/hns3_ethdev.c
+++ b/drivers/net/hns3/hns3_ethdev.c
@@ -2722,10 +2722,6 @@ hns3_get_capability(struct hns3_hw *hw)
 	struct hns3_pf *pf = &hns->pf;
 	int ret;
 
-	ret = hns3_get_pci_revision_id(hw, &hw->revision);
-	if (ret)
-		return ret;
-
 	ret = hns3_query_mac_stats_reg_num(hw);
 	if (ret)
 		return ret;
@@ -4582,6 +4578,10 @@ hns3_init_pf(struct rte_eth_dev *eth_dev)
 	/* Get hardware io base address from pcie BAR2 IO space */
 	hw->io_base = pci_dev->mem_resource[2].addr;
 
+	ret = hns3_get_pci_revision_id(hw, &hw->revision);
+	if (ret)
+		return ret;
+
 	/* Firmware command queue initialize */
 	ret = hns3_cmd_init_queue(hw);
 	if (ret) {
diff --git a/drivers/net/hns3/hns3_ethdev.h b/drivers/net/hns3/hns3_ethdev.h
index 0e8d043704..668f141e32 100644
--- a/drivers/net/hns3/hns3_ethdev.h
+++ b/drivers/net/hns3/hns3_ethdev.h
@@ -888,6 +888,7 @@ enum hns3_dev_cap {
 	HNS3_DEV_SUPPORT_TM_B,
 	HNS3_DEV_SUPPORT_VF_VLAN_FLT_MOD_B,
 	HNS3_DEV_SUPPORT_FC_AUTO_B,
+	HNS3_DEV_SUPPORT_GRO_B,
 };
 
 #define hns3_dev_get_support(hw, _name) \
diff --git a/drivers/net/hns3/hns3_ethdev_vf.c b/drivers/net/hns3/hns3_ethdev_vf.c
index 003071c6ff..ba4fe13c01 100644
--- a/drivers/net/hns3/hns3_ethdev_vf.c
+++ b/drivers/net/hns3/hns3_ethdev_vf.c
@@ -762,10 +762,6 @@ hns3vf_get_capability(struct hns3_hw *hw)
 {
 	int ret;
 
-	ret = hns3_get_pci_revision_id(hw, &hw->revision);
-	if (ret)
-		return ret;
-
 	if (hw->revision < PCI_REVISION_ID_HIP09_A) {
 		hns3_set_default_dev_specifications(hw);
 		hw->intr.mapping_mode = HNS3_INTR_MAPPING_VEC_RSV_ONE;
@@ -1418,6 +1414,10 @@ hns3vf_init_vf(struct rte_eth_dev *eth_dev)
 	/* Get hardware io base address from pcie BAR2 IO space */
 	hw->io_base = pci_dev->mem_resource[2].addr;
 
+	ret = hns3_get_pci_revision_id(hw, &hw->revision);
+	if (ret)
+		return ret;
+
 	/* Firmware command queue initialize */
 	ret = hns3_cmd_init_queue(hw);
 	if (ret) {
diff --git a/drivers/net/hns3/hns3_rxtx.c b/drivers/net/hns3/hns3_rxtx.c
index 3054d24080..8b7c469685 100644
--- a/drivers/net/hns3/hns3_rxtx.c
+++ b/drivers/net/hns3/hns3_rxtx.c
@@ -3125,6 +3125,9 @@ hns3_config_gro(struct hns3_hw *hw, bool en)
 	struct hns3_cmd_desc desc;
 	int ret;
 
+	if (!hns3_dev_get_support(hw, GRO))
+		return 0;
+
 	hns3_cmd_setup_basic_desc(&desc, HNS3_OPC_GRO_GENERIC_CONFIG, false);
 	req = (struct hns3_cfg_gro_status_cmd *)desc.data;
 
-- 
2.23.0

