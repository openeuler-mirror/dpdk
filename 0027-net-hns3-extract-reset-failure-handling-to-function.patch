From f13c07a570fabe362b55d2e3643b5ff96513597f Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Sat, 22 Jan 2022 09:51:33 +0800
Subject: [PATCH] net/hns3: extract reset failure handling to function

Extract a function to handle reset fail for clearer code logic.

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Acked-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_intr.c | 54 +++++++++++++++++++++---------------
 1 file changed, 32 insertions(+), 22 deletions(-)

diff --git a/drivers/net/hns3/hns3_intr.c b/drivers/net/hns3/hns3_intr.c
index 66dc509086..3ca2e1e338 100644
--- a/drivers/net/hns3/hns3_intr.c
+++ b/drivers/net/hns3/hns3_intr.c
@@ -2770,6 +2770,37 @@ hns3_reset_post(struct hns3_adapter *hns)
 	return -EIO;
 }
 
+static void
+hns3_reset_fail_handle(struct hns3_adapter *hns)
+{
+	struct hns3_hw *hw = &hns->hw;
+	struct timeval tv_delta;
+	struct timeval tv;
+
+	hns3_clear_reset_level(hw, &hw->reset.pending);
+	if (hns3_reset_err_handle(hns)) {
+		hw->reset.stage = RESET_STAGE_PREWAIT;
+		hns3_schedule_reset(hns);
+		return;
+	}
+
+	rte_spinlock_lock(&hw->lock);
+	if (hw->reset.mbuf_deferred_free) {
+		hns3_dev_release_mbufs(hns);
+		hw->reset.mbuf_deferred_free = false;
+	}
+	rte_spinlock_unlock(&hw->lock);
+	__atomic_store_n(&hns->hw.reset.resetting, 0, __ATOMIC_RELAXED);
+	hw->reset.stage = RESET_STAGE_NONE;
+	hns3_clock_gettime(&tv);
+	timersub(&tv, &hw->reset.start_time, &tv_delta);
+	hns3_warn(hw, "%s reset fail delta %" PRIu64 " ms time=%ld.%.6ld",
+		  reset_string[hw->reset.level],
+		  hns3_clock_calctime_ms(&tv_delta),
+		  tv.tv_sec, tv.tv_usec);
+	hw->reset.level = HNS3_NONE_RESET;
+}
+
 /*
  * There are three scenarios as follows:
  * When the reset is not in progress, the reset process starts.
@@ -2784,7 +2815,6 @@ int
 hns3_reset_process(struct hns3_adapter *hns, enum hns3_reset_level new_level)
 {
 	struct hns3_hw *hw = &hns->hw;
-	struct timeval tv_delta;
 	struct timeval tv;
 	int ret;
 
@@ -2843,27 +2873,7 @@ hns3_reset_process(struct hns3_adapter *hns, enum hns3_reset_level new_level)
 	if (ret == -EAGAIN)
 		return ret;
 err:
-	hns3_clear_reset_level(hw, &hw->reset.pending);
-	if (hns3_reset_err_handle(hns)) {
-		hw->reset.stage = RESET_STAGE_PREWAIT;
-		hns3_schedule_reset(hns);
-	} else {
-		rte_spinlock_lock(&hw->lock);
-		if (hw->reset.mbuf_deferred_free) {
-			hns3_dev_release_mbufs(hns);
-			hw->reset.mbuf_deferred_free = false;
-		}
-		rte_spinlock_unlock(&hw->lock);
-		__atomic_store_n(&hns->hw.reset.resetting, 0, __ATOMIC_RELAXED);
-		hw->reset.stage = RESET_STAGE_NONE;
-		hns3_clock_gettime(&tv);
-		timersub(&tv, &hw->reset.start_time, &tv_delta);
-		hns3_warn(hw, "%s reset fail delta %" PRIu64 " ms time=%ld.%.6ld",
-			  reset_string[hw->reset.level],
-			  hns3_clock_calctime_ms(&tv_delta),
-			  tv.tv_sec, tv.tv_usec);
-		hw->reset.level = HNS3_NONE_RESET;
-	}
+	hns3_reset_fail_handle(hns);
 
 	return -EIO;
 }
-- 
2.33.0

