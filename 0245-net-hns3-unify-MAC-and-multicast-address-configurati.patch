From 67d013484d9b521fd174e8485f7ebed333195bca Mon Sep 17 00:00:00 2001
From: Huisong Li <lihuisong@huawei.com>
Date: Fri, 22 Oct 2021 17:20:01 +0800
Subject: [PATCH 12/33] net/hns3: unify MAC and multicast address configuration

Currently, the interface logic for adding and deleting all MAC address
and multicast address in PF and VF driver is the same. This patch
extracts two common interfaces to configure them separately.

Signed-off-by: Huisong Li <lihuisong@huawei.com>
Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_ethdev.c    | 32 ++++++-------
 drivers/net/hns3/hns3_ethdev.h    |  2 +
 drivers/net/hns3/hns3_ethdev_vf.c | 77 +++----------------------------
 3 files changed, 25 insertions(+), 86 deletions(-)

diff --git a/drivers/net/hns3/hns3_ethdev.c b/drivers/net/hns3/hns3_ethdev.c
index 00016d58e..bdd29220a 100644
--- a/drivers/net/hns3/hns3_ethdev.c
+++ b/drivers/net/hns3/hns3_ethdev.c
@@ -1790,17 +1790,20 @@ hns3_set_default_mac_addr(struct rte_eth_dev *dev,
 	return ret;
 }
 
-static int
+int
 hns3_configure_all_mac_addr(struct hns3_adapter *hns, bool del)
 {
 	char mac_str[RTE_ETHER_ADDR_FMT_SIZE];
 	struct hns3_hw *hw = &hns->hw;
+	struct hns3_hw_ops *ops = &hw->ops;
 	struct rte_ether_addr *addr;
-	int err = 0;
-	int ret;
+	uint16_t mac_addrs_capa;
+	int ret = 0;
 	int i;
 
-	for (i = 0; i < HNS3_UC_MACADDR_NUM; i++) {
+	mac_addrs_capa =
+		hns->is_vf ? HNS3_VF_UC_MACADDR_NUM : HNS3_UC_MACADDR_NUM;
+	for (i = 0; i < mac_addrs_capa; i++) {
 		addr = &hw->data->mac_addrs[i];
 		if (rte_is_zero_ether_addr(addr))
 			continue;
@@ -1812,15 +1815,14 @@ hns3_configure_all_mac_addr(struct hns3_adapter *hns, bool del)
 			      ops->add_uc_mac_addr(hw, addr);
 
 		if (ret) {
-			err = ret;
 			hns3_ether_format_addr(mac_str, RTE_ETHER_ADDR_FMT_SIZE,
-					      addr);
-			hns3_err(hw, "failed to %s mac addr(%s) index:%d "
-				 "ret = %d.", del ? "remove" : "restore",
-				 mac_str, i, ret);
+					       addr);
+			hns3_err(hw, "failed to %s mac addr(%s) index:%d ret = %d.",
+				 del ? "remove" : "restore", mac_str, i, ret);
 		}
 	}
-	return err;
+
+	return ret;
 }
 
 static void
@@ -2151,14 +2153,13 @@ hns3_set_mc_mac_addr_list(struct rte_eth_dev *dev,
 	return 0;
 }
 
-static int
+int
 hns3_configure_all_mc_mac_addr(struct hns3_adapter *hns, bool del)
 {
 	char mac_str[RTE_ETHER_ADDR_FMT_SIZE];
 	struct hns3_hw *hw = &hns->hw;
 	struct rte_ether_addr *addr;
-	int err = 0;
-	int ret;
+	int ret = 0;
 	int i;
 
 	for (i = 0; i < hw->mc_addrs_num; i++) {
@@ -2170,14 +2171,13 @@ hns3_configure_all_mc_mac_addr(struct hns3_adapter *hns, bool del)
 		else
 			ret = hw->ops.add_mc_mac_addr(hw, addr);
 		if (ret) {
-			err = ret;
 			hns3_ether_format_addr(mac_str, RTE_ETHER_ADDR_FMT_SIZE,
 					      addr);
-			hns3_dbg(hw, "%s mc mac addr: %s failed for pf: ret = %d",
+			hns3_dbg(hw, "failed to %s mc mac addr: %s ret = %d",
 				 del ? "Remove" : "Restore", mac_str, ret);
 		}
 	}
-	return err;
+	return ret;
 }
 
 static int
diff --git a/drivers/net/hns3/hns3_ethdev.h b/drivers/net/hns3/hns3_ethdev.h
index 73947e194..942e8419c 100644
--- a/drivers/net/hns3/hns3_ethdev.h
+++ b/drivers/net/hns3/hns3_ethdev.h
@@ -1065,6 +1065,8 @@ void hns3vf_update_push_lsc_cap(struct hns3_hw *hw, bool supported);
 
 bool hns3_find_duplicate_mc_addr(struct hns3_hw *hw,
 				struct rte_ether_addr *mc_addr);
+int hns3_configure_all_mc_mac_addr(struct hns3_adapter *hns, bool del);
+int hns3_configure_all_mac_addr(struct hns3_adapter *hns, bool del);
 
 int hns3_restore_ptp(struct hns3_adapter *hns);
 int hns3_mbuf_dyn_rx_timestamp_register(struct rte_eth_dev *dev,
diff --git a/drivers/net/hns3/hns3_ethdev_vf.c b/drivers/net/hns3/hns3_ethdev_vf.c
index f9c5e3b4f..cce4d3450 100644
--- a/drivers/net/hns3/hns3_ethdev_vf.c
+++ b/drivers/net/hns3/hns3_ethdev_vf.c
@@ -323,40 +323,6 @@ hns3vf_set_default_mac_addr(struct rte_eth_dev *dev,
 	return ret;
 }
 
-static int
-hns3vf_configure_mac_addr(struct hns3_adapter *hns, bool del)
-{
-	char mac_str[RTE_ETHER_ADDR_FMT_SIZE];
-	struct hns3_hw *hw = &hns->hw;
-	struct hns3_hw_ops *ops = &hw->ops;
-	struct rte_ether_addr *addr;
-	int err = 0;
-	int ret;
-	int i;
-
-	for (i = 0; i < HNS3_VF_UC_MACADDR_NUM; i++) {
-		addr = &hw->data->mac_addrs[i];
-		if (rte_is_zero_ether_addr(addr))
-			continue;
-		if (rte_is_multicast_ether_addr(addr))
-			ret = del ? ops->del_mc_mac_addr(hw, addr) :
-			      ops->add_mc_mac_addr(hw, addr);
-		else
-			ret = del ? ops->del_uc_mac_addr(hw, addr) :
-			      ops->add_uc_mac_addr(hw, addr);
-
-		if (ret) {
-			err = ret;
-			hns3_ether_format_addr(mac_str, RTE_ETHER_ADDR_FMT_SIZE,
-					      addr);
-			hns3_err(hw, "failed to %s mac addr(%s) index:%d "
-				 "ret = %d.", del ? "remove" : "restore",
-				 mac_str, i, ret);
-		}
-	}
-	return err;
-}
-
 static int
 hns3vf_add_mc_mac_addr(struct hns3_hw *hw,
 		       struct rte_ether_addr *mac_addr)
@@ -511,35 +477,6 @@ hns3vf_set_mc_mac_addr_list(struct rte_eth_dev *dev,
 	return 0;
 }
 
-static int
-hns3vf_configure_all_mc_mac_addr(struct hns3_adapter *hns, bool del)
-{
-	char mac_str[RTE_ETHER_ADDR_FMT_SIZE];
-	struct hns3_hw *hw = &hns->hw;
-	struct rte_ether_addr *addr;
-	int err = 0;
-	int ret;
-	int i;
-
-	for (i = 0; i < hw->mc_addrs_num; i++) {
-		addr = &hw->mc_addrs[i];
-		if (!rte_is_multicast_ether_addr(addr))
-			continue;
-		if (del)
-			ret = hw->ops.del_mc_mac_addr(hw, addr);
-		else
-			ret = hw->ops.add_mc_mac_addr(hw, addr);
-		if (ret) {
-			err = ret;
-			hns3_ether_format_addr(mac_str, RTE_ETHER_ADDR_FMT_SIZE,
-					      addr);
-			hns3_err(hw, "Failed to %s mc mac addr: %s for vf: %d",
-				 del ? "Remove" : "Restore", mac_str, ret);
-		}
-	}
-	return err;
-}
-
 static int
 hns3vf_set_promisc_mode(struct hns3_hw *hw, bool en_bc_pmc,
 			bool en_uc_pmc, bool en_mc_pmc)
@@ -2077,7 +2014,7 @@ hns3vf_do_stop(struct hns3_adapter *hns)
 		hns3_dev_release_mbufs(hns);
 
 	if (__atomic_load_n(&hw->reset.disable_cmd, __ATOMIC_RELAXED) == 0) {
-		hns3vf_configure_mac_addr(hns, true);
+		hns3_configure_all_mac_addr(hns, true);
 		ret = hns3_reset_all_tqps(hns);
 		if (ret) {
 			hns3_err(hw, "failed to reset all queues ret = %d",
@@ -2172,7 +2109,7 @@ hns3vf_dev_close(struct rte_eth_dev *eth_dev)
 	hns3_reset_abort(hns);
 	hw->adapter_state = HNS3_NIC_CLOSED;
 	rte_eal_alarm_cancel(hns3vf_keep_alive_handler, eth_dev);
-	hns3vf_configure_all_mc_mac_addr(hns, true);
+	hns3_configure_all_mc_mac_addr(hns, true);
 	hns3vf_remove_all_vlan_table(hns);
 	hns3vf_uninit_vf(eth_dev);
 	hns3_free_all_queues(eth_dev);
@@ -2598,7 +2535,7 @@ hns3vf_stop_service(struct hns3_adapter *hns)
 	 * required to delete the entries.
 	 */
 	if (__atomic_load_n(&hw->reset.disable_cmd, __ATOMIC_RELAXED) == 0)
-		hns3vf_configure_all_mc_mac_addr(hns, true);
+		hns3_configure_all_mc_mac_addr(hns, true);
 	rte_spinlock_unlock(&hw->lock);
 
 	return 0;
@@ -2684,11 +2621,11 @@ hns3vf_restore_conf(struct hns3_adapter *hns)
 	if (ret)
 		return ret;
 
-	ret = hns3vf_configure_mac_addr(hns, false);
+	ret = hns3_configure_all_mac_addr(hns, false);
 	if (ret)
 		return ret;
 
-	ret = hns3vf_configure_all_mc_mac_addr(hns, false);
+	ret = hns3_configure_all_mc_mac_addr(hns, false);
 	if (ret)
 		goto err_mc_mac;
 
@@ -2729,9 +2666,9 @@ hns3vf_restore_conf(struct hns3_adapter *hns)
 	return 0;
 
 err_vlan_table:
-	hns3vf_configure_all_mc_mac_addr(hns, true);
+	hns3_configure_all_mc_mac_addr(hns, true);
 err_mc_mac:
-	hns3vf_configure_mac_addr(hns, true);
+	hns3_configure_all_mac_addr(hns, true);
 	return ret;
 }
 
-- 
2.33.0

