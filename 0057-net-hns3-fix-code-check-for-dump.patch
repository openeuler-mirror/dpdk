From d2c737bb909c52de76246d9c74944d96c5e7792f Mon Sep 17 00:00:00 2001
From: "Min Hu (Connor)" <humin29@huawei.com>
Date: Thu, 31 Mar 2022 15:59:51 +0800
Subject: [PATCH 12/13] net/hns3: fix code check for dump

This patch fix code check for dump, making it more readable.

Signed-off-by: Min Hu (Connor) <humin29@huawei.com>
---
 drivers/net/hns3/hns3_dump.c      | 341 +++++++++++++++---------------
 drivers/net/hns3/hns3_dump.h      |  10 +
 drivers/net/hns3/hns3_ethdev.c    |   1 +
 drivers/net/hns3/hns3_ethdev.h    |   3 +-
 drivers/net/hns3/hns3_ethdev_vf.c |   1 +
 5 files changed, 187 insertions(+), 169 deletions(-)
 create mode 100644 drivers/net/hns3/hns3_dump.h

diff --git a/drivers/net/hns3/hns3_dump.c b/drivers/net/hns3/hns3_dump.c
index d9c1879f74..3a30a585c5 100644
--- a/drivers/net/hns3/hns3_dump.c
+++ b/drivers/net/hns3/hns3_dump.c
@@ -2,37 +2,41 @@
  * Copyright(C) 2022 HiSilicon Limited
  */
 
-#include <rte_kvargs.h>
-#include <rte_bus_pci.h>
-#include <ethdev_pci.h>
-#include <rte_pci.h>
+#include <rte_malloc.h>
 
+#include "hns3_ethdev.h"
 #include "hns3_common.h"
-#include "hns3_logs.h"
-#include "hns3_regs.h"
 #include "hns3_rxtx.h"
+#include "hns3_regs.h"
+#include "hns3_logs.h"
+#include "hns3_dump.h"
 
 static const char *
-hns3_get_adapter_state_name(uint32_t state)
+hns3_get_adapter_state_name(enum hns3_adapter_state state)
 {
-	static const char * const state_name[] = {
-		"UNINITIALIZED",
-		"INITIALIZED",
-		"CONFIGURING",
-		"CONFIGURED",
-		"STARTING",
-		"STARTED",
-		"STOPPING",
-		"CLOSING",
-		"CLOSED",
-		"REMOVED",
-		"NSTATES"
+	const struct {
+		enum hns3_adapter_state state;
+		const char *name;
+	} adapter_state_name[] = {
+		{HNS3_NIC_UNINITIALIZED, "UNINITIALIZED"},
+		{HNS3_NIC_INITIALIZED, "INITIALIZED"},
+		{HNS3_NIC_CONFIGURING, "CONFIGURING"},
+		{HNS3_NIC_CONFIGURED, "CONFIGURED"},
+		{HNS3_NIC_STARTING, "STARTING"},
+		{HNS3_NIC_STARTED, "STARTED"},
+		{HNS3_NIC_STOPPING, "STOPPING"},
+		{HNS3_NIC_CLOSING, "CLOSING"},
+		{HNS3_NIC_CLOSED, "CLOSED"},
+		{HNS3_NIC_REMOVED, "REMOVED"},
+		{HNS3_NIC_NSTATES, "NSTATES"},
 	};
+	uint32_t i;
 
-	if (state < RTE_DIM(state_name))
-		return state_name[state];
-	else
-		return "unknown";
+	for (i = 0; i < RTE_DIM(adapter_state_name); i++)
+		if (state == adapter_state_name[i].state)
+			return adapter_state_name[i].name;
+
+	return "Unknown";
 }
 
 static const char *
@@ -79,32 +83,36 @@ hns3_get_dev_mac_info(FILE *file, struct hns3_adapter *hns)
 static void
 hns3_get_dev_feature_capability(FILE *file, struct hns3_hw *hw)
 {
-	const char * const caps_name[] = {
-		"DCB",
-		"COPPER",
-		"FD QUEUE REGION",
-		"PTP",
-		"TX PUSH",
-		"INDEP TXRX",
-		"STASH",
-		"SIMPLE BD",
-		"RXD Advanced Layout",
-		"OUTER UDP CKSUM",
-		"RAS IMP",
-		"TM",
+	const struct {
+		enum hns3_dev_cap cap;
+		const char *name;
+	} caps_name[] = {
+		{HNS3_DEV_SUPPORT_DCB_B, "DCB"},
+		{HNS3_DEV_SUPPORT_COPPER_B, "COPPER"},
+		{HNS3_DEV_SUPPORT_FD_QUEUE_REGION_B, "FD QUEUE REGION"},
+		{HNS3_DEV_SUPPORT_PTP_B, "PTP"},
+		{HNS3_DEV_SUPPORT_TX_PUSH_B, "TX PUSH"},
+		{HNS3_DEV_SUPPORT_INDEP_TXRX_B, "INDEP TXRX"},
+		{HNS3_DEV_SUPPORT_STASH_B, "STASH"},
+		{HNS3_DEV_SUPPORT_SIMPLE_BD_B, "SIMPLE BD"},
+		{HNS3_DEV_SUPPORT_RXD_ADV_LAYOUT_B, "RXD Advanced Layout"},
+		{HNS3_DEV_SUPPORT_OUTER_UDP_CKSUM_B, "OUTER UDP CKSUM"},
+		{HNS3_DEV_SUPPORT_RAS_IMP_B, "RAS IMP"},
+		{HNS3_DEV_SUPPORT_TM_B, "TM"},
 	};
 	uint32_t i;
 
 	fprintf(file, "  - Dev Capability:\n");
 	for (i = 0; i < RTE_DIM(caps_name); i++)
-		fprintf(file, "\t  -- support %s: %s\n", caps_name[i],
-			hw->capability & BIT(i) ? "yes" : "no");
+		fprintf(file, "\t  -- support %s: %s\n", caps_name[i].name,
+			hns3_get_bit(hw->capability, caps_name[i].cap) ? "Yes" :
+									 "No");
 }
 
 static const char *
 hns3_get_fdir_tuple_name(uint32_t index)
 {
-	static const char * const tuple_name[] = {
+	const char * const tuple_name[] = {
 		"outer_dst_mac",
 		"outer_src_mac",
 		"outer_vlan_1st_tag",
@@ -145,10 +153,8 @@ hns3_get_fdir_tuple_name(uint32_t index)
 static void
 hns3_get_fdir_basic_info(FILE *file, struct hns3_pf *pf)
 {
-#define TMPBUF_SIZE		2048
-#define PERLINE_TUPLE_NAMES	4
+#define HNS3_PERLINE_TUPLE_NAME_LEN	4
 	struct hns3_fd_cfg *fdcfg = &pf->fdir.fd_cfg;
-	char tmpbuf[TMPBUF_SIZE] = {0};
 	uint32_t i, count = 0;
 
 	fprintf(file, "  - Fdir Info:\n");
@@ -171,17 +177,15 @@ hns3_get_fdir_basic_info(FILE *file, struct hns3_pf *pf)
 	for (i = 0; i < MAX_TUPLE; i++) {
 		if (!(fdcfg->key_cfg[HNS3_FD_STAGE_1].tuple_active & BIT(i)))
 			continue;
-		if (count % PERLINE_TUPLE_NAMES == 0)
+		if (count % HNS3_PERLINE_TUPLE_NAME_LEN == 0)
 			fprintf(file, "\t      ");
 		fprintf(file, " %s", hns3_get_fdir_tuple_name(i));
 		count++;
-		if (count % PERLINE_TUPLE_NAMES == 0)
+		if (count % HNS3_PERLINE_TUPLE_NAME_LEN == 0)
 			fprintf(file, "\n");
 	}
-	if (count % PERLINE_TUPLE_NAMES)
+	if (count % HNS3_PERLINE_TUPLE_NAME_LEN)
 		fprintf(file, "\n");
-
-	fprintf(file, "%s", tmpbuf);
 }
 
 static void
@@ -220,99 +224,94 @@ hns3_get_device_basic_info(FILE *file, struct rte_eth_dev *dev)
 		dev->data->dev_conf.intr_conf.rxq);
 }
 
-/*
- * Note: caller must make sure queue_id < nb_queues
- *       nb_queues = RTE_MAX(eth_dev->data->nb_rx_queues,
- *                           eth_dev->data->nb_tx_queues)
- */
 static struct hns3_rx_queue *
-hns3_get_rx_queue(struct rte_eth_dev *dev, uint32_t queue_id)
+hns3_get_rx_queue(struct rte_eth_dev *dev)
 {
-	struct hns3_adapter *hns = dev->data->dev_private;
-	struct hns3_hw *hw = &hns->hw;
-	uint32_t offset;
+	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
+	struct hns3_rx_queue *rxq;
+	uint32_t queue_id;
 	void **rx_queues;
 
-	if (queue_id < dev->data->nb_rx_queues) {
+	for (queue_id = 0; queue_id < dev->data->nb_rx_queues; queue_id++) {
 		rx_queues = dev->data->rx_queues;
-		offset = queue_id;
-	} else {
-		/*
-		 * For kunpeng930, fake queue is not exist. But since the queues
-		 * are usually accessd in pairs, this branch may still exist.
-		 */
-		if (hns3_dev_get_support(hw, INDEP_TXRX))
+		if (rx_queues == NULL || rx_queues[queue_id] == NULL) {
+			hns3_err(hw, "detect rx_queues is NULL!\n");
 			return NULL;
+		}
 
-		rx_queues = hw->fkq_data.rx_queues;
-		offset = queue_id - dev->data->nb_rx_queues;
-	}
+		rxq = (struct hns3_rx_queue *)rx_queues[queue_id];
+		if (rxq->rx_deferred_start)
+			continue;
 
-	if (rx_queues != NULL && rx_queues[offset] != NULL)
-		return rx_queues[offset];
+		return rx_queues[queue_id];
+	}
 
-	hns3_err(hw, "Detect rx_queues is NULL!\n");
 	return NULL;
 }
 
-/*
- * Note: caller must make sure queue_id < nb_queues
- *       nb_queues = RTE_MAX(eth_dev->data->nb_rx_queues,
- *                           eth_dev->data->nb_tx_queues)
- */
 static struct hns3_tx_queue *
-hns3_get_tx_queue(struct rte_eth_dev *dev, uint32_t queue_id)
+hns3_get_tx_queue(struct rte_eth_dev *dev)
 {
-	struct hns3_adapter *hns = dev->data->dev_private;
-	struct hns3_hw *hw = &hns->hw;
-	uint32_t offset;
+	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
+	struct hns3_tx_queue *txq;
+	uint32_t queue_id;
 	void **tx_queues;
 
-	if (queue_id < dev->data->nb_tx_queues) {
+	for (queue_id = 0; queue_id < dev->data->nb_tx_queues; queue_id++) {
 		tx_queues = dev->data->tx_queues;
-		offset = queue_id;
-	} else {
-		/*
-		 * For kunpeng930, fake queue is not exist. But since the queues
-		 * are usually accessd in pairs, this branch may still exist.
-		 */
-		if (hns3_dev_get_support(hw, INDEP_TXRX))
+		if (tx_queues == NULL || tx_queues[queue_id] == NULL) {
+			hns3_err(hw, "detect tx_queues is NULL!\n");
 			return NULL;
-		tx_queues = hw->fkq_data.tx_queues;
-		offset = queue_id - dev->data->nb_tx_queues;
-	}
+		}
 
-	if (tx_queues != NULL && tx_queues[offset] != NULL)
-		return tx_queues[offset];
+		txq = (struct hns3_tx_queue *)tx_queues[queue_id];
+		if (txq->tx_deferred_start)
+			continue;
+
+		return tx_queues[queue_id];
+	}
 
-	hns3_err(hw, "Detect tx_queues is NULL!\n");
 	return NULL;
 }
 
 static void
 hns3_get_rxtx_fake_queue_info(FILE *file, struct rte_eth_dev *dev)
 {
-	struct hns3_adapter *hns = dev->data->dev_private;
-	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(hns);
+	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
 	struct hns3_rx_queue *rxq;
 	struct hns3_tx_queue *txq;
-	uint32_t queue_id;
+	uint32_t queue_id = 0;
+	void **rx_queues;
+	void **tx_queues;
 
-	if (dev->data->nb_rx_queues != dev->data->nb_tx_queues &&
-	    !hns3_dev_get_support(hw, INDEP_TXRX)) {
-		queue_id = RTE_MIN(dev->data->nb_rx_queues,
-				   dev->data->nb_tx_queues);
-		rxq = hns3_get_rx_queue(dev, queue_id);
-		if (rxq == NULL)
+	if (hns3_dev_get_support(hw, INDEP_TXRX))
+		return;
+
+	if (dev->data->nb_rx_queues < dev->data->nb_tx_queues) {
+		rx_queues = hw->fkq_data.rx_queues;
+		if (rx_queues == NULL || rx_queues[queue_id] == NULL) {
+			hns3_err(hw, "detect rx_queues is NULL!\n");
 			return;
-		txq = hns3_get_tx_queue(dev, queue_id);
-		if (txq == NULL)
+		}
+		rxq = (struct hns3_rx_queue *)rx_queues[queue_id];
+
+		fprintf(file,
+			"\t  -- first fake_queue info:\n"
+			"\t       Rx: port=%u nb_desc=%u free_thresh=%u\n",
+			rxq->port_id, rxq->nb_rx_desc, rxq->rx_free_thresh);
+	} else if (dev->data->nb_rx_queues > dev->data->nb_tx_queues) {
+		tx_queues = hw->fkq_data.tx_queues;
+		queue_id = 0;
+
+		if (tx_queues == NULL || tx_queues[queue_id] == NULL) {
+			hns3_err(hw, "detect tx_queues is NULL!\n");
 			return;
+		}
+		txq = (struct hns3_tx_queue *)tx_queues[queue_id];
+
 		fprintf(file,
-			"\t  -- first fake_queue rxtx info:\n"
-			"\t       Rx: port=%u nb_desc=%u free_thresh=%u\n"
-			"\t       Tx: port=%u nb_desc=%u\n",
-			rxq->port_id, rxq->nb_rx_desc, rxq->rx_free_thresh,
+			"\t  -- first fake_queue info:\n"
+			"\t	  Tx: port=%u nb_desc=%u\n",
 			txq->port_id, txq->nb_tx_desc);
 	}
 }
@@ -321,7 +320,7 @@ static void
 hns3_get_queue_enable_state(struct hns3_hw *hw, uint32_t *queue_state,
 			    uint32_t nb_queues, bool is_rxq)
 {
-#define STATE_SIZE (sizeof(*queue_state) * CHAR_BIT)
+#define HNS3_QUEUE_NUM_PER_STATS (sizeof(*queue_state) * HNS3_UINT8_BIT)
 	uint32_t queue_en_reg;
 	uint32_t reg_offset;
 	uint32_t state;
@@ -334,28 +333,28 @@ hns3_get_queue_enable_state(struct hns3_hw *hw, uint32_t *queue_state,
 		if (hns3_dev_get_support(hw, INDEP_TXRX))
 			state = state && hns3_read_dev(hw, reg_offset +
 						       queue_en_reg);
-		hns3_set_bit(queue_state[i / STATE_SIZE],
-				i % STATE_SIZE, state);
+		hns3_set_bit(queue_state[i / HNS3_QUEUE_NUM_PER_STATS],
+				i % HNS3_QUEUE_NUM_PER_STATS, state);
 	}
 }
 
 static void
 hns3_print_queue_state_perline(FILE *file, const uint32_t *queue_state,
-				uint32_t nb_queues, uint32_t line_num)
+			       uint32_t nb_queues, uint32_t line_num)
 {
-#define NUM_QUEUE_PER_LINE (sizeof(*queue_state) * CHAR_BIT)
-	uint32_t qid = line_num * NUM_QUEUE_PER_LINE;
-	uint32_t j;
+#define HNS3_NUM_QUEUE_PER_LINE (sizeof(*queue_state) * HNS3_UINT8_BIT)
+	uint32_t id = line_num * HNS3_NUM_QUEUE_PER_LINE;
+	uint32_t i;
 
-	for (j = 0; j < NUM_QUEUE_PER_LINE; j++) {
-		fprintf(file, "%1lx", hns3_get_bit(queue_state[line_num], j));
+	for (i = 0; i < HNS3_NUM_QUEUE_PER_LINE; i++) {
+		fprintf(file, "%1lx", hns3_get_bit(queue_state[line_num], i));
 
-		if (qid % CHAR_BIT == CHAR_BIT - 1) {
+		if (id % HNS3_UINT8_BIT == HNS3_UINT8_BIT - 1) {
 			fprintf(file, "%s",
-				j == NUM_QUEUE_PER_LINE - 1 ? "\n" : ":");
+				i == HNS3_NUM_QUEUE_PER_LINE - 1 ? "\n" : ":");
 		}
-		qid++;
-		if (qid >= nb_queues) {
+		id++;
+		if (id >= nb_queues) {
 			fprintf(file, "\n");
 			break;
 		}
@@ -364,23 +363,17 @@ hns3_print_queue_state_perline(FILE *file, const uint32_t *queue_state,
 
 static void
 hns3_display_queue_enable_state(FILE *file, const uint32_t *queue_state,
-				 uint32_t nb_queues, bool is_rxq)
+				uint32_t nb_queues, bool is_rxq)
 {
-#define NUM_QUEUE_PER_LINE (sizeof(*queue_state) * CHAR_BIT)
+#define HNS3_NUM_QUEUE_PER_LINE (sizeof(*queue_state) * HNS3_UINT8_BIT)
 	uint32_t i;
 
-	if (nb_queues == 0) {
-		fprintf(file, "\t       %s queue number is 0\n",
-				is_rxq ? "Rx" : "Tx");
-		return;
-	}
-
 	fprintf(file, "\t       %s queue id | enable state bitMap\n",
 			is_rxq ? "Rx" : "Tx");
 
-	for (i = 0; i < (nb_queues - 1) / NUM_QUEUE_PER_LINE + 1; i++) {
-		uint32_t line_end = (i + 1) * NUM_QUEUE_PER_LINE - 1;
-		uint32_t line_start = i * NUM_QUEUE_PER_LINE;
+	for (i = 0; i < (nb_queues - 1) / HNS3_NUM_QUEUE_PER_LINE + 1; i++) {
+		uint32_t line_end = (i + 1) * HNS3_NUM_QUEUE_PER_LINE - 1;
+		uint32_t line_start = i * HNS3_NUM_QUEUE_PER_LINE;
 		fprintf(file, "\t       %04u - %04u | ", line_start,
 			nb_queues - 1 > line_end ? line_end : nb_queues - 1);
 
@@ -391,16 +384,28 @@ hns3_display_queue_enable_state(FILE *file, const uint32_t *queue_state,
 static void
 hns3_get_rxtx_queue_enable_state(FILE *file, struct rte_eth_dev *dev)
 {
-#define MAX_TQP_NUM 1280
-#define QUEUE_BITMAP_SIZE (MAX_TQP_NUM / 32)
 	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
-	uint32_t rx_queue_state[QUEUE_BITMAP_SIZE] = {0};
-	uint32_t tx_queue_state[QUEUE_BITMAP_SIZE] = {0};
+	uint32_t *rx_queue_state;
+	uint32_t *tx_queue_state;
 	uint32_t nb_rx_queues;
 	uint32_t nb_tx_queues;
+	uint32_t bitmap_size;
+
+	bitmap_size = (hw->tqps_num * sizeof(uint32_t) + HNS3_UINT32_BIT) /
+			HNS3_UINT32_BIT;
+	rx_queue_state = (uint32_t *)rte_zmalloc(NULL, bitmap_size, 0);
+	tx_queue_state = (uint32_t *)rte_zmalloc(NULL, bitmap_size, 0);
 
 	nb_rx_queues = dev->data->nb_rx_queues;
 	nb_tx_queues = dev->data->nb_tx_queues;
+	if (nb_rx_queues == 0) {
+		fprintf(file, "\t  -- Rx queue number is 0\n");
+		return;
+	}
+	if (nb_tx_queues == 0) {
+		fprintf(file, "\t  -- Tx queue number is 0\n");
+		return;
+	}
 
 	fprintf(file, "\t  -- enable state:\n");
 	hns3_get_queue_enable_state(hw, rx_queue_state, nb_rx_queues, true);
@@ -410,6 +415,8 @@ hns3_get_rxtx_queue_enable_state(FILE *file, struct rte_eth_dev *dev)
 	hns3_get_queue_enable_state(hw, tx_queue_state, nb_tx_queues, false);
 	hns3_display_queue_enable_state(file, tx_queue_state, nb_tx_queues,
 					 false);
+	rte_free(rx_queue_state);
+	rte_free(tx_queue_state);
 }
 
 static void
@@ -417,12 +424,11 @@ hns3_get_rxtx_queue_info(FILE *file, struct rte_eth_dev *dev)
 {
 	struct hns3_rx_queue *rxq;
 	struct hns3_tx_queue *txq;
-	uint32_t queue_id = 0;
 
-	rxq = hns3_get_rx_queue(dev, queue_id);
+	rxq = hns3_get_rx_queue(dev);
 	if (rxq == NULL)
 		return;
-	txq = hns3_get_tx_queue(dev, queue_id);
+	txq = hns3_get_tx_queue(dev);
 	if (txq == NULL)
 		return;
 	fprintf(file, "  - Rx/Tx Queue Info:\n");
@@ -462,8 +468,8 @@ hns3_get_vlan_rx_offload_cfg(FILE *file, struct hns3_hw *hw)
 	ret = hns3_cmd_send(hw, &desc, 1);
 	if (ret != 0) {
 		hns3_err(hw,
-			"NIC IMP exec ret=%d desc_num=%d optcode=0x%x!",
-			ret, 1, rte_le_to_cpu_16(desc.opcode));
+			 "NIC firmware exec ret=%d optcode=0x%x!", ret,
+			 rte_le_to_cpu_16(desc.opcode));
 		return ret;
 	}
 
@@ -551,7 +557,7 @@ hns3_get_vlan_tx_offload_cfg(FILE *file, struct hns3_hw *hw)
 	ret = hns3_cmd_send(hw, &desc, 1);
 	if (ret != 0) {
 		hns3_err(hw,
-			"NIC IMP exec ret=%d desc_num=%d optcode=0x%x!",
+			"NIC firmware exec ret=%d desc_num=%d optcode=0x%x!",
 			ret, 1, rte_le_to_cpu_16(desc.opcode));
 		return ret;
 	}
@@ -564,8 +570,8 @@ hns3_get_vlan_tx_offload_cfg(FILE *file, struct hns3_hw *hw)
 static void
 hns3_get_port_pvid_info(FILE *file, struct hns3_hw *hw)
 {
-	fprintf(file, "\t  -- pvid status: %s\n",
-		hw->port_base_vlan_cfg.state ? "on" : "off");
+	fprintf(file, "  - pvid status: %s\n",
+		hw->port_base_vlan_cfg.state ? "On" : "Off");
 }
 
 static void
@@ -581,8 +587,6 @@ hns3_get_vlan_config_info(FILE *file, struct hns3_hw *hw)
 	ret = hns3_get_vlan_tx_offload_cfg(file, hw);
 	if (ret < 0)
 		return;
-
-	hns3_get_port_pvid_info(file, hw);
 }
 
 static void
@@ -592,7 +596,7 @@ hns3_get_tm_conf_shaper_info(FILE *file, struct hns3_tm_conf *conf)
 		&conf->shaper_profile_list;
 	struct hns3_tm_shaper_profile *shaper_profile;
 
-	if (!conf->nb_shaper_profile)
+	if (conf->nb_shaper_profile == 0)
 		return;
 
 	fprintf(file, "  shaper_profile:\n");
@@ -608,7 +612,7 @@ hns3_get_tm_conf_shaper_info(FILE *file, struct hns3_tm_conf *conf)
 static void
 hns3_get_tm_conf_port_node_info(FILE *file, struct hns3_tm_conf *conf)
 {
-	if (!conf->root)
+	if (conf->root == NULL)
 		return;
 
 	fprintf(file,
@@ -627,7 +631,7 @@ hns3_get_tm_conf_tc_node_info(FILE *file, struct hns3_tm_conf *conf)
 	struct hns3_tm_node *tm_node;
 	uint32_t tidx;
 
-	if (!conf->nb_tc_node)
+	if (conf->nb_tc_node == 0)
 		return;
 
 	fprintf(file, "  tc_node: \n");
@@ -658,29 +662,28 @@ hns3_get_tm_conf_queue_format_info(FILE *file, struct hns3_tm_node **queue_node,
 				   uint32_t *queue_node_tc,
 				   uint32_t nb_tx_queues)
 {
-#define PERLINE_QUEUES	32
-#define PERLINE_STRIDE	8
-#define LINE_BUF_SIZE	1024
-	uint32_t i, j, line_num, start_queue, end_queue;
-	char tmpbuf[LINE_BUF_SIZE] = {0};
+#define HNS3_PERLINE_QUEUES	32
+#define HNS3_PERLINE_STRIDE	8
+	uint32_t i, j, line_num, start_queue_id, end_queue_id;
 
-	line_num = (nb_tx_queues + PERLINE_QUEUES - 1) / PERLINE_QUEUES;
+	line_num = (nb_tx_queues + HNS3_PERLINE_QUEUES - 1) /
+		HNS3_PERLINE_QUEUES;
 	for (i = 0; i < line_num; i++) {
-		start_queue = i * PERLINE_QUEUES;
-		end_queue = (i + 1) * PERLINE_QUEUES - 1;
-		if (end_queue > nb_tx_queues - 1)
-			end_queue = nb_tx_queues - 1;
-		fprintf(file, "    %04u - %04u | ", start_queue, end_queue);
-		for (j = start_queue; j < nb_tx_queues; j++) {
-			if (j >= end_queue + 1)
+		start_queue_id = i * HNS3_PERLINE_QUEUES;
+		end_queue_id = (i + 1) * HNS3_PERLINE_QUEUES - 1;
+		if (end_queue_id > nb_tx_queues - 1)
+			end_queue_id = nb_tx_queues - 1;
+		fprintf(file, "    %04u - %04u | ", start_queue_id,
+			end_queue_id);
+		for (j = start_queue_id; j < nb_tx_queues; j++) {
+			if (j >= end_queue_id + 1)
 				break;
-			if (j > start_queue && j % PERLINE_STRIDE == 0)
+			if (j > start_queue_id && j % HNS3_PERLINE_STRIDE == 0)
 				fprintf(file, ":");
 			fprintf(file, "%u",
 				queue_node[j] ? queue_node_tc[j] :
 				HNS3_MAX_TC_NUM);
 		}
-		fprintf(file, "%s\n", tmpbuf);
 	}
 }
 
@@ -694,7 +697,7 @@ hns3_get_tm_conf_queue_node_info(FILE *file, struct hns3_tm_conf *conf,
 	uint32_t queue_node_tc[nb_queue_node];
 	struct hns3_tm_node *tm_node;
 
-	if (!conf->nb_queue_node)
+	if (conf->nb_queue_node == 0)
 		return;
 
 	fprintf(file,
@@ -720,9 +723,13 @@ hns3_get_tm_conf_queue_node_info(FILE *file, struct hns3_tm_conf *conf,
 static void
 hns3_get_tm_conf_info(FILE *file, struct rte_eth_dev *dev)
 {
+	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
 	struct hns3_pf *pf = HNS3_DEV_PRIVATE_TO_PF(dev->data->dev_private);
 	struct hns3_tm_conf *conf = &pf->tm_conf;
 
+	if (!hns3_dev_get_support(hw, TM))
+		return;
+
 	fprintf(file, "  - TM config info:\n");
 	fprintf(file,
 		"\t  -- nb_leaf_nodes_max=%u nb_nodes_max=%u\n"
@@ -826,8 +833,7 @@ hns3_get_link_fc_info(FILE *file, struct rte_eth_dev *dev)
 static void
 hns3_get_flow_ctrl_info(FILE *file, struct rte_eth_dev *dev)
 {
-	struct hns3_adapter *hns = dev->data->dev_private;
-	struct hns3_hw *hw = &hns->hw;
+	struct hns3_hw *hw = HNS3_DEV_PRIVATE_TO_HW(dev->data->dev_private);
 
 	fprintf(file, "  - Flow Ctrl Info:\n");
 	fprintf(file,
@@ -849,6 +855,7 @@ hns3_eth_dev_priv_dump(struct rte_eth_dev *dev, FILE *file)
 	hns3_get_device_basic_info(file, dev);
 	hns3_get_dev_feature_capability(file, hw);
 	hns3_get_rxtx_queue_info(file, dev);
+	hns3_get_port_pvid_info(file, hw);
 
 	/*
 	 * VF only supports dumping basic info, feaure capability and queue
diff --git a/drivers/net/hns3/hns3_dump.h b/drivers/net/hns3/hns3_dump.h
new file mode 100644
index 0000000000..8ba7ee866a
--- /dev/null
+++ b/drivers/net/hns3/hns3_dump.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(C) 2022 HiSilicon Limited
+ */
+
+#ifndef _HNS3_DUMP_H_
+#define _HNS3_DUMP_H_
+
+int hns3_eth_dev_priv_dump(struct rte_eth_dev *dev, FILE *file);
+
+#endif /* _HNS3_DUMP_H_ */
diff --git a/drivers/net/hns3/hns3_ethdev.c b/drivers/net/hns3/hns3_ethdev.c
index cac6dd7755..dfc41d2a05 100644
--- a/drivers/net/hns3/hns3_ethdev.c
+++ b/drivers/net/hns3/hns3_ethdev.c
@@ -8,6 +8,7 @@
 
 #include "hns3_ethdev.h"
 #include "hns3_common.h"
+#include "hns3_dump.h"
 #include "hns3_logs.h"
 #include "hns3_rxtx.h"
 #include "hns3_intr.h"
diff --git a/drivers/net/hns3/hns3_ethdev.h b/drivers/net/hns3/hns3_ethdev.h
index fd83bb7109..d6d82c55f9 100644
--- a/drivers/net/hns3/hns3_ethdev.h
+++ b/drivers/net/hns3/hns3_ethdev.h
@@ -874,7 +874,7 @@ struct hns3_adapter {
 
 #define HNS3_DEVARG_MBX_TIME_LIMIT_MS	"mbx_time_limit_ms"
 
-enum {
+enum hns3_dev_cap {
 	HNS3_DEV_SUPPORT_DCB_B,
 	HNS3_DEV_SUPPORT_COPPER_B,
 	HNS3_DEV_SUPPORT_FD_QUEUE_REGION_B,
@@ -1057,7 +1057,6 @@ int hns3_timesync_read_time(struct rte_eth_dev *dev, struct timespec *ts);
 int hns3_timesync_write_time(struct rte_eth_dev *dev,
 			const struct timespec *ts);
 int hns3_timesync_adjust_time(struct rte_eth_dev *dev, int64_t delta);
-int hns3_eth_dev_priv_dump(struct rte_eth_dev *dev, FILE *file);
 
 static inline bool
 is_reset_pending(struct hns3_adapter *hns)
diff --git a/drivers/net/hns3/hns3_ethdev_vf.c b/drivers/net/hns3/hns3_ethdev_vf.c
index aee0c36360..92fbdb90cd 100644
--- a/drivers/net/hns3/hns3_ethdev_vf.c
+++ b/drivers/net/hns3/hns3_ethdev_vf.c
@@ -10,6 +10,7 @@
 
 #include "hns3_ethdev.h"
 #include "hns3_common.h"
+#include "hns3_dump.h"
 #include "hns3_logs.h"
 #include "hns3_rxtx.h"
 #include "hns3_regs.h"
-- 
2.30.0

